{
  "js": [
    {
      "name": "AggregateError",
      "classDeck": "deck",
      "deck": "build-in object",
      "id": 1.2,
      "type": "AggregateError",
      "description": "объект, представляющий собой ошибку, в которую \"завернуты\" несколько возникших ошибок. Такое исключение выбрасывается, когда при выполнении одной операции возможно возникновение множества ошибок - например, при Promise.any() в случае, когда все промисы будут отклонены.\nPromise.any([\n  Promise.reject(new Error(\"some error\")),\n]).catch(e => {\n  console.log(e instanceof AggregateError); // true\n  console.log(e.message);                   // \"All Promises rejected\"\n  console.log(e.name);                      // \"AggregateError\"\n  console.log(e.errors);                    // [ Error: \"some error\" ]\n});",
      "objects": [
        {
          "name": "AggregateError()",
          "classDeck": "card",
          "deck": "AggregateError",
          "id": 1.21,
          "type": "constructor",
          "description": "конструктор в синтаксисе\nnew AggregateError(errors, message)\n создает одну ошибку для нескольких ошибок, которые нужно обернуть в один объект ошибки. errors - итерируемый массив ошибок (которые в действительности могут не быть экземплярами объекта Error), он будет сохранен в свойстве AggregateError.prototype.errors; необязательный параметр message - человекочитаемое описание ошибки. Отлов ошибок такого рода - через instanceof AggregateError."
        },
        {
          "name": "AggregateError.prototype.errors",
          "classDeck": "card",
          "deck": "AggregateError",
          "id": 1.22,
          "type": "property",
          "description": "массив содержащихся в объекте AggregateError ошибок"
        }
      ]
    },
    {
      "name": "Array",
      "classDeck": "deck",
      "deck": "build-in object",
      "id": 1.1,
      "type": "Array",
      "description": "класс Array в JavaScript - глобальный объект, использующийся при создании массивов - списко-подобных высокоуровневых объектов. Прототип массивов имеет методы для операций их обхода и изменения. Ни длина массивов, ни тип данных их элементов не являются в JS фиксированными. Т.к. длину массивов можно изменить в любое время, а данные можно сохранять в массиве необязательно в сплошном порядке, то JavaScript не гарантирует их компактность, это зависит от того, как программист будет их использовать. В основном, эти возможности выгодны разработчикам, но если они для вас нежелательны, в текущем контексте, подумайте об использовании типизированных массивов. Массивы не могут использовать строки в качестве индексов элементов (как в ассоциативных массивах), они должны использовать для этого целые числа. Установка или попытка доступа к нецелым индексам при помощи нотации квадратных скобок (или через точку) не установят и не выберут элемент в массиве, но установят или запросят переменную, ассоциированную с объектом свойств этого массива. Объект свойств массива и список элементов массива - вещи разные, и операции обхода или изменения нельзя применить в этим именованным свойствам. \nНумерация элементов идет с 0, последний элемент идет под индексом length - 1. Использование неверного индекса вернет undefined. Доступ к элементам - только через нотацию с квадратными скобками. Добавление элементов в свободные \"слоты\" соответственно увеличит длину массива (последний слот + 1), уменьшение длины массива приведет к удалению элементов.\nОбщие правила поиска в массивах. Если вам нужен индекс найденного элемента, используйте Array.prototype.findIndex(); если нужен индекс значения, используйте Array.prototype.indexOf() (он похож на метод .findIndex(), но проверяет каждый элемент на равенство значению вместо применения проверяющей функции); если нужно найти значение, существующее в данном массиве, используйте Array.prototype.includes() (и вновь, оно проверяет каждый элемент на равенство значений вместо использования проверяющей функции); если нужно найти все элементы, отвечающие требованиям проверяющей функции, используйте Array.prototype.some(). \nПример с двумерным массивом - создание шахматной доски:\nlet board = [\n  ['R','N','B','Q','K','B','N','R'],\n  ['P','P','P','P','P','P','P','P'],\n  [' ',' ',' ',' ',' ',' ',' ',' '],\n  [' ',' ',' ',' ',' ',' ',' ',' '],\n  [' ',' ',' ',' ',' ',' ',' ',' '],\n  [' ',' ',' ',' ',' ',' ',' ',' '],\n  ['p','p','p','p','p','p','p','p'],\n  ['r','n','b','q','k','b','n','r'] ]\nconsole.log(board.join('\\n') + '\\n\\n')\n// Move King's Pawn forward 2\nboard[4][4] = board[6][4]\nboard[6][4] = ' '\nconsole.log(board.join('\\n'))",
      "objects": [
        {
          "name": "Array()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.11,
          "type": "constructor",
          "description": "в синтаксисе let arr = new Array(el_1, el_2,...) или new Array(arrLength) используется при создании массивов. Элементы el_1, el_2... инициализируются массивом, кроме случая, когда аргумент всего один и это число (тогда расценит этот параметр как задаваемую длину массива - arrLength, значение в диапазоне от 0 до 253 - 1 включительно, создает \"пустые\" слоты со значениями undefined) - работает только в конструкторе, но не при литеральном создании массива. \nСинтаксис литеральной нотации - let arr = [] или [el_1, el2, ...]. "
        },
        {
          "name": "Array[Symbol.species]",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.12,
          "type": "static property",
          "description": "Array[Symbol.species] - свойство-аксессор, возвращающее дефолтный конструктор Array. \nArray[Symbol.species]; // function Array()\nКонструкторы подклассов перезаписывают это значение, но можно это исправить.\nclass MyArray extends Array {\n  // Overwrite MyArray species to the parent Array constructor\n  static get [Symbol.species]() { return Array; }\nНет поддержки в IE."
        },
        {
          "name": "Array.from()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.13,
          "type": "static method",
          "description": "Array.from() - статический метод, создающий новый массив - поверхностную копию массивоподобного или любого другого итерируемого объекта (Map, Set). Синтаксис - Array.from(arrayLike, mapFn, thisArg). arrayLike - изначальный объект. mapFn (необязательно) - функция, которая будет применена к каждому элементу массива. thisArg (необязательно) - значение, которое функция mapFn будет рассматривать как this при вызове. Метод вернет новый эксземпляр массива Array. Более подробно цепочку метода можно описать как Array.from(obj).map(mapFn, thisArg), только без создания промежуточной копии массива. Это особенно важно для определенных подклассов массивов, таких как типизированные массивы, т.к. промежуточный массив обрежет значения первоначального массива, чтобы они соответствовали определенному типу. Начиная с ES2015 стало возможно создавать подклассы как встроенных, так и пользовательских классов. В результате, статические методы, такие как Array.from(), наследуются подклассами Array и создают новые экземпляры подкласса, а не класса Array.\nСоздание массива из строки:\nArray.from('foo');// [ \"f\", \"o\", \"o\" ]\nМассив из коллекции Map:\nconst map = new Map([['1', 'a'], ['2', 'b']]);\nArray.from(map);// [['1', 'a'], ['2', 'b']]\nArray.from(map.values());// ['a', 'b'];\nArray.from(map.keys());// ['1', '2'];\nМассив из NodeList:\nconst images = document.getElementsByTagName('img');\nconst sources = Array.from(images, image => image.src);\nconst insecureSources = sources.filter(link => link.startsWith('http://'));\nСоздание массива аргументов:\nfunction f() {\n  return Array.from(arguments);\n}\nf(1, 2, 3);// [ 1, 2, 3 ]\nПрименение стрелочных функций с этим методом:\nArray.from([1, 2, 3], x => x + x);// [2, 4, 6]\n// Generate a sequence of numbers. Since the array is initialized with `undefined` on each position, the value of `v` below will be `undefined`\nArray.from({length: 5}, (v, i) => i);// [0, 1, 2, 3, 4]\nconst range = (start, stop, step) => Array.from({ length: (stop - start) / step + 1}, (_, i) => start + (i * step));\nrange(0, 4, 1);// [0, 1, 2, 3, 4]\nrange(1, 10, 2);// [1, 3, 5, 7, 9]\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.isArray()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.14,
          "type": "static method",
          "description": "Array.isArray() - статический метод, определяющий в синтаксисе Array.isArray(value), является ли переданное значение value массивом Array. Возвращает true или false. "
        },
        {
          "name": "Array.of()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.15,
          "type": "static method",
          "description": "Array.of() - статический метод, создающий новый экземпляр массива Array из произвольного числа аргументов, независимо от их количества и типа. Отличает метод от конструктора Array() обработкой аргумента в виде одного целого числа: Array.of(7) создает массив с единственным элементом 7, в то время как Array(7) создаст пустой массив с длиной 7 (в реальности, он не будет совсем пустым, у него будут слоты со значениями undefined). Возвращает новый экземпляр массива. Метод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.length",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.16,
          "type": "property",
          "description": "Array.prototype.length - свойство объекта типа Array, устанавливающее или возвращающее количество элементов в данном массиве. Значение - беззнаковое 32-битное целое число, всегда бОльшее самого большого индекса в этом массиве, т.е. число от 0 до 253 (не включительно). Вы можете в любой момент установить заданную длину для \"обрезки\" массива (\"лишние\" элементы будут удалены). Когда вы \"расширяете\" массив, увеличивая длину, количество элементов увеличивается, но это будут пустые неперебираемые слоты со значениями undefined. \nvar numbers = [];\nnumbers.length = 3;\nconsole.log(numbers); // [undefined, undefined, undefined]\nСвойство перезаписываемое, но не перечисляемое и неизменяемое.   "
        },
        {
          "name": "Array.prototype[Symbol.unscopables]",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.17,
          "type": "property",
          "description": "Array.prototype[Symbol.unscopables] - символьное свойство, содержащее имена свойств, не включенных в стандарт до ES2015. Они исключаются из применяемых с устаревшим оператором привязки with (т.е. они не \"видны\" оператору). Это свойства at(), copyWithin(), entries(), fill(), find(), findIndex(), includes(), keys(), values(). Свойство неперезаписываемое, неперечисляемое, но изменяемое (конфигурируемое). Не поддерживается в IE."
        },
        {
          "name": "Array.prototype.at()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.18,
          "type": "method",
          "description": "Array.prototype.at() - внутренний метод в синтаксисе arr.at(index) принимающий целое значение индекса элемента index и возвращающий элемент массива arr по этому индексу. Разрешены отрицательные значения - они означают отсчет с конца массива. У последнего элемента индекс равен -1. Если указанного индекса не существует, вернет undefined. Метод - самый лаконичный и удобочитаемый среди методов нахождения предпоследнего (-2) элемента массива. Но у него пока еще очень плохая поддержка, он поддерживается фактически только в Chrome и Edge. "
        },
        {
          "name": "Array.prototype.concat()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.19,
          "type": "method",
          "description": "Array.prototype.concat() - внутренний метод, использующийся для объединения двух или более массивов. Не меняет первоначальные массивы, возвращает новый массив. Синтаксис - const newArr = oldArr.concat(value_1, value_2, ...). Параметры value... - значения и/или массивы, которые надо слить с изначальным массивом oldArr. Если всем параметры опущены, будет возвращена поверхностная копия изначального массива. Добавляет аргументы в том порядке, в котором они находятся, элементы этого аргумента (если это массив) или сам аргумент (если это не массив). Не обрабатывает рекурсивно вложенные массивы аргументов (т.е. переносит в новый массив ссылку на массив-аргумент). Метод не меняет значение this или любой из обрабатываемых как аргументы массив, но возвращает поверхностную копию, содержащую копии тех же элементов, взятых в оригинальных массивах. Эти элементы копируются в новый массив следующим образом: Ссылки на объекты (а не сами объекты) - метод копирует ссылки на объекты в новый массив, оба, и старый, и новый массивы ссылаются на один и тот же объект, следовательно, при изменении объекта эти изменения видны новому, и оригинальным массивам. Это касается и элементов массивов-аргументов, которые сами являются массивами. Данные разных типов - строки, числа и булевы значения (не объекты String, Number или Boolean) - метод копирует значения в новый массив. \nconst num1 = [1, 2, 3];\nconst num2 = [4, 5, 6];\nconst num3 = [7, 8, 9];\nconst numbers = num1.concat(num2, num3);\nconsole.log(numbers);// [1, 2, 3, 4, 5, 6, 7, 8, 9]\nОбъединение массивов с добавлением элементов из них:\nconst letters = ['a', 'b', 'c'];\nconst alphaNumeric = letters.concat(1, [2, 3]);\nconsole.log(alphaNumeric);// ['a', 'b', 'c', 1, 2, 3]\nСлияние с вложенными массивами:\nconst num1 = [[1]];\nconst num2 = [2, [3]];\nconst numbers = num1.concat(num2);\nconsole.log(numbers);// [[1], 2, [3]]\nnum1[0].push(4);\nconsole.log(numbers);// [[1, 4], 2, [3]]"
        },
        {
          "name": "Array.prototype.copyWithin()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.121,
          "type": "method",
          "description": "Array.prototype.copyWithin() - метод в синтаксисе arr.copyWithin(target, start, end) создает поверхностную копию части массива, начиная с элемента start (если пропущен, начнет отсчет с 0, при отрицательном значении считает элементы с конца) и заканчивая end (не включительно, при отрицательном значении считает с конца массива, если пропущен - значением будет arr.length) и копирует ее в этот же массив на место элементов, начиная с target. Возвращает массив с его неизмененной длиной. \n[1, 2, 3, 4, 5].copyWithin(-2);// [1, 2, 3, 1, 2]\n[1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5]\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4);// [4, 2, 3, 4, 5]\n[1, 2, 3, 4, 5].copyWithin(-2, -3, -1);// [1, 2, 3, 3, 4]\n[].copyWithin.call({length: 5, 3: 1}, 0, 3);// {0: 1, 3: 1, length: 5}\nvar i32a = new Int32Array([1, 2, 3, 4, 5]);\ni32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]\nНе поддерживается в IE."
        },
        {
          "name": "Array.prototype.entries()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.122,
          "type": "method",
          "description": "Array.prototype.entries() - метод в синтаксисе arr.entries() возвращает новый объект итератора массива, содержащий пары ключ/значение для каждого индекса в массиве. \nconst a = ['a', 'b', 'c'];\nfor (const [index, element] of a.entries())\n  console.log(index, element);\n// 0 'a'\n// 1 'b'\n// 2 'c'"
        },
        {
          "name": "Array.prototype.every()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.123,
          "type": "method",
          "description": "Array.prototype.every() - метод в синтаксисе arr.every(callback(element, index, array), thisArg) проверяет, все ли элементы массива соответствуют условиям, изложенным в колбэк-функции. Возвращает булево значение - true, если колбэк-функция вернет true для каждого элемента, иначе работа метода будет немедленно прервана и вернется false. Колбэк-функция принимает три аргумента: обязательный element - текущий обрабатываемый элемент массива, необязательный index - индекс обрабатываемого элемента и необязательный array - массив, на котором вызван метод. Интересно, что вызванный на пустом массиве метод вернет true при любой колбэк-функции. Функция вызывается для каждого индекса, имеющего присвоенные значения. Не вызывается для удаленных индексов или которым значения ни разу не присваивались. Если методу передается опциональный аргумент thisArg, он будет использоваться как значение this колбэк-функции, иначе будет использоваться undefined. Метод не меняет массив, на котором вызван. Диапазон всех элементов для обработки колбэк-функцией устанавливается до первого вызова колбэка, так что функция не обработает элементы, добавленные к массиву после того, как метод начал свою работу. Если значения элементов меняются, будет рассмотрено значение в тот момент, когда элемент будет передан колбэк-функции. Удаленные элементы метод не посетит. \nfunction isBigEnough(element, index, array) {\n  return element >= 10;\n}\n[12, 5, 8, 130, 44].every(isBigEnough);   // false\n[12, 54, 18, 130, 44].every(isBigEnough); // true\nТо же самое с применением стрелочных функций.\n[12, 5, 8, 130, 44].every(x => x >= 10);   // false\n[12, 54, 18, 130, 44].every(x => x >= 10); // true"
        },
        {
          "name": "Array.prototype.fill()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.124,
          "type": "method",
          "description": "Array.prototype.fill() - метод в синтаксисе arr.fill(value, start, end) заменяет все элементы массива, начиная с индекса start (по умолчанию 0, если значение отрицательное, оно рассматривается как arr.length + start) и заканичивая end (по умолчанию, arr.length, если значение отрицательное, оно рассматривается как arr.length + end) на статическое значение value. Возвращает обновленный массив, заполненный значениями value. Метод намеренно является групповым (generic): он не требует, чтобы значение this было объектом Array. Это изменяющий метод: он изменит массив и вернет его же, а не его копию. Если первый аргумент - объект, каждый слот в массиве будет заполнен ссылкой на этот объект. \n[1, 2, 3].fill(4) // [4, 4, 4]\n[1, 2, 3].fill(4, 1)   // [1, 4, 4]\n[1, 2, 3].fill(4, 3, 3)  // [1, 2, 3]\n[1, 2, 3].fill(4, NaN, NaN) // [1, 2, 3]\nArray(3).fill(4) // [4, 4, 4]\n[].fill.call({ length: 3 }, 4)   // {0: 4, 1: 4, 2: 4, length: 3}\nlet arr = Array(3).fill({}) // [{}, {}, {}]\narr[0].hi = \"hi\"// [{ hi: \"hi\" }, { hi: \"hi\" }, { hi: \"hi\" }]\nПример с созданием матрицы из единиц:\nconst arr = new Array(3);\nfor (let i=0; i<arr.length; i++) {\n  arr[i] = new Array(4).fill(1); // Creating an array of size 4 and filled of 1\n}\narr[0][0] = 10;\nconsole.log(arr[0][0]); // 10\nconsole.log(arr[1][0]); // 1\nconsole.log(arr[2][0]); // 1\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.filter()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.125,
          "type": "method",
          "description": "Array.prototype.filter() - метод в синтаксисе let newArray = arr.filter(callback(currentValue, index. array), thisArg) создает новый массив из всех соответствующих требованию колбэк-функции элементов массива arr, на котором вызван. Колбэк - функция-предикат (возвращает логическое значение) для проверки элемента массива. true заставит скопировать элемент в новый массив, false - не копировать. сurrentValue - текущий обрабатываемый элемент. Необязательные параметры - index (текущий индекс обрабатываемого элемента), array - массив, к которому применяется метод и thisArg - значение this для вызываемой колбэк-функции. Если в новый массив не будет передан ни один элемент, вернется пустой массив. Функция вызывается для каждого индекса, имеющего присвоенные значения. Не вызывается для удаленных индексов или которым значения ни разу не присваивались. Метод не изменяет массив, на котором вызван. Диапазон всех элементов для обработки колбэк-функцией устанавливается до первого вызова колбэка, так что функция не обработает элементы, добавленные к массиву после того, как метод начал свою работу. Если значения элементов меняются, будет рассмотрено значение в тот момент, когда элемент будет передан колбэк-функции. Удаленные элементы метод не посетит. \nfunction isBigEnough(value) {\n  return value >= 10\n}\nlet filtered = [12, 5, 8, 130, 44].filter(isBigEnough)// filtered is [12, 130, 44]\nПример с отбором всех простых чисел из имеющегося массива:\nconst array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];\nfunction isPrime(num) {\n  for (let i = 2; num > i; i++) {\n    if (num % i == 0) {\n      return false;\n    }\n  }\n  return num > 1;\n}\nconsole.log(array.filter(isPrime)); // [2, 3, 5, 7, 11, 13]\nФильтрация неверных вводных данных из JSON:\nlet arr = [\n  { id: 15 },\n  { id: -1 },\n  { id: 0 },\n  { id: 3 },\n  { id: 12.2 },\n  { },\n  { id: null },\n  { id: NaN },\n  { id: 'undefined' }\n]\nlet invalidEntries = 0\nfunction filterByID(item) {\n  if (Number.isFinite(item.id) && item.id !== 0) {\n    return true\n  }\n  invalidEntries++\n  return false;\n}\nlet arrByID = arr.filter(filterByID)\nconsole.log('Filtered Array\\n', arrByID)// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]\nconsole.log('Number of Invalid Entries = ', invalidEntries)// Number of Invalid Entries = 5\nПоиск по символам или фразе в массиве:\nconst fruits = ['apple', 'banana', 'grapes', 'mango', 'orange']\nconst filterItems = (arr, query) => {\n  return arr.filter(el => el.toLowerCase().indexOf(query.toLowerCase()) !== -1)\n}\nconsole.log(filterItems(fruits, 'ap'))  // ['apple', 'grapes']\nconsole.log(filterItems(fruits, 'an'))  // ['banana', 'mango', 'orange']"
        },
        {
          "name": "Array.prototype.find()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.126,
          "type": "method",
          "description": "Array.prototype.find() - метод в синтаксисе arr.find(callback(element, index.array), thisArg) возвращает значение первого найденного в массиве arr элемента, отвечающее проверке функцией callback. Если такого значения не найдено, вернет undefined. \nОбщие правила поиска в массивах. Если вам нужен индекс найденного элемента, используйте Array.prototype.findIndex(); если нужен индекс значения, используйте Array.prototype.indexOf() (он похож на метод .findIndex(), но проверяет каждый элемент на равенство значению вместо применения проверяющей функции); если нужно найти значение, существующее в данном массиве, используйте Array.prototype.includes() (и вновь, оно проверяет каждый элемент на равенство значений вместо использования проверяющей функции); если нужно найти все элементы, отвечающие требованиям проверяющей функции, используйте Array.prototype.some(). \nCallback-функция метода принимает три аргумента: текущий элемент массива element, текущий индекс (положение) элемента в массиве index и массив, на котором вызван метод array. Опциональный аргумент метода - thisArg - объект, который следует использовать как this внутри колбэк-функции. Будьте осторожны с возвращаемым значением и условными операторами, индекс 0 оператор if или другие предикативные конструкции расценят как false. Механика метода: колбэк-функция вызывается для каждого индекса в массиве, при первом же найденном соответствии метод будет прерван и вернет этот элемент. Метод обрабатывает все индексы, в т.ч. без присвоенных значений, поэтому он может быть менее эффективен в парсинге массивов, чем тот, что просматривает в массивах только индексы с присвоенными значениями. Если указан thisArg, он будет использоваться как this внутри колбэк-функции при каждом ее вызове, иначе используется undefined. Метод не изменяет массив, на котором вызван, но колбэк-функция внутри него может это делать. А раз так, то элементы, обрабатываемые методом find, инициализируются перед первым вызовом колбэк-функции. Исходя из этого: колбэк-функция не обработает никакой элемент, добавленный в массив после начала работы метода; если существующий в массиве элемент еще не обработан и изменяется колбэком, его значение, передаваемое колбэк-функции, будет значением, существующим на момент посещения индекса элемента; удаленные элементы также посещаются методом. \nconst inventory = [\n  {name: 'apples', quantity: 2},\n  {name: 'bananas', quantity: 0},\n  {name: 'cherries', quantity: 5}\n];\nfunction isCherries(fruit) {\n  return fruit.name === 'cherries';\n}\nconsole.log(inventory.find(isCherries));// { name: 'cherries', quantity: 5 }\nТо же с использованием стрелочной функции:\nconst result = inventory.find( ({ name }) => name === 'cherries' );\nconsole.log(result) // { name: 'cherries', quantity: 5 }\nНахождение простого числа в массиве:\nfunction isPrime(element, index, array) {\n  let start = 2;\n  while (start <= Math.sqrt(element)) {\n    if (element % start++ < 1) {\n      return false;\n    }\n  }\n  return element > 1;\n}\nconsole.log([4, 6, 8, 12].find(isPrime)); // undefined, not found\nconsole.log([4, 5, 8, 12].find(isPrime)); // 5\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.findIndex()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.127,
          "type": "method",
          "description": "Array.prototype.findIndex() - метод в синтаксисе arr.findIndex(callback(element, index, array), thisArg) возвращает индекс первого найденного в массиве элемента, отвечающего требованиям проверочной функции callback. Если элемент не найден или arr.length = 0, вернет -1. Отличается от метода Array.prototype.find() возвращаемым значением - возвращает индекс, а .find() возвращает значение найденного элемента. callback - функция, запускаемая на каждом значении в массиве, пока она не вернет true, показывая, что найден элемент, соответствующий всем условиям. Принимает три аргумента: element - текущий обрабатываемый элемент в массиве, index (необязательно) - индекс обрабатываемого в данный момент элемента, array (необязательно) - массив, на котором вызывается метод. Также есть необязательный параметр thisArg - объект this, передаваемый колбэк-функции при ее вызове. Иначе ей передается undefined. В отличие от других методов массива, таких как Array.some(), колбэк-функция вызывается и для индексов без присвоенных значений. Диапазон обрабатываемых элементов устанавливается до первого вызова колбэка, он не будет включать элементы, добавленные в массив после начала работы метода. Если элемент существует в массиве, но еще не посещен и изменяется колбэком, его значение, передаваемое колбэк-функции, будет значением, существовавшим на момент посещения индекса методом. Удаленные элементы также обходятся методом. Пример с нахождением индекса простого числа в массиве:\nfunction isPrime(num) {\n  for (let i = 2; num > i; i++) {\n    if (num % i == 0) {\n      return false;\n    }\n  }\n  return num > 1;\n}\nconsole.log([4, 6, 8, 9, 12].findIndex(isPrime)); // -1, not found\nconsole.log([4, 6, 7, 9, 12].findIndex(isPrime)); // 2 (array[2] is 7)\nПример с применением стрелочных функций:\nconst fruits = [\"apple\", \"banana\", \"cantaloupe\", \"blueberries\", \"grapefruit\"];\nconst index = fruits.findIndex(fruit => fruit === \"blueberries\");\nconsole.log(index); // 3\nconsole.log(fruits[index]); // blueberries\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.forEach()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.128,
          "type": "method",
          "description": "Array.prototype.forEach() - метод в синтаксисе arr.forEach(callback(currentValue, index, array), thisArg) запускает колбэк-функцию для каждого элемента массива. Колбэк принимает до трех аргументов: обязательный currentValue - текущий обрабатываемый элемент массива, необязательный index - индекс обрабатываемого элемента и необязательный array - массив, на котором вызван метод. Необязательный параметр thisArg - значение, рассматриваемое как this при запуске колбэка (при использовании стрелочных функций аргумент нужно пропустить). Возвращаемое значение - undefined. Колбэк вызывается для каждого элемента в массиве в порядке возрастания. Она не вызывается для индексов удаленных или неинициализированых свойств (как у разреженных массивов). Диапазон обрабатываемых элементов устанавливается до первого вызова колбэка, он не будет включать элементы, добавленные в массив после начала работы метода. Если элемент существует в массиве, но еще не посещен и изменяется колбэком, его значение, передаваемое колбэк-функции, будет значением, существовавшим на момент посещения индекса методом. Удаленные перед посещением метода элементы не посещаются. Если уже посещенный элемент удаляется (например, при помощи .shift()) во время итерации, то элемент, следующий за удаленным элементом, пропускается (т.к. в данном случае индекс сдвигается и на место удаленного \"встает\" следующий элемент). В измененном массиве он, естественно, останется.\nlet words = ['one', 'two', 'three', 'four']\nwords.forEach(function(word) {\n  console.log(word)\n  if (word === 'two') {\n    words.shift() //'one' will delete from array\n  }\n}) // one // two // four\nconsole.log(words);  //['two', 'three', 'four']\nМетод не делает копию массива перед его обработкой. В отличие от методов .map() или .reduce() он всегда возвращает undefined и не применяется по цепочке. Типичное применение - запуск побочных эффектов в конце цепочки. Сам метод не меняет массив, на котором вызван, а вот колбэк может. Никакого другого способа для остановки цикла метода, кроме выброса исключения, нет. Если для вас важна возможность его прерывания, этот метод для вас не подходит. Досрочное прерывание можно выполнить применением: простого цикла for, циклами for ... of / for ... in, методами Array.prototype.every(), Array.prototype.some(), Array.prototype.find(), Array.prototype.findIndex(). Метод ожидает синхронной функции, он не ждет промисов. Трижды убедитесь, что не возникает осложнений, если вы используете промисы (или асинхронные функции) в качестве колбэк-функции метода forEach(). \nПример с пропуском неинициализированных элементов (колбэк для них не вызывается):\nconst arraySparse = [1,3,,7]\nlet numCallbackRuns = 0\narraySparse.forEach(function(element) {\n  console.log(element)\n  numCallbackRuns++\n})\nconsole.log(\"numCallbackRuns: \", numCallbackRuns)\n// 1\n// 3\n// 7\n// numCallbackRuns: 3\nЗамена цикла методом:\nconst items = ['item1', 'item2', 'item3']\nconst copyItems = []\n// before\nfor (let i = 0; i < items.length; i++) {\n  copyItems.push(items[i])\n}\n// after\nitems.forEach(function(item){\n  copyItems.push(item)\n})\nЗамена методу console.log() для построчного вывода индекса и значения элементов массива:\nfunction logArrayElements(element, index, array) {\n  console.log('a[' + index + '] = ' + element)\n}\n[2, 5, , 9].forEach(logArrayElements)\n// logs:\n// a[0] = 2\n// a[1] = 5\n// a[3] = 9\nПример с использованием аргумента this:\nfunction Counter() {\n  this.sum = 0\n  this.count = 0\n}\nCounter.prototype.add = function(array) {\n  array.forEach(function countEntry(entry) {\n    this.sum += entry\n    ++this.count\n  }, this)\n}\nconst obj = new Counter()\nobj.add([2, 5, 9])\nobj.count // 3\nobj.sum // 16\nПример с выравниванием масива (но лучше использовать метод .flat()):\nfunction flatten(arr) {\n  const result = []\n  arr.forEach(function(i) {\n    if (Array.isArray(i)) {\n      result.push(...flatten(i))\n    } else {\n      result.push(i)\n    }\n  })\n  return result\n}\nconst nested = [1, 2, 3, [4, 5, [6, 7], 8, 9]]\nflatten(nested) // [1, 2, 3, 4, 5, 6, 7, 8, 9]"
        },
        {
          "name": "Array.prototype.includes()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.129,
          "type": "method",
          "description": "Array.prototype.includes() - метод в синтаксисе arr.includes(value, index) определяет, содержит ли данный массив arr значение value среди своих данных, возвращая в зависимости от этого true или false. В поиске строк и символов метод регистрозависим. Необязательный аргумент index - индекс в массиве, с которого следует начать поиск (по умолчанию 0, при отрицательных значених начнет с элемента arr.length + index, если равен длине массива или больше ее - вернется false). -0, +0 и 0 считает равными, но false не интерпретирует как 0. \nПри негативных значениях index метод использует вычисленный индекс. Если он меньше или равен -1 * arr.length, будет инициирован поиск во всем массиве.\n// array length is 3, fromIndex is -100, computed index is 3 + (-100) = -97\nlet arr = ['a', 'b', 'c'];\narr.includes('a', -100); // true\narr.includes('b', -100); // true\narr.includes('c', -100); // true\narr.includes('a', -2);  // false\nМетод намеренно разработан общим - т.е. ему не обязательно быть вызванным на массиве, его можно применять и на других объектах, например, на массивомподобных объектах, таких как arguments. \n(function() {\n  console.log(Array.prototype.includes.call(arguments, 'a'))  // true\n  console.log(Array.prototype.includes.call(arguments, 'd'))  // false\n})('a','b','c')Метод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.indexOf()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.131,
          "type": "method",
          "description": "Array.prototype.indexOf() - метод в синтаксисе arr.indexOf(element, index) вернет первый индекс, по которому будет найден элемент element в массиве arr, или -1, если такой элемент не будет найден. Необязательный аргумент index - индекс, с которого следует начать поиск. Если он больше или равен длине массива, вернется -1 (что означает, поиск не был проведен). Отрицательное значение рассматривается как отступ от конца массива, (но поиск в любом случае будет идти в направлении слева направо). Значение по умолчанию - 0 (поиск по всему массиву). Метод использует при поиске строгое сравнение (===). Для строк применяется String.prototype.indexOf(). \nПример с нахождением всех вхождений элемента:\nvar indices = [];\nvar array = ['a', 'b', 'a', 'c', 'a', 'd'];\nvar element = 'a';\nvar idx = array.indexOf(element);\nwhile (idx != -1) {\n  indices.push(idx);\n  idx = array.indexOf(element, idx + 1);\n}\nconsole.log(indices);// [0, 2, 4]"
        },
        {
          "name": "Array.prototype.join()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.132,
          "type": "method",
          "description": "Array.prototype.join() - метод в синтаксисе arr.join(separator) создает и возвращает новую строку из всех элементов массива (или массивоподобного объекта) arr, разделенных запятой (по умолчанию) или другим разделителем separator. Если в массиве всего один элемент - вернется строка из одного элемента без разделителей. Задав в качестве разделителя пустую строку, мы получим строку из элементов, ничем не отделенных друг от друга. При пустом массиве, а также если единственным элементом массива является null или undefined, вернется пустая строка. \nvar a = ['Wind', 'Water', 'Fire'];\na.join();      // 'Wind,Water,Fire'\na.join(', ');  // 'Wind, Water, Fire'\na.join(' + '); // 'Wind + Water + Fire'\na.join('');    // 'WindWaterFire'"
        },
        {
          "name": "Array.prototype.keys()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.133,
          "type": "method",
          "description": "Array.prototype.keys() - метод в синтаксисе arr.keys() возвращает новый итератор объекта Array, содержащий ключи (индекс) для каждого индекса в массиве. Метод в том числе обходит индексы с неприсвоенными значениями (пустые слоты).\nvar arr = ['a', , 'c'];\nvar sparseKeys = Object.keys(arr);\nvar denseKeys = [...arr.keys()];\nconsole.log(sparseKeys); // ['0', '2']\nconsole.log(denseKeys);  // [0, 1, 2]\nНе поддерживается в IE."
        },
        {
          "name": "Array.prototype.lastIndexOf()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.134,
          "type": "method",
          "description": "Array.prototype.lastIndexOf() - метод в синтаксисе arr.lastIndexOf(element, index) возвращает последний индекс вхождения искомого элемента element в массиве arr, или -1, если элемент не будет найден. Поиск идет в обратном порядке - справа налево, начиная с индекса index (необязательный аргумент, по умолчанию - arr.length - 1, в этом случае поиск идет по всему массиву). Если index больше или равен длине массива, поиск также будет вестись по всему массиву, отрицательное значение рассматривается как отступ от конца массива (но поиск ведется так же слева направо). При отрицательных значениях index использует вычисленный индекс, и если он равен или меньше 0, метод вернет -1. Использует строгое сравнение (===). \nvar numbers = [2, 5, 9, 2];\nnumbers.lastIndexOf(2);     // 3\nnumbers.lastIndexOf(7);     // -1\nnumbers.lastIndexOf(-7);// -1\nnumbers.lastIndexOf(2, 3);  // 3\nnumbers.lastIndexOf(2, 2);  // 0\nnumbers.lastIndexOf(2, -2); // 0\nnumbers.lastIndexOf(2, -1); // 3"
        },
        {
          "name": "Array.prototype.map()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.135,
          "type": "method",
          "description": "Array.prototype.map() - метод в синтаксисе let newArray = arr.map(callback(currentValue, index, array), thisArg) создает новый массив, заполненный результатами применения к каждому элементу массива arr колбэк-функции. Колбэк принимает три аргумента: обязательный currentValue - текущий обрабатываемый элемент массива, необязательный index - индекс текущего элемента, необязательный array - массив, на котором вызван метод. Опциональный аргумент thisArg - значение, которое будет рассматриваться как this колбэк-функцией. Колбэк будет вызываться только для индексов с присвоенными значениями (даже если им присвоено undefined). Но не вызывается для пропущенных элементов, если они были удалены или никогда не устанавливались. Диапазон обрабатываемых элементов устанавливается до первого вызова колбэка. Элементы, добавленные в массив после начала работы метода не будут посещены колбэк-функцией. Если элемент существует в массиве и изменяется после вызова метода, его значением будет значение в момент его посещения колбэком. Удаленные после вызова метода элементы, но до их посещения колбэком, им уже не посещаются. В соответствии с установленным алгоритмом, если массив, ан котором вызывается метод, является разреженным, итоговый массив также будт разреженным с пустыми слотами в тех же индексах, что и в изначальном массиве. \nПример с преобразованием массива чисел в массив квадратных корней из них:\nlet numbers = [1, 4, 9]\nlet roots = numbers.map(function(num) {\n    return Math.sqrt(num)\n})\n// roots is now     [1, 2, 3]\n// numbers is still [1, 4, 9]\nПереформатирование объектов в массив:\nlet kvArray = [{key: 1, value: 10},\n               {key: 2, value: 20},\n               {key: 3, value: 30}]\nlet reformattedArray = kvArray.map(obj => {\n   let rObj = {}\n   rObj[obj.key] = obj.value\n   return rObj\n})// reformattedArray is now [{1: 10}, {2: 20}, {3: 30}],\nИспользование колбэк-функцией аргумента, берущегося из элемента. Но с этим надо быть осторожным, некоторые функции могут неправильно \"перенять\" аргументы (как, например, parseInt может неправильно расценить второй аргумент, у нее это обычно система счисления):\nlet numbers = [1, 4, 9]\nlet doubles = numbers.map(function(num) {\n  return num * 2\n})\n// doubles is now   [2, 8, 18]\n// numbers is still [1, 4, 9]\nПример общего использования метода на примере со строками:\nlet map = Array.prototype.map\nlet a = map.call('Hello World', function(x) {\n  return x.charCodeAt(0)\n})// a now equals [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]"
        },
        {
          "name": "Array.prototype.pop()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.136,
          "type": "method",
          "description": "Array.prototype.pop() - метод в синтаксисе arr.pop() удаляет последний элемент массива и возвращает его. Изменяет длину массива. В случае, если массив пуст, вернет undefined. Метод намеренно сделан общим, он может быть вызван или применен (при помощи Function.prototype.call() или Function.prototype.apply()) к объектам, похожим на массивы. Объекты, не имеющие свойства length, отражающее последний элемент в цепочке на основе числовых характеристик с отсчетом от 0, могут вести себя непредсказуемо. \nМетод Array.prototype.shift() ведет себя похожим образом, но удаляет элемент из начала массива.\nПример применения на массивоподобном объекте:\nvar myFish = {0:'angel', 1:'clown', 2:'mandarin', 3:'sturgeon', length: 4};\nvar popped = Array.prototype.pop.call(myFish); //same syntax for using apply( )\nconsole.log(myFish); // {0:'angel', 1:'clown', 2:'mandarin', length: 3}\nconsole.log(popped); // 'sturgeon'"
        },
        {
          "name": "Array.prototype.push()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.137,
          "type": "method",
          "description": "Array.prototype.push() - метод в синтаксисе arr.push(element_1, element_2, ...) добавляет один или более элементов в конец массива и возвращает новую длину массива. Метод намеренно сделан общим, он может быть вызван или применен (при помощи \nFunction.prototype.call() или Function.prototype.apply()) к объектам, похожим на массивы. Метод push основан на свойстве длины (length), определяющем где начать вставку данных значений. Если значение свойства не может быть приведено к числу, вместо него берется индекс 0. Это делает возможными случаи с отсутствующим свойством length, в результате это свойство будет создано. Несмотря на то, что строки по своей природе являются массивоподобными объектами, они не подходят для применения этого метода, так как неизменяемы. Это же касается объекта arguments. \nПример со слиянием массивов (будьте осторожны с количеством элементов в добавляемом массиве, он не должен быть большим, чтобы функция .apply() не \"перебрала\" с ограниченным количеством аргументов):\nlet vegetables = ['parsnip', 'potato']\nlet moreVegs = ['celery', 'beetroot']\nArray.prototype.push.apply(vegetables, moreVegs)\nconsole.log(vegetables)  // ['parsnip', 'potato', 'celery', 'beetroot']\nПример с использованием в массивоподобных абъектах:\nlet obj = {\n    length: 0,\n    addElem: function addElem(elem) {\n        // length is automatically incremented every time an element is added.\n        [].push.call(this, elem)\n    }\n}\nobj.addElem({})\nobj.addElem({})\nconsole.log(obj.length)// → 2"
        },
        {
          "name": "Array.prototype.reduce()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.138,
          "type": "method",
          "description": "Array.prototype.reduce() - метод в синтаксисе arr.reduce(callback(accumulator, currentValue, index, array), initialValue) запускает функцию преобразования (reducer) на каждом элементе массива, результатом которой на выходе становится единственное значение. Колбэк-функция преобразования принимает 4 аргумента: суммируемое значение accumulator (обязательный аргумент), текущий обрабатываемый элемент сurrentValue (обязательный), текущий индекс элемента index (необязательный, если предоставлен аргумент initialValue, начнет с 0, иначе начнет с индекса 1, приняв первый элемент массива за initialValue) и \"исходный\" массив array (также необязательный). Возвращаемым значением функции будет суммируемое значение, присваиваемое accumulator, запоминаемое на каждой итерации при прохождении массива, которое в итоге становится результирующим значением. Необязательный параметр initialValue - изначальное значение, принимаемое функцией как первый аргумент при первом вызове. Иначе изначальным accumulator становится первый элемент массива, а как currentValue он будет пропущен. Запуск .reduce() на пустом массиве без initialValue приведет к ошибке TypeError. \nПрименимы стрелочные функции:\n[0, 1, 2, 3, 4].reduce( (accumulator, currentValue, currentIndex, array) => accumulator + currentValue )\nДругими словами. При первом вызове колбэка accumulator и currentValue могут быть одним из двух значений. Если указан initialValue, то accumulator принимается равным initialValue и currentValue будет равен первому значению в массиве. Если initialValue не указан, accumulator равен первому значению в массиве и currentValue равен второму (следующему) значению массива. В первом случае колбэк запустится на индексе 0, во втором - на индексе 1. Соответственно, если в массиве всего один элемент и initialValue не указан, или initialValue указан, но массив пуст - вернется это единственное значение (единственный элемент или initialValue) без запуска колбэка. Лучше всегда предоставлять initialValue, метод будет работать лучше, в т.ч. на пустых и больших массивах.\nlet maxCallback = ( acc, cur ) => Math.max( acc.x, cur.x );\nlet maxCallback2 = ( max, cur ) => Math.max( max, cur );\n[ { x: 2 }, { x: 22 }, { x: 42 } ].reduce( maxCallback ); // NaN\n[ { x: 2 }, { x: 22 } ].reduce( maxCallback ); // 22\n[ { x: 2 } ].reduce( maxCallback ); // { x: 2 }\n[].reduce( maxCallback ); // TypeError\n[ { x: 22 }, { x: 42 } ].map( el => el.x )\n                        .reduce( maxCallback2, -Infinity );\nПример с выравниванием (разворачиванием) массива:\nvar flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {\n  return a.concat(b);\n});// flattened равен [0, 1, 2, 3, 4, 5]\nПример с созданием массива элементов из определенного свойства объектов, перечисленных в массиве. С применением spread-оператора.\nlet friends = [{\n  name: 'Anna',\n  books: ['Bible', 'Harry Potter'],\n  age: 21\n}, {\n  name: 'Bob',\n  books: ['War and peace', 'Romeo and Juliet'],\n  age: 26\n}, {\n  name: 'Alice',\n  books: ['The Lord of the Rings', 'The Shining'],\n  age: 18\n}]\n// allbooks - list which will contain all friends' books + additional list contained in initialValue\nlet allbooks = friends.reduce(function(accumulator, currentValue) {\n  return [...accumulator, ...currentValue.books]\n}, ['Alphabet'])\n// allbooks = [\n//   'Alphabet', 'Bible', 'Harry Potter', 'War and peace',\n//   'Romeo and Juliet', 'The Lord of the Rings',\n//   'The Shining'\n// ]\nПример с удалением дубликатов элементов (вместо Array.from(new Set(myArray))):\nlet myArray = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd'];\nlet myOrderedArray = myArray.reduce(function (accumulator, currentValue) {\n  if (accumulator.indexOf(currentValue) === -1) {\n    accumulator.push(currentValue);\n  }\n  return accumulator;\n}, [])\nconsole.log(myOrderedArray);// [a, b, c, e, d]\nПример с группировкой объектов по определенным свойствам:\nlet people = [\n  { name: 'Alice', age: 21 },\n  { name: 'Max', age: 20 },\n  { name: 'Jane', age: 20 }\n];\nfunction groupBy(objectArray, property) {\n  return objectArray.reduce(function (acc, obj) {\n    let key = obj[property]\n    if (!acc[key]) {\n      acc[key] = []\n    }\n    acc[key].push(obj)\n    return acc\n  }, {})\n}\nlet groupedPeople = groupBy(people, 'age')\n// groupedPeople is:\n// {\n//   20: [\n//     { name: 'Max', age: 20 },\n//     { name: 'Jane', age: 20 }\n//   ],\n//   21: [{ name: 'Alice', age: 21 }]\n// }"
        },
        {
          "name": "Array.prototype.reduceRight()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.139,
          "type": "method",
          "description": "Array.prototype.reduceRight() - метод в синтаксисе \narr.reduceRight(callback(accumulator, currentValue, index, array), initialValue) запускает функцию преобразования (reducer) на каждом элементе массива, как метод Array.prototype.reduce(), только с конца массива, справа налево. Результатом становится единственное значение. Колбэк-функция преобразования принимает 4 аргумента: суммируемое значение accumulator (обязательный аргумент) - значение, возвращенное предыдущим вызовом колбэка или initialValue (если оно установлено), текущий обрабатываемый элемент сurrentValue (обязательный), текущий индекс элемента index (необязательный, если предоставлен аргумент initialValue, начнет с 0, иначе начнет с индекса 1, приняв первый элемент массива за initialValue) и \"исходный\" массив array (также необязательный). Возвращаемым значением функции будет суммируемое значение, присваиваемое accumulator, запоминаемое на каждой итерации при прохождении массива, которое в итоге становится результирующим значением. Необязательный параметр initialValue - изначальное значение, принимаемое функцией как первый аргумент при первом вызове. Иначе изначальным accumulator становится последний элемент массива, а как currentValue он будет пропущен. Запуск .reduce() на пустом массиве без initialValue приведет к ошибке TypeError. reduceRight() запускает колбэк-функцию на каждом элементе, представленном в массие, исключая \"дыры\" массива. \nПри первом вызове колбэка accumulator и currentValue могут быть одним из двух значений. Если указан initialValue, то accumulator принимается равным initialValue и currentValue будет равен последнему значению в массиве. Если initialValue не указан, accumulator равен последнему значению в массиве и currentValue равен предпоследнему значению. Соответственно, если в массиве всего один элемент, вне зависимости от его положения, и initialValue не указан, или initialValue указан, но массив пуст - вернется это единственное значение (единственный элемент или initialValue) без запуска колбэка. Лучше всегда предоставлять initialValue, метод будет работать лучше, в т.ч. на пустых и больших массивах.\nПримеры см. у метода Array.prototype.reduce(). Единственное отличие - в направлении обхода массива:\nvar a = ['1', '2', '3', '4', '5'];\nvar left  = a.reduce(function(prev, cur) { return prev + cur; });\nvar right = a.reduceRight(function(prev, cur) { return prev + cur; });\nconsole.log(left);  // \"12345\"\nconsole.log(right); // \"54321\""
        },
        {
          "name": "Array.prototype.reverse()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.141,
          "type": "method",
          "description": "Array.prototype.reverse() - метод в синтаксисе arr.reverse() \"переворачивает\" массив на месте. Первый элемент становится последним, а последний первым. Метод перемещает элементы в массиве и возвращает ссылку на изменившийся массив. \nconst a = [1, 2, 3];\nconsole.log(a); // [1, 2, 3]\na.reverse();\nconsole.log(a); // [3, 2, 1]\nНамеренно разработан общим методом, может быть применен или вызван (при помощи Function.prototype.apply() или Function.prototype.call()) к/на объектах, похожих на массивы. Объекты, не имеющие свойства length, демонстрирующего последний элемент в непрерывном ряду, основанные на начале отсчета с 0 числовые свойства могут вести себя непредсказуемо. \nconst a = {0: 1, 1: 2, 2: 3, length: 3};\nconsole.log(a); // {0: 1, 1: 2, 2: 3, length: 3}\nArray.prototype.reverse.call(a); //same syntax for using apply()\nconsole.log(a); // {0: 3, 1: 2, 2: 1, length: 3}"
        },
        {
          "name": "Array.prototype.shift()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.142,
          "type": "method",
          "description": "Array.prototype.shift() - метод в синтаксисе arr.shift() удаляет первый элемент (по индексу 0) в массиве и возвращает удаленный элемент. Метод изменяет длину массива, \"сдвигая\" значения на 1 единицу вниз в индексе. Если длина уже равна 0, вернет undefined. Метод намеренно сделан общим, так что может быть применен или вызван (при помощи Function.prototype.apply() или Function.prototype.call()) к/на объектах, похожих на массивы. Объекты, не имеющие свойства length, демонстрирующего последний элемент в непрерывном ряду, основанные на начале отсчета с 0 числовые свойства могут вести себя непредсказуемо. Такой же метод для удаления последнего элемента массива - Array.prototype.pop().\nvar myFish = ['angel', 'clown', 'mandarin', 'surgeon'];\nconsole.log('myFish before:', JSON.stringify(myFish));// myFish before: ['angel', 'clown', 'mandarin', 'surgeon']\nvar shifted = myFish.shift();\nconsole.log('myFish after:', JSON.stringify(myFish));// myFish after: ['clown', 'mandarin', 'surgeon']\nconsole.log('Removed this element:', shifted);// Removed this element: angel\nПример с использованием в цикле:\nvar names = [\"Andrew\", \"Edward\", \"Paul\", \"Chris\" ,\"John\"];\nwhile( (i = names.shift()) !== undefined ) {\n    console.log(i);\n}// Andrew, Edward, Paul, Chris, John"
        },
        {
          "name": "Array.prototype.slice()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.143,
          "type": "method",
          "description": "Array.prototype.slice() - метод в синтаксисе arr.slice(start, end) возвращает поверхностную копию части массива arr (начиная с индекса start и до, но не включительно, индекса end) в виде нового объекта массива. Изначальный массив не изменяется. Аргументы необязательные. Индекс start начинает отсчет с 0, негативное значение может быть использовано и означает \"отступ\" от конца массива (slice(-2) выберет два последних элемента). Значение по умолчанию 0, если значение превышает длину массива, будет создан и возвращен пустой массив. Индекс end может быть негативным значением, оно означает \"отступ\" от конца массива (slice(0, -1) выберет все элементы без последнего в массиве). Если индекс не указан, будут выбраны все оставшиеся элементы. \nКак уже было сказано, создается поверхностная копия. Для элементов-объектов в новый массив копируются ссылки на них, и оригинальный, и новый массивы ссылаются на один и тот же объект, так что изменения в нем видны в обоих массивах. Для строк, чисел и булевых значений (не для объектов String, Number или Boolean) метод копирует их в новый массив, их изменения в изначальном массиве не приведут к их изменениям в новом. При добавлении элемента в \"старый\" массив \"новый\" не меняется.\nМетод также привязывается к массивоподобным объектам (при помощи \nFunction.prototype.apply() и Function.prototype.call()).   \nfunction list() {\n  return Array.prototype.slice.call(arguments)\n}\nlet list1 = list(1, 2, 3) // [1, 2, 3]\nВозможен синтаксис [].slice.call(arguments) вместо Array.prototype.slice.call(). Но лучше использовать bind().\nlet unboundSlice = Array.prototype.slice\nlet slice = Function.prototype.call.bind(unboundSlice)\nfunction list() {\n  return slice(arguments)\n}\nlet list1 = list(1, 2, 3) // [1, 2, 3]"
        },
        {
          "name": "Array.prototype.some()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.144,
          "type": "method",
          "description": "Array.prototype.some() - метод в синтаксисе arr.some(callback(element, index, array), thisArg) проверяет, соответствует ли хотя бы один элемент массива arr условиям проверочной функции callback. Возвращает булево значение. Колбэк-функция принимает три аргумента: обязательный параметр element - текущий обрабатываемый элемент, необязательный index - индекс элемента, обрабатываемого в данный момент, и необязательный array - массив, на котором вызван метод. Также необязательный параметр thisArg - значение, используемое как this при вызове колбэк-функции. Колбэк вызывается только для индексов с присвоенными значениями. Функция никогда не будет вызвана для удаленных индексов или индексов, которым ни разу не присваивалось значение ранее. Метод не изменяет массив, на котором вызван. Диапазон рассматриваемых элементов устанавливается до первого вызова колбэк-функции. Элементы, добавленные к массиву после начала работы метода не будут посещены колбэком. Если существующий в массиве, но еще не посещенный элемент изменяется колбэком, значением, передаваемым колбэку, будет то значение, которое было на момент посещения методом данного индекса. Удаленные элементы не посещаются. Вызов метода на пустом массиве всегда вернет false. \nfunction isBiggerThan10(element, index, array) {\n  return element > 10;\n}\n[2, 5, 8, 1, 4].some(isBiggerThan10);  // false\n[12, 5, 8, 1, 4].some(isBiggerThan10); // true\nТо же с использованием стрелочных функций:\n[2, 5, 8, 1, 4].some(x => x > 10);  // false\n[12, 5, 8, 1, 4].some(x => x > 10); // true\nПример с проверкой на существование свойства:\nconst fruits = ['apple', 'banana', 'mango', 'guava'];\nfunction checkAvailability(arr, val) {\n  return arr.some(function(arrVal) {\n    return val === arrVal;\n  });\n}\ncheckAvailability(fruits, 'kela');   // false\ncheckAvailability(fruits, 'banana'); // true\nВариант со стрелочной функцией:\nfunction checkAvailability(arr, val) {\n  return arr.some(arrVal => val === arrVal);\n}\nПример с конвертацией значений в булево значение:\nconst TRUTHY_VALUES = [true, 'true', 1];\nfunction getBoolean(value) {\n  'use strict';\n  if (typeof value === 'string') {\n    value = value.toLowerCase().trim();\n  }\n  return TRUTHY_VALUES.some(function(t) {\n    return t === value;\n  });\n}\ngetBoolean(false);   // false\ngetBoolean('false'); // false\ngetBoolean(1);       // true\ngetBoolean('true');  // true"
        },
        {
          "name": "Array.prototype.sort()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.145,
          "type": "method",
          "description": "Array.prototype.sort() - метод в синтаксисе arr.sort(compareFunction) сортирует элементы массива на месте и возвращает отсортированный массив. По умолчанию метод сортировки - по возрастанию, значения конвертируются в строки и их значением принимается значение кодовых точек в UTF-16. Все элементы со значением undefined переместятся в конец массива, две (или больше) кодовые точки у суррогатных пар оцениваются по раздельности. Затраты времени и ресурсов неоднозначны из-за различий в реализации. \nАргумент compareFunction - функция, определяющая порядок сортировки. Если параметр пропущен, элементы будут конвертироваться в строки, а затем сравниваться по кодовым точкам в Unicode. Если предоставлен - сравнение пойдет по этой функции, все элементы со значением undefined переместятся в конец массива и функция сравнения к ним применяться не будет. Функция оперирует двумя элементами - первым и вторым (a и b): \n- если она возвращает значение меньше 0 - индекс a будет ниже индекса b (сначала в массиве будет идти a, потом b)\n- если функция возвращает 0, положение a и b относительно друг друга не меняется, но меняется по отношению к другим сортируемым элементам; это поведение гарантируется только в ES2019, так что старые браузеры могут это не поддерживать\n- если функция возвращает значение больше 0, положение a и b не изменяется\n- функция должна возвращать всегда одно и то же значение для двух одних и тех же элементов, если возвращаются противоречивые результаты, порядок сортировки определен не будет. \nПри сравнении чисел, а не строк, функция может вычитать b из a. Такая функция отсортирует массив в порядке возрастания (если только не содержит Infinty и NaN). В массиве удобно применять стрелочные функции.\nlet numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);// [1, 2, 3, 4, 5]\nПример с сортировкой объектов по одному из их свойств:\nvar items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic', value: 13 },\n  { name: 'Zeros', value: 37 }\n];\nitems.sort(function (a, b) {\n  return a.value - b.value;\n});\nitems.sort(function(a, b) {\n  var nameA = a.name.toUpperCase(); // ignore upper and lowercase\n  var nameB = b.name.toUpperCase(); // ignore upper and lowercase\n  if (nameA < nameB) {\n    return -1;\n  }\n  if (nameA > nameB) {\n    return 1;\n  }\n  return 0;\n});\nДля сравнения строк, имеющих символы за пределами языковой плоскости, применяют String.prototype.localeCompare(). \nvar items = ['réservé', 'premier', 'communiqué', 'café', 'adieu', 'éclair'];\nitems.sort(function (a, b) {\n  return a.localeCompare(b);\n});// items is ['adieu', 'café', 'communiqué', 'éclair', 'premier', 'réservé']\nВ зависимости от природы функции сравнения затраты на работу метода сортировки могут быть очень большими. В таких случаях можно применять метод с созданием промежуточного массива с отбором нужных элементов методом Array.prototype.map(), с последующей его сортировкой. При проблемах с производительностью можно использовать бесплатную библиотеку Mapsort.\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.splice()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.146,
          "type": "method",
          "description": "Array.prototype.splice() - метод в синтаксисе let arrDelItems = arr.splice(start, deleteCount, item_1, item_2, ...) изменяет содержание массива, удаляя или передвигая существующие в нем элементы и/или на месте добавляя в него новые. Обязательный аргумент start - начальный индекс, с которого изменяется массив; если значение больше длины массива, будет расцениваться как длина массива и тогда не будет удален ни один существующий элемент, новые будут просто добавляться; если значение отицательное, расценивается как array.length + start (но если сумма станет меньше 0, работать массив начнет с индекса 0). Необязательный аргумент deleteCount - целое число, указывающее количество элементов, подлежащих удалению начиная с индекса start; если аргумент пропущен или его значение равно или больше чем array.length - start (т.е. количество подлежащих удалению элементов превышает количество оставшихся в массиве при отсчете от данного индекса), то будут удалены все элементы от start до конца массива, но такого поведения не будет в IE8; если значение равно 0 или отрицательно, ни один элемент удален не будет, но тогда вы должны обозначить хотя бы один новый элемент для вставки. Необязательные аргументы item_1, item_2... - добавляемые элементы, которые будут вставлены начиная с индекса start (т.е. новый элемент будет размещен именно по индексу start); если они отсутствуют, метод лишь удалит элементы из массива. Метод возвращает массив из удаленных элементов (даже если был удален лишь один, а если не удалялось ни одного - вернется пустой массив). Если число вставляемых элементов больше или меньше числа удаляемых, изменится длина массива.  \nlet myFish = ['angel', 'clown', 'drum', 'mandarin', 'sturgeon'];\nlet removed = myFish.splice(3, 1);\n// myFish is [\"angel\", \"clown\", \"drum\", \"sturgeon\"]\n// removed is [\"mandarin\"]\nremoved = myFish.splice(-2);\n// myFish is [\"angel\", \"clown\", \"sturgeon\"]\n// removed is [\"drum\"]"
        },
        {
          "name": "Array.prototype.toLocaleString()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.147,
          "type": "method",
          "description": "Array.prototype.toLocaleString() - метод в синтаксисе arr.toLocaleString(locales, options) возвращает строку, представляющую перечисленные элементы массива. Элементы конвертируются в строки методом toLocaleString, разделенные знаком вроде запятой. Необязательный параметр locales - строка или массив строк с тегами языка BCP-47. Основные формы и их интерпретация описана у встроенного объекта Intl. Необязательный параметр options - объект с набором конфигурационных свойств, у объектов - Object.prototype.toLocaleString(), у чисел - см. Number.prototype.toLocaleString(), у дат - Date.prototype.toLocaleString(). \nvar prices = ['￥7', 500, 8123, 12];\nprices.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' });// \"￥7,￥500,￥8,123,￥12\"\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.toString()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.148,
          "type": "method",
          "description": "Array.prototype.toString() - метод в синтаксисе arr.toString() возвращает строку, представляющую массив и его элементы. У массивов переопределен метод объектов toString. У массивов он объединяет массив и возвращает одну строку, содержащую все элементы массива, разделенные запятыми. JavaScript вызывает этот метод автоматически, когда массив должен быть представлен в виде текстового значения или где массив участвует в конкатенации строк. Метод уже общий, его можно вызвать с любым объектом. Тогда будет вызван Object.prototype.toString(). \nvar arr = ['bla', 'bla-bla-bla', {'name' : 'SomeName', 'age' : 30}, null, [1, 2, 3, [4, 5]]];\nlet str = arr.toString();\nalert(str);// bla,bla-bla-bla,[object Object],,1,2,3,4,5"
        },
        {
          "name": "Array.prototype.unshift()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.149,
          "type": "method",
          "description": "Array.prototype.unshift() - метод в синтаксисе arr.unshift(elem_1, elem_2, ...) добавляет один или больше элементов в начало массива и возвращает новую длину массива. Метод намеренно сделан общим, так что может быть применен или вызван (при помощи \nFunction.prototype.apply() или Function.prototype.call()) к/на объектах, похожих на массивы. Объекты, не имеющие свойства length, демонстрирующего последний элемент в непрерывном ряду, основанные на начале отсчета с 0 числовые свойства могут вести себя непредсказуемо. \nИмейте в виду, что если для вставки передаются несколько элементов, они вставляются \"куском\", целой частью, в начало объекта, в том порядке, в котором они перечислены как параметры. Следовательно, вызов unshift с n аргументов один раз и вызов метода n раз с одним аргументом не одно и то же.\nlet arr = [4, 5, 6]\narr.unshift(1, 2, 3)\nconsole.log(arr);// [1, 2, 3, 4, 5, 6]\narr = [4, 5, 6] // resetting the array\narr.unshift(1)\narr.unshift(2)\narr.unshift(3)\nconsole.log(arr)// [3, 2, 1, 4, 5, 6]"
        },
        {
          "name": "Array.prototype.values()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.151,
          "type": "method",
          "description": "Array.prototype.values() - метод в синтаксисе arr.values() возвращает новый итератор массива Array Iterator - объект, содержащий значения каждого индекса массива. Объект временный, для однократного применения. Является дефолтной реализацией метода Array.prototype[Symbol.iterator]\nArray.prototype.values === Array.prototype[Symbol.iterator];// true\nСоответственно, возможно применение метода .next():\nvar arr = ['a', 'b', 'c', 'd', 'e'];\nvar iterator = arr.values();\niterator.next();// Object { value: \"a\", done: false }\niterator.next().value;// \"b\"\niterator.next()[\"value\"];// \"c\"\niterator.next();// Object { value: \"d\", done: false }\niterator.next();// Object { value: \"e\", done: false }\niterator.next();// Object { value: undefined, done: true }\niteraror.next().value;// undefined\nПример с использованием итератора в цикле:\nvar arr = ['a', 'b', 'c', 'd', 'e'];\nvar iterator = arr.values();\nfor (let letter of iterator) {\n  console.log(letter);\n}  //\"a\" \"b\" \"c\" \"d\" \"e\"\nИтератор не хранит значения, лишь ссылки на них. Так что при изменении значений массива значения в объекте также изменятся. Метод не поддерживается в IE."
        },
        {
          "name": "Array.prototype[Symbol.iterator]()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.152,
          "type": "method",
          "description": "Array.prototype[Symbol.iterator]() - метод в синтаксисе arr[Symbol.iterator]() - часть протокола итерации, определяющая как синхронно итерировать данный ряд значений. Значение свойства является тем же функциональным объектом, что и значение метода Array.prototype.values(). \nПример с использованием метода с созданием списка:\n<ul id=\"letterResult\">\n</ul>\nconst arr = ['a', 'b', 'c'];\nconst eArr = arr[Symbol.iterator]();\nconst letterResult = document.getElementById('letterResult');\nfor (let letter of eArr) {\n  const li = document.createElement('LI');\n  li.textContent = letter;\n  letterResult.appendChild(li);\n}\nПроверка на итерабельность:\nfunction isIterable(it) {\nif (!(Symbol.iterator in Object.getPrototypeOf(it)\n/* or \"Symbol.iterator in Object.__proto__\"\n    or \"it[Symbol.iterator]\" */)) {\n   console.log(it, ' is not an iterable object...');\n    } else {\n        var iterator = it[Symbol.iterator];\n        return iterator;\n    }\n} \nМетод не поддерживается в IE."
        }
      ]
    },
    {
      "name": "Expressions",
      "classDeck": "deck",
      "id": 3,
      "type": "Expressions",
      "objects": [
        {
          "name": "'use strict'",
          "classDeck": "card",
          "deck": "Expressions",
          "id": 3.1,
          "type": "expression",
          "description": "или \"use strict\", объявление \"строгого\" режима (ES5 и выше). Указывается в самом начале скрипта. Можно указывать в начале функции, над ним могут быть написаны только комментарии. В консоли по умолчанию выключен. Старые консоли директиву не поймут - ее надо обернуть в функцию:\n(function() {\n 'use strict';\n ...\n})()\nКлассы и модули автоматически включают строгий режим, в них директиву можно не указывать."
        },
        {
          "name": "throw",
          "classDeck": "card",
          "deck": "Expressions",
          "id": 3.2,
          "type": "expression",
          "description": "инструкция throw выбрасывает определенное пользователем исключение. Выполнение текущей функции будет остановлено (все инструкции после throw не будут запущены) и контроль перейдет к первому в стеке вызовов блоку catch. Если такого блока среди вызванных функций нет, выполнение кода будет прекращено. Выбрасывать может любое выражение, которое становится значением исключения. \nthrow 'Error2';// generates an exception with a string value\nthrow 42;// generates an exception with the value 42\nthrow true;// generates an exception with the value true\nthrow new Error('Required');// generates an error object with the message of Required\nНо лучше выбрасывать объект ошибки, который можно создавать по собственному конструктору.\nfunction UserException(message) {\n  this.message = message;\n  this.name = 'UserException';\n}\nfunction getMonthName(mo) {\n  mo = mo - 1; // Adjust month number for array index (1 = Jan, 12 = Dec)\n  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',\n    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  if (months[mo] !== undefined) {\n    return months[mo];\n  } else {\n    throw new UserException('InvalidMonthNo');\n  }\n}\ntry {\n  // statements to try\n  var myMonth = 15; // 15 is out of bound to raise the exception\n  var monthName = getMonthName(myMonth);\n} catch (e) {\n  monthName = 'unknown';\n  console.error(e.message, e.name); // pass exception object to err handler\n}\nТакже можно пробрасывать исключение дальше, после того, как вы его отловили. Пробрасываемые исключения всплывают до функции-обертки или до более высокого уровня, где пользователь сможет его увидеть.\ntry {\n  throw n; // throws an exception with a numeric value\n} catch (e) {\n  if (e <= 50) {\n    // statements to handle exceptions 1-50\n  } else {\n    // cannot handle this exception, so rethrow\n    throw e;\n  }\n}"
        }
      ]
    },
    {
      "name": "Function",
      "classDeck": "deck",
      "deck": "build-in object",
      "id": 5,
      "type": "Function",
      "description": "Каждая функция в JavaScript фактически объект function. Она может рассматриваться как код (function(){}).constructor === Function, который вернет true.",
      "objects": [
        {
          "name": "new Function()",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.1,
          "type": "constructor",
          "description": "Конструктор создает новый объект Function. Вызов конструктора напрямую может создавать функции динамически, но они будут небезопасны и с похожей (но не столь очевидной) производительсностью, как у eval(). Тем не менее, в отличие от eval, конструктор Function создает функции, которые будут запускаться в глобальной области видимости. Синтаксис - new Function(arg1, arg2, ..., argN, funcBody), где arg - имена, использующиеся функцией как имена формальных аргументов, каждое из них - строка, отвечающая валидному идентификатору JS, или список таких строк, разделенных запятыми. Например, \"x\", \"theValue\" или \"x, theValue. funcBody - строка с JS-выражением, содержащим определение функции. Объект function, созданный при помощи такого конструктора, парсится еще при создании функции. Это менее эффективно, чем при объявлении функции декларативно или экспрессивно, которые парсятся во время остановки кода. Все передаваемые аргументы расцениваются как имена идентификаторов параметров создаваемой функции, в том порядке, в каком они ей передаются. Если указанный аргумент пропускается, его значением станет undefined. Вызов конструктора Function без оператора new будет иметь тот же эффект, что и вызов конструктора. \nconst adder = new Function('a', 'b', 'return a + b');\nФункции, созданные при помощи конструктора, не создают замыканий в создаваемом контексте, они всегда создаются в глобальной области видимости. При их запуске они доступны только их локальным переменным и глобальным переменным, но не тем, что находятся в той области видимости, где был вызван конструктор."
        },
        {
          "name": "Function.prototype.apply()",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.11,
          "type": "method",
          "description": "метод вызывает функцию с определенным значением this и аргументами, предоставленными в виде массива (или массивоподобного объекта). Синтаксис - \nfunc.apply(thisArg, [argsArray])\nИмейте в виду, что this может не быть актуальным значением, рассматриваемым методом. Если метод применен на функции в нестрогом режиме, null и undefined будут заменены на глобальный объект, а примитивные значения обернуты. Аргумент this обязателен. Параметр argsArray - массивоподобный объект с аргументами, с которыми должна быть вызвана функция, или null или undefined, если аргументы передавать не нужно. Возвращаемое значение метода - результат вызова функции с указанным this и параметрами. Главное отличие от метода call() при их схожести написания - с методом apply() применяется массивоподобный объект с параметрами, а с методом call() - список аргументов. Когда первым аргументом идет undefined или null, похожего результата можно достичь при помощи спред-синтаксиса в массиве (...). Вы можете присваивать уже существующей функции различные объекты this, всегда ссылающиеся на текущий объект (к которому примеяете функцию). \nC методом apply() вы можете написать один метод, а затем наследовать его в других объектах без необходимости переписывать этот метод. В качестве массива аргументов можно применять массив литералов (строк) или даже \"чистый\" массив. Также вместо массива применим объект arguments. В таком случае вы не обязаны знать весь набор аргументов заранее. Применим любой тип массивоподобных абъектов, в т.ч. NodeList. Старые браузеры (Chrome<17, IE<9) не обрабатывают массивоподобные объекты, принимая только массивы. \nПрименить метод можно с методом массива push(), если нужно добавить в существующий массив элементы из другого массива (просто метод push() добавит массив как отдельный элемент внутрь другого, а метод concat() не изменит существующий, а создаст новый массив).\nconst array = ['a', 'b'];\nconst elements = [0, 1, 2];\narray.push.apply(array, elements);\nconsole.info(array); // [\"a\", \"b\", 0, 1, 2] \nДругое мудрое применение - вместе с некоторыми встроенными функциями. Например, для поиска минимальных и максимальных значений в массиве вместо применения циклов.\nconst numbers = [5, 6, 2, 3, 7];\nlet max = Math.max.apply(null, numbers);\nlet min = Math.min.apply(null, numbers);\nЕдинственное - следите за количеством аргументов, при сильном превышении лимита движка возможны проблемы. Тогда используйте гибридный метод.\nfunction minOfArray(arr) {\n  let min = Infinity;\n  let QUANTUM = 32768;\n  for (var i = 0, len = arr.length; i < len; i += QUANTUM) {\n    var submin = Math.min.apply(null,\n                                arr.slice(i, Math.min(i+QUANTUM, len)));\n    min = Math.min(submin, min);\n  }\n  return min;\n}\nlet min = minOfArray([5, 6, 2, 3, 7]);\nЕще одно применение - создание цепочек конструкторов.\nFunction.prototype.construct = function(aArgs) {\n  let oNew = Object.create(this.prototype);\n  this.apply(oNew, aArgs);\n  return oNew;\n};\nfunction MyConstructor() {\n  for (let nProp = 0; nProp < arguments.length; nProp++) {\n    this['property' + nProp] = arguments[nProp];\n  }\n}\nlet myArray = [4, 'Hello world!', false];\nlet myInstance = MyConstructor.construct(myArray);\nconsole.log(myInstance.property1);                // logs 'Hello world!'\nconsole.log(myInstance instanceof MyConstructor); // logs 'true'\nconsole.log(myInstance.constructor);              // logs 'MyConstructor'"
        },
        {
          "name": "Function.prototype.bind()",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.12,
          "type": "method",
          "description": "метод создает новую функцию, которая при вызове имеет в качестве this предоставленное значение с набором аргументов, предшествующих любым другим аргументам, передаваемым функции. Синтаксис - \nlet boundFunc = func.bind(thisArg, arg1, arg2, ..., argN)\nthisArg - значение, передаваемое как this целевой функции при ее \"привязанном\" вызове, оно игнорируется, если привязываемая функция создана при помощи конструктора с оператором new. Когда используется bind() при создании функции (как колбэк-функции) внутри setTimeout, любые примитивные значения, передаваемые в качестве this, конвертируются в объекты. Если никаких аргументов не передается или thisArg равно null или undefined, this текущей области видимости расценивается как rhisArg. arg1... - аргументы, предшествующие любым другим, передаваемым в функцию. Возвращаемое значение метода - копия функции с установленным this и инициализированными аргументами (если они есть). Другими словами - метод bind() создает новую привязанную функцию, являющуюся экзотическим объектом функции, обернутой вокруг оригинального функционального объекта. Вызов привязанной функции в основном является запуском функции-обертки."
        },
        {
          "name": "Function.prototype.call()",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.13,
          "type": "method",
          "description": "метод вызывает функцию с данным значением this и индивидуально предлагаемыми аргументами. Синтаксис - \nfunc.call(thisArg, arg1, arg2, ..., argN)\nВозвращаемое значение - результат вызова функции с указанным this и аргументами. Метод позволяет принадлежащий одному объекту функциональный метод назначить и вызвать на другом объекте. Метод предлагает новое значение this функции или методу. С ним вы можете написать метод один раз и затем наследовать его в других объектах без необходимости вновь его писать. Главное отличие от метода apply() - в методе call() указывается список аргументов, в apply() - массив или массивоподобный объект. "
        },
        {
          "name": "Function.prototype.displayName",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.14,
          "type": "property",
          "description": "нестандартизованное свойство, возвращающее отображаемое имя функции.\nfunction doSomething() {}\nconsole.log(doSomething.displayName); // \"undefined\"\nvar popup = function(content) { console.log(content); };\npopup.displayName = 'Show Popup';\nconsole.log(popup.displayName); // \"Show Popup\""
        },
        {
          "name": "Function.prototype.length",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.15,
          "type": "property",
          "description": "свойство, показывающее количество ожидаемых функцией параметров. Свойство неперезаписываемое, неперечисляемое, изменяемое. Это длина объекта функции. Учитывает только параметры до первого, указанного со значением по умолчанию и не учитываем параметр \"остальное\" (rest parameter, ...). В противовес ему, arguments.length считается отдельно для функции и предоставляет количество всех актуальных аргументов, переданных функции. Длина конструктора функции всегда равна 1. Свойство length у прототипа Function равно 0."
        },
        {
          "name": "Function.prototype.name",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.16,
          "type": "property",
          "description": "свойство только для чтения, демонстрирующее установленное при ее создании имя функции, значением также может быть anonymous (для анонимных функций или созданных конструктором) или '' (пустая строка, для анонимных экспрессивных и стрелочных функций). Свойство неперезаписываемое, неперечисляемое, но изменяемое (до ES6 было неизменяемым). Будьте осторожны при использовании этого свойства и изменении сырого кода, выполняемого минификаторами и обфускаторами JS. Одна из задач этих инструментов - уменьшить размер кода перед деплоингом, такие трансформации часто меняют названия функций. Разархивированный код запускается в первоначальном виде, но поведение метода декомпрессии не всегда одинаково, поэтому, если задействуете свойство Function.name, убедитесь, что процесс сборки не изменит имя или не давате функциям конкретных имен. Начиная с ECMA2015, именами могут быть именя переменных и методов, у методов в т.ч. в короткой форме их обозначения. \nlet f = function() {};\nlet object = {\n  someMethod: function() {}\n};\nconsole.log(f.name); // \"f\"\nconsole.log(object.someMethod.name); // \"someMethod\"\nvar o = {\n  foo(){}\n};\no.foo.name; // \"foo\";\nИмена методов обычным присваиванием не изменить, только через Object.defineProperty(). У \"привязанных\" методом bind функций перед именем будет приставка bound, у методов-геттеров и сеттеров - приставки get/set. У созданных через конструктор класса имя будет именем класса, но только если в конструкторе не будет статического метода name (static name()). На безупречную работу с именами классов у этого свойства лучше не полагаться. Если в качестве имени метода применен символ, значением свойства будет описание символа в скобках (если оно задавалось).\nlet sym1 = Symbol(\"foo\");\nlet sym2 = Symbol();\nlet o = {\n  [sym1]: function(){},\n  [sym2]: function(){}\n};\no[sym1].name; // \"[foo]\"\no[sym2].name; // \"\""
        },
        {
          "name": "Function.prototype.toString()",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.17,
          "type": "method",
          "description": "метод возвращает строку, представляющую исходный код функции. Синтаксис - \nfunc.toString()\nМетод перезаписывает унаследованный от Object. Для объектов Function, определенных пользователем, метод возвращает строку с текстовым сегментом, использованным для определения функции. JavaScript вызывает метод toString() автоматически, когда функция представляется как текстовое значение, например, при конкатенации со строкой. Метод выбросит исключение TypeError, если значением this не будет являться объект function. Возможен \"короткий\" вызов с конкатенацией с пустой строкой.\nfunction foo() { return 'bar' }\nconsole.log(foo + ''); // \"function foo() { return 'bar' }\""
        }
      ]
    },
    {
      "name": "Operators",
      "classDeck": "deck",
      "type": "operators",
      "id": 2,
      "objects": [
        {
          "name": "!",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.1,
          "type": "operator",
          "description": "логический оператор НЕ. Приводит операнд к логическому типу и возвращает противоположное логическое значение. \nalert(!true);//false"
        },
        {
          "name": "!!",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.2,
          "type": "operator",
          "description": "Двойной оператор !! принудительно приводит значение к логике (как Boolean()). Самый высокий приоритет из всех логических операторов."
        },
        {
          "name": "!=",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.3,
          "type": "operator",
          "description": "оператор неравенства"
        },
        {
          "name": "!==",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.4,
          "type": "operator",
          "description": "оператор строгого неравенства"
        },
        {
          "name": "%",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.5,
          "type": "operator",
          "description": "оператор modulo, оператор взятия остатка\nlet n = 20 % 4;// 0"
        },
        {
          "name": "&&",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.6,
          "type": "operator",
          "description": "логический оператор И. В традиционном программировании возвращает true только если оба операнда true:\nalert(true && false);//false\nalert(false && true);//false\nalert(false && false);//false\nalert(true && true);// true\nВ JS перебирает операнды слева направо, конвертирует их в логику, если результат false, останавливается и возвращает его исходное значение, если все результаты true, возвращает исходное значение последнего операнда. В итоге, возвращается первое ложное значение или последнее (если ничего не найдено).\nМожет заменять if:\nlet x=1;\n(x>0) && alert('первый операнд true, поэтому ты видишь эту надпись');"
        },
        {
          "name": "&&=",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.7,
          "type": "operator",
          "description": "если операнд а имеет истинное значение, то присвоить ему значение операнда b:\na = 1;\nb = 2;\na &&= b;\nconsole.log(a);// 2"
        },
        {
          "name": "**",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.8,
          "type": "operator",
          "description": "оператор возведения в степень и извлечения корня, целые значения - степень, нецелые - корень\nlet n = 2 ** 3;// 8\nlet n = 4 ** (1/2);// 2, квадратный корень\nlet n = 9 ** (1/3);// 3, кубический корень"
        },
        {
          "name": "+",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.9,
          "type": "operator",
          "description": "унарный плюс. Суммирует числа. Приводит нечисловые данные к числу. Иначе - осуществляет конкатенацию строк. Если первое значение число, второе строка - сконкатенирует их. Если несколько первых значений - числа, потом идет строка - сложит числа и сконкатенирует результат со строкой. В любом случае, если хотя бы один операнд строка, результатом будет строка."
        },
        {
          "name": "++",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.11,
          "type": "operator",
          "description": "инкремент. Префиксная форма возвращает увеличенное значение на 1. Постфиксная возвращает старое значение. Работает только с переменными.\nlet i=0;\nwhile(++i<5) alert(i);// 1, 2, 3, 4\nно\nwhile(i++<5) alert(i);// 1, 2, 3, 4, 5. "
        }
      ]
    },
    {
      "name": "Proxy",
      "classDeck": "deck",
      "deck": "build-in object",
      "id": 4,
      "type": "Proxy",
      "description": "объект Proxy позволяет создавать прокси - объект-посредник - для другого объекта, который может перехватывать и переопределять основные операции с этим объектом. Создается с двумя параметрами: target - целевой объект, который нужно проксировать, и handler - объект (ловушка), определяющий, какие операции необходимо перехватывать и как их переопределять. Пустой объект укажет поведение, как с целевым объектом:\nconst target = {\n  message1: \"hello\",\n  message2: \"everyone\"\n};\nconst handler1 = {};\nconst proxy1 = new Proxy(target, handler1);\nconsole.log(proxy1.message1); // hello\nconsole.log(proxy1.message2); // everyone\nЗадаем правила поведения для всех подобных операций - например, при получении свойства:\nconst handler2 = {\n  get: function(target, prop, receiver) {\n    return \"world\";\n  }\n};\nconst proxy2 = new Proxy(target, handler2);\nconsole.log(proxy2.message1); // world\nconsole.log(proxy2.message2); // world\nДля обеспечения \"изначального\" поведения у одних свойств и другого, измененного, у других - используем в связке с Reflect (в примере выше функция переопределения запроса по-сути являлась reflect-функцией):\nconst target = {\n  message1: \"hello\",\n  message2: \"everyone\"\n};\nconst handler1 = {};\nconst proxy1 = new Proxy(target, handler1);\nconsole.log(proxy1.message1); // hello\nconsole.log(proxy1.message2); // everyone\nconst target = {\n  message1: \"hello\",\n  message2: \"everyone\"\n};\nconst handler3 = {\n  get: function (target, prop, receiver) {\n    if (prop === \"message2\") {\n      return \"world\";\n    }\n    return Reflect.get(...arguments);\n  },\n};\nconst proxy3 = new Proxy(target, handler3);\nconsole.log(proxy3.message1); // hello\nconsole.log(proxy3.message2); // world\nНет поддержки в IE.\n\nПрокси могут помочь в предварительной проверке передаваемых объекту свойств:\nlet validator = {\n  set: function(obj, prop, value) {\n    if (prop === 'age') {\n      if (!Number.isInteger(value)) {\n        throw new TypeError('The age is not an integer');\n      }\n      if (value > 200) {\n        throw new RangeError('The age seems invalid');\n      }\n    }\n    obj[prop] = value; // The default behavior to store the value\n    return true; // Indicate success\n  }\n};\nconst person = new Proxy({}, validator);\nperson.age = 100;\nconsole.log(person.age); // 100\nperson.age = 'young';    // Throws an exception\nperson.age = 300;        // Throws an exception\nМожно легко расширять конструкторы другими конструкторами:\nfunction extend(sup, base) {\n  var descriptor = Object.getOwnPropertyDescriptor(\n    base.prototype, 'constructor'\n  );\n  base.prototype = Object.create(sup.prototype);\n  var handler = {\n    construct: function(target, args) {\n      var obj = Object.create(base.prototype);\n      this.apply(target, obj, args);\n      return obj;\n    },\n    apply: function(target, that, args) {\n      sup.apply(that, args);\n      base.apply(that, args);\n    }\n  };\n  var proxy = new Proxy(base, handler);\n  descriptor.value = proxy;\n  Object.defineProperty(base.prototype, 'constructor', descriptor);\n  return proxy;\n}\nvar Person = function(name) {\n  this.name = name;\n};\nvar Boy = extend(Person, function(name, age) {\n  this.age = age;\n});\nBoy.prototype.gender = 'M';\nvar Peter = new Boy('Peter', 13);\nconsole.log(Peter.gender);  // \"M\"\nconsole.log(Peter.name);    // \"Peter\"\nconsole.log(Peter.age);     // 13\nПереключаем значения атрибутов или меняем классы в DOM:\nlet view = new Proxy({\n  selected: null\n},\n{\n  set: function(obj, prop, newval) {\n    let oldval = obj[prop];\n    if (prop === 'selected') {\n      if (oldval) {\n        oldval.setAttribute('aria-selected', 'false');\n      }\n      if (newval) {\n        newval.setAttribute('aria-selected', 'true');\n      }\n    }\n    // The default behavior to store the value\n    obj[prop] = newval;\n    // Indicate success\n    return true;\n  }\n});\nlet i1 = view.selected = document.getElementById('item-1');  //giving error here, i1 is null\nconsole.log(i1.getAttribute('aria-selected'));//  'true'\nlet i2 = view.selected = document.getElementById('item-2');\nconsole.log(i1.getAttribute('aria-selected'));//  'false'\nconsole.log(i2.getAttribute('aria-selected'));//  'true'\nКорректировка значений и дополнительные свойства:\nlet products = new Proxy({\n  browsers: ['Internet Explorer', 'Netscape']\n},\n{\n  get: function(obj, prop) {\n    // An extra property\n    if (prop === 'latestBrowser') {\n      return obj.browsers[obj.browsers.length - 1];\n    }\n    // The default behavior to return the value\n    return obj[prop];\n  },\n  set: function(obj, prop, value) {\n    // An extra property\n    if (prop === 'latestBrowser') {\n      obj.browsers.push(value);\n      return true;\n    }\n    // Convert the value if it is not an array\n    if (typeof value === 'string') {\n      value = [value];\n    }\n    // The default behavior to store the value\n    obj[prop] = value;\n    // Indicate success\n    return true;\n  }\n});\nconsole.log(products.browsers);//  ['Internet Explorer', 'Netscape']\nproducts.browsers = 'Firefox';//  pass a string (by mistake)\nconsole.log(products.browsers);//  ['Firefox'] <- no problem, the value is an array\nproducts.latestBrowser = 'Chrome';\nconsole.log(products.browsers);//  ['Firefox', 'Chrome']\nconsole.log(products.latestBrowser);//  'Chrome'\nСоздание механизма поиска объекта в массиве объектов по определенным свойствам объекта:\nlet products = new Proxy([\n  { name: 'Firefox', type: 'browser' },\n  { name: 'SeaMonkey', type: 'browser' },\n  { name: 'Thunderbird', type: 'mailer' }\n],\n{\n  get: function(obj, prop) {\n    // The default behavior to return the value; prop is usually an integer\n    if (prop in obj) {\n      return obj[prop];\n    }\n    // Get the number of products; an alias of products.length\n    if (prop === 'number') {\n      return obj.length;\n    }\n    let result, types = {};\n    for (let product of obj) {\n      if (product.name === prop) {\n        result = product;\n      }\n      if (types[product.type]) {\n        types[product.type].push(product);\n      } else {\n        types[product.type] = [product];\n      }\n    }\n    // Get a product by name\n    if (result) {\n      return result;\n    }\n    // Get products by type\n    if (prop in types) {\n      return types[prop];\n    }\n    // Get product types\n    if (prop === 'types') {\n      return Object.keys(types);\n    }\n    return undefined;\n  }\n});\nconsole.log(products[0]);          // { name: 'Firefox', type: 'browser' }\nconsole.log(products['Firefox']);  // { name: 'Firefox', type: 'browser' }\nconsole.log(products['Chrome']);   // undefined\nconsole.log(products.browser);     // [{ name: 'Firefox', type: 'browser' }, { name: 'SeaMonkey', type: 'browser' }]\nconsole.log(products.types);       // ['browser', 'mailer']\nconsole.log(products.number);      // 3",
      "objects": [
        {
          "name": "new Proxy()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.1,
          "type": "constructor",
          "description": "Proxy() - конструктор в синтаксисе var proxy = new Proxy(target. handler) создает объекты Proxy. target - целевой объект для заворачивания в прокси, это может быть объект любого рода, включая массив, функцию или даже другой прокси. handler - объект, чьи свойства и функции определяют поведение прокси при проведении операций с ним. Оба аргумента обязательны. \nФункции-обработчики - перечень всех возможных ловушек: handler.apply(), handler.construct(), handler.defineProperty(), handler.deleteProperty(), handler.get(), handler.getOwnPropertyDescriptor(), handler.getPrototypeOf(), handler.has(), handler.isExtensible(), handler.ownKeys(), handler.preventExtentions(), handler.set(), handler.setPrototypeOf()"
        },
        {
          "name": "handler.apply()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.2,
          "type": "Proxy handler",
          "description": "ловушка для перехвата вызова функции - proxy(...args), Function.prototype.call(), Function.prototype.apply(), Reflect.apply(). Синтаксис - \nconst p = new Proxy(target, {\n  apply: function(target, thisArg, argumentsList) {\n  }\n});\nМетоду передаются следующие параметры, this привязывается к обработчику. target - целевой объект, thisArg - аргумент this для вызова, argumentsList - список аргументов.\nМожет возвращать любое значение. Инварианты: target должен быть вызываемым объектом - т.е. это должна быть функция. \nfunction sum(a, b) {\n  return a + b;\n}\nconst handler = {\n  apply: function(target, thisArg, argumentsList) {\n    console.log(`Calculate sum: ${argumentsList}`);\n    // expected output: \"Calculate sum: 1,2\"\n    return target(argumentsList[0], argumentsList[1]) * 10;\n  }\n};\nconst proxy1 = new Proxy(sum, handler);\nconsole.log(sum(1, 2));\n// expected output: 3\nconsole.log(proxy1(1, 2));\n// expected output: 30"
        },
        {
          "name": "handler.construct()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.3,
          "type": "Proxy handler",
          "description": "ловушка для перехвата оператора new. Для того, чтобы новая операция была работоспособной на итоговом объекте Proxy, целевой объект, иницииализирующий прокси, должен иметь внутренний метод [[Construct]] (т.е. должен срабатывать new target). Синтаксис - \nconst p = new Proxy(target, {\n  construct: function(target, argumentsList, newTarget) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, argumentsList - список аргументов для передачи конструктору, newTarget - для кого вызывается оригинальный constructor. Метод должен возвращать объект. Перехватывает операции: new myFunction(...args), Reflect.construct(). Инварианты: будет выброшено TypeError, если метод возвратит не объект. \nconst p = new Proxy(function() {}, {\n  construct: function(target, argumentsList, newTarget) {\n    console.log('called: ' + argumentsList.join(', '));\n    return { value: argumentsList[0] * 10 };\n  }\n});\nconsole.log(new p(1).value); // \"called: 1\"\n                             // 10"
        },
        {
          "name": "handler.defineProperty()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.4,
          "type": "Proxy handler",
          "description": "метод-ловушка для Object.defineProperty() и Reflect.defineProperty(). Синтаксис - \nconst p = new Proxy(target, {\n  defineProperty: function(target, property, descriptor) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя или Symbol свойства, чьи дескрипторы извлекаются, descriptor - дескриптор свойства, устанавливаемый или подвергающийся изменению. Метод возвращает булево значение, демонстрирующее, было ли успешно установлено или изменено свойство. Инварианты (будет выброшеноTypeError): свойство не может быть добавлено, если целевой объект не расширяемый; свойство не может быть добавлено как или изменено на неконфигурируемое, если оно не существует как неконфигурируемое собственное свойство целевого объекта; свойство не может быть неконфигурируемым, если у объекта есть  соответствующее конфигурируемое свойство; если свойство имеет соответствующее целевое свойство, то исключение не будет выброшено; в строгом режиме возвращаемое обработчиком значение false выбросит исключение TypeError. \nconst p = new Proxy({}, {\n  defineProperty: function(target, prop, descriptor) {\n    console.log('called: ' + prop);\n    return true;\n  }\n});\nconst desc = { configurable: true, enumerable: true, value: 10 };\nObject.defineProperty(p, 'a', desc); // \"called: a\"\nПри вызове Object.defineProperty() или Reflect.defineProperty() передаваемый ловушке descriptor имеет некоторые ограничения - будут переданы только поля со стандартными свойствами (enumerable, configurable, writable, value, set, get) нестандартные будут проигнорированы.\nconst p = new Proxy({}, {\n  defineProperty(target, prop, descriptor) {\n    console.log(descriptor);\n    return Reflect.defineProperty(target, prop, descriptor);\n  }\n});\nObject.defineProperty(p, 'name', {\n  value: 'proxy',\n  type: 'custom'\n});  // { value: 'proxy' }"
        },
        {
          "name": "handler.deleteProperty()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.5,
          "type": "Proxy handler",
          "description": "метод-ловушка для оператора delete. Перехватывает delete proxy[foo], delete proxy.foo и Reflect.deleteProperty(). Синтаксис - \nconst p = new Proxy(target, {\n  deleteProperty: function(target, property) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя или Symbol свойства. Возвращает булево значение - удачно ли было удалено указанное свойство. Инварианты (будет выброшено исключение): свойство не может быть удалено, если оно существует как собственное неконфигурируемое своство целевого объекта. \nconst p = new Proxy({}, {\n  deleteProperty: function(target, prop) {\n    if (prop in target){\n      delete target[prop]\n      console.log('property removed: ' + prop)\n      return true\n    }\n    else {\n      console.log('property not found: ' + prop)\n      return false\n    }\n  }\n});"
        },
        {
          "name": "handler.get()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.6,
          "type": "Proxy handler",
          "description": "метод-ловушка получения значения свойства. Перехватывает proxy[foo], proxy.foo, Object.create(proxy)[foo], Reflect.get(). Синтаксис - \nconst p = new Proxy(target, {\n  get: function(target, property, receiver) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя или Symbol свойства, receiver - прокси или объект, наследующий от прокси. Метод может вернуть любое значение. Инварианты (будет выброшено исключение): значение, объявляемое у свойства, должно быть таким же, что и у соответствующего свойства целевого объекта, если это неперезаписываемое, неконфигурируемое собственное свойство данных; значение, объявляемое у свойства, должно быть undefined, если соответствующее свойство целевого объекта - неконфигурируемое собственное свойство доступа и имеет значение undefined, как и его атрибут [[Get]]. \nconst p = new Proxy({}, {\n  get: function(target, property, receiver) {\n    console.log('called: ' + property);\n    return 10;\n  }\n});\nconsole.log(p.a); // \"called: a\"\n                  // 10"
        },
        {
          "name": "handler.getOwnPropertyDescriptor()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.7,
          "type": "Proxy handler",
          "description": "метод-ловушка для Object.getOwnPropertyDescriptor() и Reflect.getOwnPropertyDescriptor(). Синтаксис - \nconst p = new Proxy(target, {\n  getOwnPropertyDescriptor: function(target, property) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя свойства, чей дескриптор нужно получить. Метод возвращает объект (дескриптор свойства) или undefined. Инварианты (будет выброшено TypeError): метод обязан возвращать только объект или undefined; свойство не может быть объявлено несуществующим, если оно существует как неконфигурируемое собственное свойство целевого объекта; свойство не может быть объявлено несуществующим, если оно существует как собственное свойство целевого объекта и сам целевой объект нерасширяемый; свойство не может быть объявлено существующим, если оно не существует в виде собственного свойства целевого объекта и объект нерасширяемый; свойство не может объявляться как неконфигурируемое, если оно не существует как собственное свойство целевого объекта или существует как конфигурируемое собственное свойство; результат метода Object.getOwnPropertyDescriptor(target) может применяться к целевому объекту посредством Object.defineProperty() и это не вызовет ошибку. \nconst p = new Proxy({ a: 20}, {\n  getOwnPropertyDescriptor: function(target, prop) {\n    console.log('called: ' + prop);\n    return { configurable: true, enumerable: true, value: 10 };\n  }\n});"
        },
        {
          "name": "handler.getPrototypeOf()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.8,
          "type": "Proxy handler",
          "description": "метод-ловушка для внутреннего метода [[GetPrototypeOf]]. Перехватит Object.getPrototypeOf(), Reflect.getPrototypeOf(), __proto__, Object.prototype.isPrototypeOf(), instanceof. Синтаксис - \nconst p = new Proxy(target, {\n  getPrototypeOf: function(target) {\n  }\n});\nИнварианты (будет выброшено исключение): метод должен возвращать объект или null; если целевой объект нерасширяем, метод Object.getPrototypeOf(proxy) должен вернуть то же значение, что и метод Object.getPrototypeOf(target). \nconst obj = {};\nconst p = new Proxy(obj, {\n    getPrototypeOf(target) {\n        return Array.prototype;\n    }\n});\nconsole.log(\n    Object.getPrototypeOf(p) === Array.prototype,  // true\n    Reflect.getPrototypeOf(p) === Array.prototype, // true\n    p.__proto__ === Array.prototype,               // true\n    Array.prototype.isPrototypeOf(p),              // true\n    p instanceof Array                             // true\n);"
        },
        {
          "name": "handler.has()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.9,
          "type": "Proxy handler",
          "description": "метод-ловушка для оператора in. Перехватывает запрос foo in proxy, foo in Object.create(proxy), оператор with (проверка with(proxy) { (foo); }), Reflect.has(). Синтаксис - \nconst p = new Proxy(target, {\n  has: function(target, property) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя или Symbol свойства, чье существование проверяется. Инварианты (будет выброшено исключение): свойство не может быть объявлено несуществующим, если оно существует как неконфигурируемое собственное свойство целевого объекта; свойство не может быть объявлено несуществующим, если оно существует как собственное свойство нерасширяемого объекта.\nconst p = new Proxy({}, {\n  has: function(target, prop) {\n    console.log('called: ' + prop);\n    return true;\n  }\n});\nconsole.log('a' in p); // \"called: a\"\n                       // true"
        },
        {
          "name": "handler.isExtensible()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.91,
          "type": "Proxy handler",
          "description": "метод-ловушка для Object.isExtensible() и Reflect.isExtensible(). Синтаксис - \nconst p = new Proxy(target, {\n  isExtensible: function(target) {\n  }\n});\nМетод возвращает булево значение. Инварианты (будет выброшено исключение): метод Object.isExtensible(proxy) должен возвращать то же значение, что и метод Object.isExtensible(target).\nonst p = new Proxy({}, {\n  isExtensible: function(target) {\n    console.log('called');\n    return true;\n  }\n});\nconsole.log(Object.isExtensible(p)); // \"called\"\n                                     // true"
        },
        {
          "name": "handler.ownKeys()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.92,
          "type": "Proxy handler",
          "description": "метод-ловушка для Reflect.ownKeys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbils() и Object.keys(). Синтаксис - \nconst p = new Proxy(target, {\n  ownKeys: function(target) {\n  }\n});\nМетод должен вернуть перебираемый объект (итератор). Инварианты (будет выброшено исключение): результатом метода должен быть массив; элементы этого массива - строки или символы; итоговый список должен содержать ключи всех неконфигурируемых собственных свойств целевого объекта; если целевой объект нерасширяемый, итоговый список должен включать ключи всех собственных свойств объекта и больше никаких значений. \nconst p = new Proxy({}, {\n  ownKeys: function(target) {\n    console.log('called');\n    return ['a', 'b', 'c'];\n  }\n});\nconsole.log(Object.getOwnPropertyNames(p)); // 'called'\n                                                                           // [ 'a', 'b', 'c' ]"
        },
        {
          "name": "handler.preventExtentions()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.93,
          "type": "Proxy handler",
          "description": "метод ловушка для Object.preventExtentions() и Reflect.preventExtentions(). Синтаксис - \nconst p = new Proxy(target, {\n  preventExtentions: function(target) {\n  }\n});\nМетод должен возвращать булево значение. Инварианты (будет выброшено исключение): Object.preventExtentions(proxy) должен возвращать только true, если Object.isExtensible(proxy) возвращает false. \nconst p = new Proxy({}, {\n  preventExtensions: function(target) {\n    console.log('called');\n    Object.preventExtensions(target);\n    return true;\n  }\n});\nconsole.log(Object.preventExtensions(p)); // \"called\"\n                                          // false"
        },
        {
          "name": "handler.set()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.94,
          "type": "Proxy handler",
          "description": "метод-ловушка для перехвата установки свойств. Перехватывает операции присваивания proxy[foo] = bar и proxy.foo = bar, присваивание наследуемому свойству Object.create(proxy)[foo] = bar и Reflect.set(). Синтаксис - \nconst p = new Proxy(target, {\n  set: function(target, property, value, receiver) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя или Symbol устанавливаемого свойства, value - новое значение свойства, receiver - объект, которому прямо адресовано присваивание, обычно это сам прокси, но обработчик может также быть вызван не прямо, а через цепочку наследования или другим образом (предположим, есть скрипт с obj.name = 'jen', и obj - не прокси и не имеет собственного свойства name, но имеет прокси в цепочке прототипов, тогда при вызове set() указываем в качестве receiver obj). Метод возвращает булево значение: true, если присваивание прошло успешно; если он возвращает false и присваивание производилось в строгом режиме, будет выброшено исключение TypeError. Инварианты (будет выброшено исключение): нельзя изменять значение свойства, отличное от значения соответствующего свойства целевого объекта, если это свойство целевого объекта неперезаписываемое, неконфигурируемое свойство данных; нельзя устанавливать значение свойства, если соответствующее свойство целевого объекта неконфигурируемое свойство доступа, имеющее в качестве своего атрибута [[Set]] значение undefined; в строгом режиме возврат значения false обязательно приведет к выбросу исключения. \nconst p = new Proxy({}, {\n  set: function(target, prop, value, receiver) {\n    target[prop] = value;\n    console.log('property set: ' + prop + ' = ' + value);\n    return true;\n  }\n})\nconsole.log('a' in p);  // false\np.a = 10;               // \"property set: a = 10\"\nconsole.log('a' in p);  // true\nconsole.log(p.a);       // 10"
        },
        {
          "name": "handler.setPrototypeOf()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.95,
          "type": "Proxy handler",
          "description": "метод-ловушка для перехвата Object.setPrototypeOf() и Reflect.setPrototypeOf(). Синтаксис - \nconst p = new Proxy(target, {\n  setPrototypeOf: function(target, prototype) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, prototype - новый объект-прототип или null. Возвращает true при успешном изменении прототипа, иначе - false. Инварианты (будет выброшено исключение): если целевой объект нерасширяем, параметр prototype должен быть равен значению метода Object.getPrototypeOf(target). Метод можно применять для предотвращения изменения прототипа объекта - тогда он должен возвращать false или выбрасывать исключение. \nconst handlerReturnsFalse = {\n    setPrototypeOf(target, newProto) {\n        return false;\n    }\n};\nconst newProto = {}, target = {};\nconst p1 = new Proxy(target, handlerReturnsFalse);\nObject.setPrototypeOf(p1, newProto); // throws a TypeError\nReflect.setPrototypeOf(p1, newProto); // returns false"
        },
        {
          "name": "Proxy.revocable()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.96,
          "type": "static property",
          "description": "статический метод в синтаксисе Proxy.revocable(target, handler) используется для создания отзываемых (revocable) прокси. target - целевой объект для оборачивания в прокси, может быть объектом любого типа, включая обычный массив, функцию или даже другой прокси. handler - объект, чьи свойства и функции определяют поведение прокси при проведении операций с ним. Метод возвращает новый отзываемый прокси. Это объект с двумя значениями: {proxy: proxy, revoke: revoke}, где proxy - новый объект прокси, созданный вызовом new Proxy(target, handler), а revoke - функция, \"выключающая\" этот прокси, делающая его невалидным. При вызове proxy.revoke() прокси становится неиспользуемым, любая установленная у обработчика handler ловушка выбросит исключение, если прокси уже отозван - он отозван навсегда и становится целью сборщика мусора. Повторный вызов revoke() не даст никакого результата. \nvar revocable = Proxy.revocable({}, {\n  get: function(target, name) {\n    return \"[[\" + name + \"]]\";\n  }\n});\nvar proxy = revocable.proxy;\nconsole.log(proxy.foo); // \"[[foo]]\"\nrevocable.revoke();\nconsole.log(proxy.foo); // TypeError is thrown\nproxy.foo = 1; // TypeError again\ndelete proxy.foo;  // still TypeError\ntypeof proxy; // \"object\", typeof doesn't trigger any trap"
        }
      ]
    },
    {
      "name": "New Deck",
      "classDeck": "deck",
      "deck": "New Deck",
      "type": "New Deck",
      "description": "",
      "objects": [
        {
          "name": "1",
          "classDeck": "card",
          "deck": "New Deck",
          "type": "wqwq",
          "description": "wwwwwwwww",
          "id": 6.1
        }
      ],
      "id": 6
    }
  ]
}