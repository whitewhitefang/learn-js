{
  "js": [
    {
      "name": "AggregateError",
      "classDeck": "deck",
      "deck": "build-in object",
      "id": 1.2,
      "type": "AggregateError",
      "description": "объект, представляющий собой ошибку, в которую \"завернуты\" несколько возникших ошибок. Такое исключение выбрасывается, когда при выполнении одной операции возможно возникновение множества ошибок - например, при Promise.any() в случае, когда все промисы будут отклонены.\nPromise.any([\n  Promise.reject(new Error(\"some error\")),\n]).catch(e => {\n  console.log(e instanceof AggregateError); // true\n  console.log(e.message);                   // \"All Promises rejected\"\n  console.log(e.name);                      // \"AggregateError\"\n  console.log(e.errors);                    // [ Error: \"some error\" ]\n});",
      "objects": [
        {
          "name": "AggregateError()",
          "classDeck": "card",
          "deck": "AggregateError",
          "id": 1.21,
          "type": "constructor",
          "description": "конструктор в синтаксисе\nnew AggregateError(errors, message)\n создает одну ошибку для нескольких ошибок, которые нужно обернуть в один объект ошибки. errors - итерируемый массив ошибок (которые в действительности могут не быть экземплярами объекта Error), он будет сохранен в свойстве AggregateError.prototype.errors; необязательный параметр message - человекочитаемое описание ошибки. Отлов ошибок такого рода - через instanceof AggregateError."
        },
        {
          "name": "AggregateError.prototype.errors",
          "classDeck": "card",
          "deck": "AggregateError",
          "id": 1.22,
          "type": "property",
          "description": "массив содержащихся в объекте AggregateError ошибок"
        }
      ]
    },
    {
      "name": "Array",
      "classDeck": "deck",
      "deck": "build-in object",
      "id": 1.1,
      "type": "Array",
      "description": "класс Array в JavaScript - глобальный объект, использующийся при создании массивов - списко-подобных высокоуровневых объектов. Прототип массивов имеет методы для операций их обхода и изменения. Ни длина массивов, ни тип данных их элементов не являются в JS фиксированными. Т.к. длину массивов можно изменить в любое время, а данные можно сохранять в массиве необязательно в сплошном порядке, то JavaScript не гарантирует их компактность, это зависит от того, как программист будет их использовать. В основном, эти возможности выгодны разработчикам, но если они для вас нежелательны, в текущем контексте, подумайте об использовании типизированных массивов. Массивы не могут использовать строки в качестве индексов элементов (как в ассоциативных массивах), они должны использовать для этого целые числа. Установка или попытка доступа к нецелым индексам при помощи нотации квадратных скобок (или через точку) не установят и не выберут элемент в массиве, но установят или запросят переменную, ассоциированную с объектом свойств этого массива. Объект свойств массива и список элементов массива - вещи разные, и операции обхода или изменения нельзя применить в этим именованным свойствам. \nНумерация элементов идет с 0, последний элемент идет под индексом length - 1. Использование неверного индекса вернет undefined. Доступ к элементам - только через нотацию с квадратными скобками. Добавление элементов в свободные \"слоты\" соответственно увеличит длину массива (последний слот + 1), уменьшение длины массива приведет к удалению элементов.\nОбщие правила поиска в массивах. Если вам нужен индекс найденного элемента, используйте Array.prototype.findIndex(); если нужен индекс значения, используйте Array.prototype.indexOf() (он похож на метод .findIndex(), но проверяет каждый элемент на равенство значению вместо применения проверяющей функции); если нужно найти значение, существующее в данном массиве, используйте Array.prototype.includes() (и вновь, оно проверяет каждый элемент на равенство значений вместо использования проверяющей функции); если нужно найти все элементы, отвечающие требованиям проверяющей функции, используйте Array.prototype.some(). \nПример с двумерным массивом - создание шахматной доски:\nlet board = [\n  ['R','N','B','Q','K','B','N','R'],\n  ['P','P','P','P','P','P','P','P'],\n  [' ',' ',' ',' ',' ',' ',' ',' '],\n  [' ',' ',' ',' ',' ',' ',' ',' '],\n  [' ',' ',' ',' ',' ',' ',' ',' '],\n  [' ',' ',' ',' ',' ',' ',' ',' '],\n  ['p','p','p','p','p','p','p','p'],\n  ['r','n','b','q','k','b','n','r'] ]\nconsole.log(board.join('\\n') + '\\n\\n')\n// Move King's Pawn forward 2\nboard[4][4] = board[6][4]\nboard[6][4] = ' '\nconsole.log(board.join('\\n'))",
      "objects": [
        {
          "name": "Array()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.11,
          "type": "constructor",
          "description": "в синтаксисе let arr = new Array(el_1, el_2,...) или new Array(arrLength) используется при создании массивов. Элементы el_1, el_2... инициализируются массивом, кроме случая, когда аргумент всего один и это число (тогда расценит этот параметр как задаваемую длину массива - arrLength, значение в диапазоне от 0 до 253 - 1 включительно, создает \"пустые\" слоты со значениями undefined) - работает только в конструкторе, но не при литеральном создании массива. \nСинтаксис литеральной нотации - let arr = [] или [el_1, el2, ...]. "
        },
        {
          "name": "Array[Symbol.species]",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.12,
          "type": "static property",
          "description": "Array[Symbol.species] - свойство-аксессор, возвращающее дефолтный конструктор Array. \nArray[Symbol.species]; // function Array()\nКонструкторы подклассов перезаписывают это значение, но можно это исправить.\nclass MyArray extends Array {\n  // Overwrite MyArray species to the parent Array constructor\n  static get [Symbol.species]() { return Array; }\nНет поддержки в IE."
        },
        {
          "name": "Array.from()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.13,
          "type": "static method",
          "description": "Array.from() - статический метод, создающий новый массив - поверхностную копию массивоподобного или любого другого итерируемого объекта (Map, Set). Синтаксис - Array.from(arrayLike, mapFn, thisArg). arrayLike - изначальный объект. mapFn (необязательно) - функция, которая будет применена к каждому элементу массива. thisArg (необязательно) - значение, которое функция mapFn будет рассматривать как this при вызове. Метод вернет новый эксземпляр массива Array. Более подробно цепочку метода можно описать как Array.from(obj).map(mapFn, thisArg), только без создания промежуточной копии массива. Это особенно важно для определенных подклассов массивов, таких как типизированные массивы, т.к. промежуточный массив обрежет значения первоначального массива, чтобы они соответствовали определенному типу. Начиная с ES2015 стало возможно создавать подклассы как встроенных, так и пользовательских классов. В результате, статические методы, такие как Array.from(), наследуются подклассами Array и создают новые экземпляры подкласса, а не класса Array.\nСоздание массива из строки:\nArray.from('foo');// [ \"f\", \"o\", \"o\" ]\nМассив из коллекции Map:\nconst map = new Map([['1', 'a'], ['2', 'b']]);\nArray.from(map);// [['1', 'a'], ['2', 'b']]\nArray.from(map.values());// ['a', 'b'];\nArray.from(map.keys());// ['1', '2'];\nМассив из NodeList:\nconst images = document.getElementsByTagName('img');\nconst sources = Array.from(images, image => image.src);\nconst insecureSources = sources.filter(link => link.startsWith('http://'));\nСоздание массива аргументов:\nfunction f() {\n  return Array.from(arguments);\n}\nf(1, 2, 3);// [ 1, 2, 3 ]\nПрименение стрелочных функций с этим методом:\nArray.from([1, 2, 3], x => x + x);// [2, 4, 6]\n// Generate a sequence of numbers. Since the array is initialized with `undefined` on each position, the value of `v` below will be `undefined`\nArray.from({length: 5}, (v, i) => i);// [0, 1, 2, 3, 4]\nconst range = (start, stop, step) => Array.from({ length: (stop - start) / step + 1}, (_, i) => start + (i * step));\nrange(0, 4, 1);// [0, 1, 2, 3, 4]\nrange(1, 10, 2);// [1, 3, 5, 7, 9]\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.isArray()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.14,
          "type": "static method",
          "description": "Array.isArray() - статический метод, определяющий в синтаксисе Array.isArray(value), является ли переданное значение value массивом Array. Возвращает true или false. "
        },
        {
          "name": "Array.of()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.15,
          "type": "static method",
          "description": "Array.of() - статический метод, создающий новый экземпляр массива Array из произвольного числа аргументов, независимо от их количества и типа. Отличает метод от конструктора Array() обработкой аргумента в виде одного целого числа: Array.of(7) создает массив с единственным элементом 7, в то время как Array(7) создаст пустой массив с длиной 7 (в реальности, он не будет совсем пустым, у него будут слоты со значениями undefined). Возвращает новый экземпляр массива. Метод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.length",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.16,
          "type": "property",
          "description": "Array.prototype.length - свойство объекта типа Array, устанавливающее или возвращающее количество элементов в данном массиве. Значение - беззнаковое 32-битное целое число, всегда бОльшее самого большого индекса в этом массиве, т.е. число от 0 до 253 (не включительно). Вы можете в любой момент установить заданную длину для \"обрезки\" массива (\"лишние\" элементы будут удалены). Когда вы \"расширяете\" массив, увеличивая длину, количество элементов увеличивается, но это будут пустые неперебираемые слоты со значениями undefined. \nvar numbers = [];\nnumbers.length = 3;\nconsole.log(numbers); // [undefined, undefined, undefined]\nСвойство перезаписываемое, но не перечисляемое и неизменяемое.   "
        },
        {
          "name": "Array.prototype[Symbol.unscopables]",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.17,
          "type": "property",
          "description": "Array.prototype[Symbol.unscopables] - символьное свойство, содержащее имена свойств, не включенных в стандарт до ES2015. Они исключаются из применяемых с устаревшим оператором привязки with (т.е. они не \"видны\" оператору). Это свойства at(), copyWithin(), entries(), fill(), find(), findIndex(), includes(), keys(), values(). Свойство неперезаписываемое, неперечисляемое, но изменяемое (конфигурируемое). Не поддерживается в IE."
        },
        {
          "name": "Array.prototype.at()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.18,
          "type": "method",
          "description": "Array.prototype.at() - внутренний метод в синтаксисе arr.at(index) принимающий целое значение индекса элемента index и возвращающий элемент массива arr по этому индексу. Разрешены отрицательные значения - они означают отсчет с конца массива. У последнего элемента индекс равен -1. Если указанного индекса не существует, вернет undefined. Метод - самый лаконичный и удобочитаемый среди методов нахождения предпоследнего (-2) элемента массива. Но у него пока еще очень плохая поддержка, он поддерживается фактически только в Chrome и Edge. "
        },
        {
          "name": "Array.prototype.concat()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.19,
          "type": "method",
          "description": "Array.prototype.concat() - внутренний метод, использующийся для объединения двух или более массивов. Не меняет первоначальные массивы, возвращает новый массив. Синтаксис - const newArr = oldArr.concat(value_1, value_2, ...). Параметры value... - значения и/или массивы, которые надо слить с изначальным массивом oldArr. Если всем параметры опущены, будет возвращена поверхностная копия изначального массива. Добавляет аргументы в том порядке, в котором они находятся, элементы этого аргумента (если это массив) или сам аргумент (если это не массив). Не обрабатывает рекурсивно вложенные массивы аргументов (т.е. переносит в новый массив ссылку на массив-аргумент). Метод не меняет значение this или любой из обрабатываемых как аргументы массив, но возвращает поверхностную копию, содержащую копии тех же элементов, взятых в оригинальных массивах. Эти элементы копируются в новый массив следующим образом: Ссылки на объекты (а не сами объекты) - метод копирует ссылки на объекты в новый массив, оба, и старый, и новый массивы ссылаются на один и тот же объект, следовательно, при изменении объекта эти изменения видны новому, и оригинальным массивам. Это касается и элементов массивов-аргументов, которые сами являются массивами. Данные разных типов - строки, числа и булевы значения (не объекты String, Number или Boolean) - метод копирует значения в новый массив. \nconst num1 = [1, 2, 3];\nconst num2 = [4, 5, 6];\nconst num3 = [7, 8, 9];\nconst numbers = num1.concat(num2, num3);\nconsole.log(numbers);// [1, 2, 3, 4, 5, 6, 7, 8, 9]\nОбъединение массивов с добавлением элементов из них:\nconst letters = ['a', 'b', 'c'];\nconst alphaNumeric = letters.concat(1, [2, 3]);\nconsole.log(alphaNumeric);// ['a', 'b', 'c', 1, 2, 3]\nСлияние с вложенными массивами:\nconst num1 = [[1]];\nconst num2 = [2, [3]];\nconst numbers = num1.concat(num2);\nconsole.log(numbers);// [[1], 2, [3]]\nnum1[0].push(4);\nconsole.log(numbers);// [[1, 4], 2, [3]]"
        },
        {
          "name": "Array.prototype.copyWithin()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.121,
          "type": "method",
          "description": "Array.prototype.copyWithin() - метод в синтаксисе arr.copyWithin(target, start, end) создает поверхностную копию части массива, начиная с элемента start (если пропущен, начнет отсчет с 0, при отрицательном значении считает элементы с конца) и заканчивая end (не включительно, при отрицательном значении считает с конца массива, если пропущен - значением будет arr.length) и копирует ее в этот же массив на место элементов, начиная с target. Возвращает массив с его неизмененной длиной. \n[1, 2, 3, 4, 5].copyWithin(-2);// [1, 2, 3, 1, 2]\n[1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5]\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4);// [4, 2, 3, 4, 5]\n[1, 2, 3, 4, 5].copyWithin(-2, -3, -1);// [1, 2, 3, 3, 4]\n[].copyWithin.call({length: 5, 3: 1}, 0, 3);// {0: 1, 3: 1, length: 5}\nvar i32a = new Int32Array([1, 2, 3, 4, 5]);\ni32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]\nНе поддерживается в IE."
        },
        {
          "name": "Array.prototype.entries()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.122,
          "type": "method",
          "description": "Array.prototype.entries() - метод в синтаксисе arr.entries() возвращает новый объект итератора массива, содержащий пары ключ/значение для каждого индекса в массиве. \nconst a = ['a', 'b', 'c'];\nfor (const [index, element] of a.entries())\n  console.log(index, element);\n// 0 'a'\n// 1 'b'\n// 2 'c'"
        },
        {
          "name": "Array.prototype.every()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.123,
          "type": "method",
          "description": "Array.prototype.every() - метод в синтаксисе arr.every(callback(element, index, array), thisArg) проверяет, все ли элементы массива соответствуют условиям, изложенным в колбэк-функции. Возвращает булево значение - true, если колбэк-функция вернет true для каждого элемента, иначе работа метода будет немедленно прервана и вернется false. Колбэк-функция принимает три аргумента: обязательный element - текущий обрабатываемый элемент массива, необязательный index - индекс обрабатываемого элемента и необязательный array - массив, на котором вызван метод. Интересно, что вызванный на пустом массиве метод вернет true при любой колбэк-функции. Функция вызывается для каждого индекса, имеющего присвоенные значения. Не вызывается для удаленных индексов или которым значения ни разу не присваивались. Если методу передается опциональный аргумент thisArg, он будет использоваться как значение this колбэк-функции, иначе будет использоваться undefined. Метод не меняет массив, на котором вызван. Диапазон всех элементов для обработки колбэк-функцией устанавливается до первого вызова колбэка, так что функция не обработает элементы, добавленные к массиву после того, как метод начал свою работу. Если значения элементов меняются, будет рассмотрено значение в тот момент, когда элемент будет передан колбэк-функции. Удаленные элементы метод не посетит. \nfunction isBigEnough(element, index, array) {\n  return element >= 10;\n}\n[12, 5, 8, 130, 44].every(isBigEnough);   // false\n[12, 54, 18, 130, 44].every(isBigEnough); // true\nТо же самое с применением стрелочных функций.\n[12, 5, 8, 130, 44].every(x => x >= 10);   // false\n[12, 54, 18, 130, 44].every(x => x >= 10); // true"
        },
        {
          "name": "Array.prototype.fill()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.124,
          "type": "method",
          "description": "Array.prototype.fill() - метод в синтаксисе arr.fill(value, start, end) заменяет все элементы массива, начиная с индекса start (по умолчанию 0, если значение отрицательное, оно рассматривается как arr.length + start) и заканичивая end (по умолчанию, arr.length, если значение отрицательное, оно рассматривается как arr.length + end) на статическое значение value. Возвращает обновленный массив, заполненный значениями value. Метод намеренно является групповым (generic): он не требует, чтобы значение this было объектом Array. Это изменяющий метод: он изменит массив и вернет его же, а не его копию. Если первый аргумент - объект, каждый слот в массиве будет заполнен ссылкой на этот объект. \n[1, 2, 3].fill(4) // [4, 4, 4]\n[1, 2, 3].fill(4, 1)   // [1, 4, 4]\n[1, 2, 3].fill(4, 3, 3)  // [1, 2, 3]\n[1, 2, 3].fill(4, NaN, NaN) // [1, 2, 3]\nArray(3).fill(4) // [4, 4, 4]\n[].fill.call({ length: 3 }, 4)   // {0: 4, 1: 4, 2: 4, length: 3}\nlet arr = Array(3).fill({}) // [{}, {}, {}]\narr[0].hi = \"hi\"// [{ hi: \"hi\" }, { hi: \"hi\" }, { hi: \"hi\" }]\nПример с созданием матрицы из единиц:\nconst arr = new Array(3);\nfor (let i=0; i<arr.length; i++) {\n  arr[i] = new Array(4).fill(1); // Creating an array of size 4 and filled of 1\n}\narr[0][0] = 10;\nconsole.log(arr[0][0]); // 10\nconsole.log(arr[1][0]); // 1\nconsole.log(arr[2][0]); // 1\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.filter()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.125,
          "type": "method",
          "description": "Array.prototype.filter() - метод в синтаксисе let newArray = arr.filter(callback(currentValue, index. array), thisArg) создает новый массив из всех соответствующих требованию колбэк-функции элементов массива arr, на котором вызван. Колбэк - функция-предикат (возвращает логическое значение) для проверки элемента массива. true заставит скопировать элемент в новый массив, false - не копировать. сurrentValue - текущий обрабатываемый элемент. Необязательные параметры - index (текущий индекс обрабатываемого элемента), array - массив, к которому применяется метод и thisArg - значение this для вызываемой колбэк-функции. Если в новый массив не будет передан ни один элемент, вернется пустой массив. Функция вызывается для каждого индекса, имеющего присвоенные значения. Не вызывается для удаленных индексов или которым значения ни разу не присваивались. Метод не изменяет массив, на котором вызван. Диапазон всех элементов для обработки колбэк-функцией устанавливается до первого вызова колбэка, так что функция не обработает элементы, добавленные к массиву после того, как метод начал свою работу. Если значения элементов меняются, будет рассмотрено значение в тот момент, когда элемент будет передан колбэк-функции. Удаленные элементы метод не посетит. \nfunction isBigEnough(value) {\n  return value >= 10\n}\nlet filtered = [12, 5, 8, 130, 44].filter(isBigEnough)// filtered is [12, 130, 44]\nПример с отбором всех простых чисел из имеющегося массива:\nconst array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];\nfunction isPrime(num) {\n  for (let i = 2; num > i; i++) {\n    if (num % i == 0) {\n      return false;\n    }\n  }\n  return num > 1;\n}\nconsole.log(array.filter(isPrime)); // [2, 3, 5, 7, 11, 13]\nФильтрация неверных вводных данных из JSON:\nlet arr = [\n  { id: 15 },\n  { id: -1 },\n  { id: 0 },\n  { id: 3 },\n  { id: 12.2 },\n  { },\n  { id: null },\n  { id: NaN },\n  { id: 'undefined' }\n]\nlet invalidEntries = 0\nfunction filterByID(item) {\n  if (Number.isFinite(item.id) && item.id !== 0) {\n    return true\n  }\n  invalidEntries++\n  return false;\n}\nlet arrByID = arr.filter(filterByID)\nconsole.log('Filtered Array\\n', arrByID)// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]\nconsole.log('Number of Invalid Entries = ', invalidEntries)// Number of Invalid Entries = 5\nПоиск по символам или фразе в массиве:\nconst fruits = ['apple', 'banana', 'grapes', 'mango', 'orange']\nconst filterItems = (arr, query) => {\n  return arr.filter(el => el.toLowerCase().indexOf(query.toLowerCase()) !== -1)\n}\nconsole.log(filterItems(fruits, 'ap'))  // ['apple', 'grapes']\nconsole.log(filterItems(fruits, 'an'))  // ['banana', 'mango', 'orange']"
        },
        {
          "name": "Array.prototype.find()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.126,
          "type": "method",
          "description": "Array.prototype.find() - метод в синтаксисе arr.find(callback(element, index.array), thisArg) возвращает значение первого найденного в массиве arr элемента, отвечающее проверке функцией callback. Если такого значения не найдено, вернет undefined. \nОбщие правила поиска в массивах. Если вам нужен индекс найденного элемента, используйте Array.prototype.findIndex(); если нужен индекс значения, используйте Array.prototype.indexOf() (он похож на метод .findIndex(), но проверяет каждый элемент на равенство значению вместо применения проверяющей функции); если нужно найти значение, существующее в данном массиве, используйте Array.prototype.includes() (и вновь, оно проверяет каждый элемент на равенство значений вместо использования проверяющей функции); если нужно найти все элементы, отвечающие требованиям проверяющей функции, используйте Array.prototype.some(). \nCallback-функция метода принимает три аргумента: текущий элемент массива element, текущий индекс (положение) элемента в массиве index и массив, на котором вызван метод array. Опциональный аргумент метода - thisArg - объект, который следует использовать как this внутри колбэк-функции. Будьте осторожны с возвращаемым значением и условными операторами, индекс 0 оператор if или другие предикативные конструкции расценят как false. Механика метода: колбэк-функция вызывается для каждого индекса в массиве, при первом же найденном соответствии метод будет прерван и вернет этот элемент. Метод обрабатывает все индексы, в т.ч. без присвоенных значений, поэтому он может быть менее эффективен в парсинге массивов, чем тот, что просматривает в массивах только индексы с присвоенными значениями. Если указан thisArg, он будет использоваться как this внутри колбэк-функции при каждом ее вызове, иначе используется undefined. Метод не изменяет массив, на котором вызван, но колбэк-функция внутри него может это делать. А раз так, то элементы, обрабатываемые методом find, инициализируются перед первым вызовом колбэк-функции. Исходя из этого: колбэк-функция не обработает никакой элемент, добавленный в массив после начала работы метода; если существующий в массиве элемент еще не обработан и изменяется колбэком, его значение, передаваемое колбэк-функции, будет значением, существующим на момент посещения индекса элемента; удаленные элементы также посещаются методом. \nconst inventory = [\n  {name: 'apples', quantity: 2},\n  {name: 'bananas', quantity: 0},\n  {name: 'cherries', quantity: 5}\n];\nfunction isCherries(fruit) {\n  return fruit.name === 'cherries';\n}\nconsole.log(inventory.find(isCherries));// { name: 'cherries', quantity: 5 }\nТо же с использованием стрелочной функции:\nconst result = inventory.find( ({ name }) => name === 'cherries' );\nconsole.log(result) // { name: 'cherries', quantity: 5 }\nНахождение простого числа в массиве:\nfunction isPrime(element, index, array) {\n  let start = 2;\n  while (start <= Math.sqrt(element)) {\n    if (element % start++ < 1) {\n      return false;\n    }\n  }\n  return element > 1;\n}\nconsole.log([4, 6, 8, 12].find(isPrime)); // undefined, not found\nconsole.log([4, 5, 8, 12].find(isPrime)); // 5\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.findIndex()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.127,
          "type": "method",
          "description": "Array.prototype.findIndex() - метод в синтаксисе arr.findIndex(callback(element, index, array), thisArg) возвращает индекс первого найденного в массиве элемента, отвечающего требованиям проверочной функции callback. Если элемент не найден или arr.length = 0, вернет -1. Отличается от метода Array.prototype.find() возвращаемым значением - возвращает индекс, а .find() возвращает значение найденного элемента. callback - функция, запускаемая на каждом значении в массиве, пока она не вернет true, показывая, что найден элемент, соответствующий всем условиям. Принимает три аргумента: element - текущий обрабатываемый элемент в массиве, index (необязательно) - индекс обрабатываемого в данный момент элемента, array (необязательно) - массив, на котором вызывается метод. Также есть необязательный параметр thisArg - объект this, передаваемый колбэк-функции при ее вызове. Иначе ей передается undefined. В отличие от других методов массива, таких как Array.some(), колбэк-функция вызывается и для индексов без присвоенных значений. Диапазон обрабатываемых элементов устанавливается до первого вызова колбэка, он не будет включать элементы, добавленные в массив после начала работы метода. Если элемент существует в массиве, но еще не посещен и изменяется колбэком, его значение, передаваемое колбэк-функции, будет значением, существовавшим на момент посещения индекса методом. Удаленные элементы также обходятся методом. Пример с нахождением индекса простого числа в массиве:\nfunction isPrime(num) {\n  for (let i = 2; num > i; i++) {\n    if (num % i == 0) {\n      return false;\n    }\n  }\n  return num > 1;\n}\nconsole.log([4, 6, 8, 9, 12].findIndex(isPrime)); // -1, not found\nconsole.log([4, 6, 7, 9, 12].findIndex(isPrime)); // 2 (array[2] is 7)\nПример с применением стрелочных функций:\nconst fruits = [\"apple\", \"banana\", \"cantaloupe\", \"blueberries\", \"grapefruit\"];\nconst index = fruits.findIndex(fruit => fruit === \"blueberries\");\nconsole.log(index); // 3\nconsole.log(fruits[index]); // blueberries\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.forEach()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.128,
          "type": "method",
          "description": "Array.prototype.forEach() - метод в синтаксисе arr.forEach(callback(currentValue, index, array), thisArg) запускает колбэк-функцию для каждого элемента массива. Колбэк принимает до трех аргументов: обязательный currentValue - текущий обрабатываемый элемент массива, необязательный index - индекс обрабатываемого элемента и необязательный array - массив, на котором вызван метод. Необязательный параметр thisArg - значение, рассматриваемое как this при запуске колбэка (при использовании стрелочных функций аргумент нужно пропустить). Возвращаемое значение - undefined. Колбэк вызывается для каждого элемента в массиве в порядке возрастания. Она не вызывается для индексов удаленных или неинициализированых свойств (как у разреженных массивов). Диапазон обрабатываемых элементов устанавливается до первого вызова колбэка, он не будет включать элементы, добавленные в массив после начала работы метода. Если элемент существует в массиве, но еще не посещен и изменяется колбэком, его значение, передаваемое колбэк-функции, будет значением, существовавшим на момент посещения индекса методом. Удаленные перед посещением метода элементы не посещаются. Если уже посещенный элемент удаляется (например, при помощи .shift()) во время итерации, то элемент, следующий за удаленным элементом, пропускается (т.к. в данном случае индекс сдвигается и на место удаленного \"встает\" следующий элемент). В измененном массиве он, естественно, останется.\nlet words = ['one', 'two', 'three', 'four']\nwords.forEach(function(word) {\n  console.log(word)\n  if (word === 'two') {\n    words.shift() //'one' will delete from array\n  }\n}) // one // two // four\nconsole.log(words);  //['two', 'three', 'four']\nМетод не делает копию массива перед его обработкой. В отличие от методов .map() или .reduce() он всегда возвращает undefined и не применяется по цепочке. Типичное применение - запуск побочных эффектов в конце цепочки. Сам метод не меняет массив, на котором вызван, а вот колбэк может. Никакого другого способа для остановки цикла метода, кроме выброса исключения, нет. Если для вас важна возможность его прерывания, этот метод для вас не подходит. Досрочное прерывание можно выполнить применением: простого цикла for, циклами for ... of / for ... in, методами Array.prototype.every(), Array.prototype.some(), Array.prototype.find(), Array.prototype.findIndex(). Метод ожидает синхронной функции, он не ждет промисов. Трижды убедитесь, что не возникает осложнений, если вы используете промисы (или асинхронные функции) в качестве колбэк-функции метода forEach(). \nПример с пропуском неинициализированных элементов (колбэк для них не вызывается):\nconst arraySparse = [1,3,,7]\nlet numCallbackRuns = 0\narraySparse.forEach(function(element) {\n  console.log(element)\n  numCallbackRuns++\n})\nconsole.log(\"numCallbackRuns: \", numCallbackRuns)\n// 1\n// 3\n// 7\n// numCallbackRuns: 3\nЗамена цикла методом:\nconst items = ['item1', 'item2', 'item3']\nconst copyItems = []\n// before\nfor (let i = 0; i < items.length; i++) {\n  copyItems.push(items[i])\n}\n// after\nitems.forEach(function(item){\n  copyItems.push(item)\n})\nЗамена методу console.log() для построчного вывода индекса и значения элементов массива:\nfunction logArrayElements(element, index, array) {\n  console.log('a[' + index + '] = ' + element)\n}\n[2, 5, , 9].forEach(logArrayElements)\n// logs:\n// a[0] = 2\n// a[1] = 5\n// a[3] = 9\nПример с использованием аргумента this:\nfunction Counter() {\n  this.sum = 0\n  this.count = 0\n}\nCounter.prototype.add = function(array) {\n  array.forEach(function countEntry(entry) {\n    this.sum += entry\n    ++this.count\n  }, this)\n}\nconst obj = new Counter()\nobj.add([2, 5, 9])\nobj.count // 3\nobj.sum // 16\nПример с выравниванием масива (но лучше использовать метод .flat()):\nfunction flatten(arr) {\n  const result = []\n  arr.forEach(function(i) {\n    if (Array.isArray(i)) {\n      result.push(...flatten(i))\n    } else {\n      result.push(i)\n    }\n  })\n  return result\n}\nconst nested = [1, 2, 3, [4, 5, [6, 7], 8, 9]]\nflatten(nested) // [1, 2, 3, 4, 5, 6, 7, 8, 9]"
        },
        {
          "name": "Array.prototype.includes()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.129,
          "type": "method",
          "description": "Array.prototype.includes() - метод в синтаксисе arr.includes(value, index) определяет, содержит ли данный массив arr значение value среди своих данных, возвращая в зависимости от этого true или false. В поиске строк и символов метод регистрозависим. Необязательный аргумент index - индекс в массиве, с которого следует начать поиск (по умолчанию 0, при отрицательных значених начнет с элемента arr.length + index, если равен длине массива или больше ее - вернется false). -0, +0 и 0 считает равными, но false не интерпретирует как 0. \nПри негативных значениях index метод использует вычисленный индекс. Если он меньше или равен -1 * arr.length, будет инициирован поиск во всем массиве.\n// array length is 3, fromIndex is -100, computed index is 3 + (-100) = -97\nlet arr = ['a', 'b', 'c'];\narr.includes('a', -100); // true\narr.includes('b', -100); // true\narr.includes('c', -100); // true\narr.includes('a', -2);  // false\nМетод намеренно разработан общим - т.е. ему не обязательно быть вызванным на массиве, его можно применять и на других объектах, например, на массивомподобных объектах, таких как arguments. \n(function() {\n  console.log(Array.prototype.includes.call(arguments, 'a'))  // true\n  console.log(Array.prototype.includes.call(arguments, 'd'))  // false\n})('a','b','c')Метод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.indexOf()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.131,
          "type": "method",
          "description": "Array.prototype.indexOf() - метод в синтаксисе arr.indexOf(element, index) вернет первый индекс, по которому будет найден элемент element в массиве arr, или -1, если такой элемент не будет найден. Необязательный аргумент index - индекс, с которого следует начать поиск. Если он больше или равен длине массива, вернется -1 (что означает, поиск не был проведен). Отрицательное значение рассматривается как отступ от конца массива, (но поиск в любом случае будет идти в направлении слева направо). Значение по умолчанию - 0 (поиск по всему массиву). Метод использует при поиске строгое сравнение (===). Для строк применяется String.prototype.indexOf(). \nПример с нахождением всех вхождений элемента:\nvar indices = [];\nvar array = ['a', 'b', 'a', 'c', 'a', 'd'];\nvar element = 'a';\nvar idx = array.indexOf(element);\nwhile (idx != -1) {\n  indices.push(idx);\n  idx = array.indexOf(element, idx + 1);\n}\nconsole.log(indices);// [0, 2, 4]"
        },
        {
          "name": "Array.prototype.join()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.132,
          "type": "method",
          "description": "Array.prototype.join() - метод в синтаксисе arr.join(separator) создает и возвращает новую строку из всех элементов массива (или массивоподобного объекта) arr, разделенных запятой (по умолчанию) или другим разделителем separator. Если в массиве всего один элемент - вернется строка из одного элемента без разделителей. Задав в качестве разделителя пустую строку, мы получим строку из элементов, ничем не отделенных друг от друга. При пустом массиве, а также если единственным элементом массива является null или undefined, вернется пустая строка. \nvar a = ['Wind', 'Water', 'Fire'];\na.join();      // 'Wind,Water,Fire'\na.join(', ');  // 'Wind, Water, Fire'\na.join(' + '); // 'Wind + Water + Fire'\na.join('');    // 'WindWaterFire'"
        },
        {
          "name": "Array.prototype.keys()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.133,
          "type": "method",
          "description": "Array.prototype.keys() - метод в синтаксисе arr.keys() возвращает новый итератор объекта Array, содержащий ключи (индекс) для каждого индекса в массиве. Метод в том числе обходит индексы с неприсвоенными значениями (пустые слоты).\nvar arr = ['a', , 'c'];\nvar sparseKeys = Object.keys(arr);\nvar denseKeys = [...arr.keys()];\nconsole.log(sparseKeys); // ['0', '2']\nconsole.log(denseKeys);  // [0, 1, 2]\nНе поддерживается в IE."
        },
        {
          "name": "Array.prototype.lastIndexOf()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.134,
          "type": "method",
          "description": "Array.prototype.lastIndexOf() - метод в синтаксисе arr.lastIndexOf(element, index) возвращает последний индекс вхождения искомого элемента element в массиве arr, или -1, если элемент не будет найден. Поиск идет в обратном порядке - справа налево, начиная с индекса index (необязательный аргумент, по умолчанию - arr.length - 1, в этом случае поиск идет по всему массиву). Если index больше или равен длине массива, поиск также будет вестись по всему массиву, отрицательное значение рассматривается как отступ от конца массива (но поиск ведется так же слева направо). При отрицательных значениях index использует вычисленный индекс, и если он равен или меньше 0, метод вернет -1. Использует строгое сравнение (===). \nvar numbers = [2, 5, 9, 2];\nnumbers.lastIndexOf(2);     // 3\nnumbers.lastIndexOf(7);     // -1\nnumbers.lastIndexOf(-7);// -1\nnumbers.lastIndexOf(2, 3);  // 3\nnumbers.lastIndexOf(2, 2);  // 0\nnumbers.lastIndexOf(2, -2); // 0\nnumbers.lastIndexOf(2, -1); // 3"
        },
        {
          "name": "Array.prototype.map()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.135,
          "type": "method",
          "description": "Array.prototype.map() - метод в синтаксисе let newArray = arr.map(callback(currentValue, index, array), thisArg) создает новый массив, заполненный результатами применения к каждому элементу массива arr колбэк-функции. Колбэк принимает три аргумента: обязательный currentValue - текущий обрабатываемый элемент массива, необязательный index - индекс текущего элемента, необязательный array - массив, на котором вызван метод. Опциональный аргумент thisArg - значение, которое будет рассматриваться как this колбэк-функцией. Колбэк будет вызываться только для индексов с присвоенными значениями (даже если им присвоено undefined). Но не вызывается для пропущенных элементов, если они были удалены или никогда не устанавливались. Диапазон обрабатываемых элементов устанавливается до первого вызова колбэка. Элементы, добавленные в массив после начала работы метода не будут посещены колбэк-функцией. Если элемент существует в массиве и изменяется после вызова метода, его значением будет значение в момент его посещения колбэком. Удаленные после вызова метода элементы, но до их посещения колбэком, им уже не посещаются. В соответствии с установленным алгоритмом, если массив, ан котором вызывается метод, является разреженным, итоговый массив также будт разреженным с пустыми слотами в тех же индексах, что и в изначальном массиве. \nПример с преобразованием массива чисел в массив квадратных корней из них:\nlet numbers = [1, 4, 9]\nlet roots = numbers.map(function(num) {\n    return Math.sqrt(num)\n})\n// roots is now     [1, 2, 3]\n// numbers is still [1, 4, 9]\nПереформатирование объектов в массив:\nlet kvArray = [{key: 1, value: 10},\n               {key: 2, value: 20},\n               {key: 3, value: 30}]\nlet reformattedArray = kvArray.map(obj => {\n   let rObj = {}\n   rObj[obj.key] = obj.value\n   return rObj\n})// reformattedArray is now [{1: 10}, {2: 20}, {3: 30}],\nИспользование колбэк-функцией аргумента, берущегося из элемента. Но с этим надо быть осторожным, некоторые функции могут неправильно \"перенять\" аргументы (как, например, parseInt может неправильно расценить второй аргумент, у нее это обычно система счисления):\nlet numbers = [1, 4, 9]\nlet doubles = numbers.map(function(num) {\n  return num * 2\n})\n// doubles is now   [2, 8, 18]\n// numbers is still [1, 4, 9]\nПример общего использования метода на примере со строками:\nlet map = Array.prototype.map\nlet a = map.call('Hello World', function(x) {\n  return x.charCodeAt(0)\n})// a now equals [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]"
        },
        {
          "name": "Array.prototype.pop()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.136,
          "type": "method",
          "description": "Array.prototype.pop() - метод в синтаксисе arr.pop() удаляет последний элемент массива и возвращает его. Изменяет длину массива. В случае, если массив пуст, вернет undefined. Метод намеренно сделан общим, он может быть вызван или применен (при помощи Function.prototype.call() или Function.prototype.apply()) к объектам, похожим на массивы. Объекты, не имеющие свойства length, отражающее последний элемент в цепочке на основе числовых характеристик с отсчетом от 0, могут вести себя непредсказуемо. \nМетод Array.prototype.shift() ведет себя похожим образом, но удаляет элемент из начала массива.\nПример применения на массивоподобном объекте:\nvar myFish = {0:'angel', 1:'clown', 2:'mandarin', 3:'sturgeon', length: 4};\nvar popped = Array.prototype.pop.call(myFish); //same syntax for using apply( )\nconsole.log(myFish); // {0:'angel', 1:'clown', 2:'mandarin', length: 3}\nconsole.log(popped); // 'sturgeon'"
        },
        {
          "name": "Array.prototype.push()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.137,
          "type": "method",
          "description": "Array.prototype.push() - метод в синтаксисе arr.push(element_1, element_2, ...) добавляет один или более элементов в конец массива и возвращает новую длину массива. Метод намеренно сделан общим, он может быть вызван или применен (при помощи \nFunction.prototype.call() или Function.prototype.apply()) к объектам, похожим на массивы. Метод push основан на свойстве длины (length), определяющем где начать вставку данных значений. Если значение свойства не может быть приведено к числу, вместо него берется индекс 0. Это делает возможными случаи с отсутствующим свойством length, в результате это свойство будет создано. Несмотря на то, что строки по своей природе являются массивоподобными объектами, они не подходят для применения этого метода, так как неизменяемы. Это же касается объекта arguments. \nПример со слиянием массивов (будьте осторожны с количеством элементов в добавляемом массиве, он не должен быть большим, чтобы функция .apply() не \"перебрала\" с ограниченным количеством аргументов):\nlet vegetables = ['parsnip', 'potato']\nlet moreVegs = ['celery', 'beetroot']\nArray.prototype.push.apply(vegetables, moreVegs)\nconsole.log(vegetables)  // ['parsnip', 'potato', 'celery', 'beetroot']\nПример с использованием в массивоподобных абъектах:\nlet obj = {\n    length: 0,\n    addElem: function addElem(elem) {\n        // length is automatically incremented every time an element is added.\n        [].push.call(this, elem)\n    }\n}\nobj.addElem({})\nobj.addElem({})\nconsole.log(obj.length)// → 2"
        },
        {
          "name": "Array.prototype.reduce()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.138,
          "type": "method",
          "description": "Array.prototype.reduce() - метод в синтаксисе arr.reduce(callback(accumulator, currentValue, index, array), initialValue) запускает функцию преобразования (reducer) на каждом элементе массива, результатом которой на выходе становится единственное значение. Колбэк-функция преобразования принимает 4 аргумента: суммируемое значение accumulator (обязательный аргумент), текущий обрабатываемый элемент сurrentValue (обязательный), текущий индекс элемента index (необязательный, если предоставлен аргумент initialValue, начнет с 0, иначе начнет с индекса 1, приняв первый элемент массива за initialValue) и \"исходный\" массив array (также необязательный). Возвращаемым значением функции будет суммируемое значение, присваиваемое accumulator, запоминаемое на каждой итерации при прохождении массива, которое в итоге становится результирующим значением. Необязательный параметр initialValue - изначальное значение, принимаемое функцией как первый аргумент при первом вызове. Иначе изначальным accumulator становится первый элемент массива, а как currentValue он будет пропущен. Запуск .reduce() на пустом массиве без initialValue приведет к ошибке TypeError. \nПрименимы стрелочные функции:\n[0, 1, 2, 3, 4].reduce( (accumulator, currentValue, currentIndex, array) => accumulator + currentValue )\nДругими словами. При первом вызове колбэка accumulator и currentValue могут быть одним из двух значений. Если указан initialValue, то accumulator принимается равным initialValue и currentValue будет равен первому значению в массиве. Если initialValue не указан, accumulator равен первому значению в массиве и currentValue равен второму (следующему) значению массива. В первом случае колбэк запустится на индексе 0, во втором - на индексе 1. Соответственно, если в массиве всего один элемент и initialValue не указан, или initialValue указан, но массив пуст - вернется это единственное значение (единственный элемент или initialValue) без запуска колбэка. Лучше всегда предоставлять initialValue, метод будет работать лучше, в т.ч. на пустых и больших массивах.\nlet maxCallback = ( acc, cur ) => Math.max( acc.x, cur.x );\nlet maxCallback2 = ( max, cur ) => Math.max( max, cur );\n[ { x: 2 }, { x: 22 }, { x: 42 } ].reduce( maxCallback ); // NaN\n[ { x: 2 }, { x: 22 } ].reduce( maxCallback ); // 22\n[ { x: 2 } ].reduce( maxCallback ); // { x: 2 }\n[].reduce( maxCallback ); // TypeError\n[ { x: 22 }, { x: 42 } ].map( el => el.x )\n                        .reduce( maxCallback2, -Infinity );\nПример с выравниванием (разворачиванием) массива:\nvar flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {\n  return a.concat(b);\n});// flattened равен [0, 1, 2, 3, 4, 5]\nПример с созданием массива элементов из определенного свойства объектов, перечисленных в массиве. С применением spread-оператора.\nlet friends = [{\n  name: 'Anna',\n  books: ['Bible', 'Harry Potter'],\n  age: 21\n}, {\n  name: 'Bob',\n  books: ['War and peace', 'Romeo and Juliet'],\n  age: 26\n}, {\n  name: 'Alice',\n  books: ['The Lord of the Rings', 'The Shining'],\n  age: 18\n}]\n// allbooks - list which will contain all friends' books + additional list contained in initialValue\nlet allbooks = friends.reduce(function(accumulator, currentValue) {\n  return [...accumulator, ...currentValue.books]\n}, ['Alphabet'])\n// allbooks = [\n//   'Alphabet', 'Bible', 'Harry Potter', 'War and peace',\n//   'Romeo and Juliet', 'The Lord of the Rings',\n//   'The Shining'\n// ]\nПример с удалением дубликатов элементов (вместо Array.from(new Set(myArray))):\nlet myArray = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd'];\nlet myOrderedArray = myArray.reduce(function (accumulator, currentValue) {\n  if (accumulator.indexOf(currentValue) === -1) {\n    accumulator.push(currentValue);\n  }\n  return accumulator;\n}, [])\nconsole.log(myOrderedArray);// [a, b, c, e, d]\nПример с группировкой объектов по определенным свойствам:\nlet people = [\n  { name: 'Alice', age: 21 },\n  { name: 'Max', age: 20 },\n  { name: 'Jane', age: 20 }\n];\nfunction groupBy(objectArray, property) {\n  return objectArray.reduce(function (acc, obj) {\n    let key = obj[property]\n    if (!acc[key]) {\n      acc[key] = []\n    }\n    acc[key].push(obj)\n    return acc\n  }, {})\n}\nlet groupedPeople = groupBy(people, 'age')\n// groupedPeople is:\n// {\n//   20: [\n//     { name: 'Max', age: 20 },\n//     { name: 'Jane', age: 20 }\n//   ],\n//   21: [{ name: 'Alice', age: 21 }]\n// }"
        },
        {
          "name": "Array.prototype.reduceRight()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.139,
          "type": "method",
          "description": "Array.prototype.reduceRight() - метод в синтаксисе \narr.reduceRight(callback(accumulator, currentValue, index, array), initialValue) запускает функцию преобразования (reducer) на каждом элементе массива, как метод Array.prototype.reduce(), только с конца массива, справа налево. Результатом становится единственное значение. Колбэк-функция преобразования принимает 4 аргумента: суммируемое значение accumulator (обязательный аргумент) - значение, возвращенное предыдущим вызовом колбэка или initialValue (если оно установлено), текущий обрабатываемый элемент сurrentValue (обязательный), текущий индекс элемента index (необязательный, если предоставлен аргумент initialValue, начнет с 0, иначе начнет с индекса 1, приняв первый элемент массива за initialValue) и \"исходный\" массив array (также необязательный). Возвращаемым значением функции будет суммируемое значение, присваиваемое accumulator, запоминаемое на каждой итерации при прохождении массива, которое в итоге становится результирующим значением. Необязательный параметр initialValue - изначальное значение, принимаемое функцией как первый аргумент при первом вызове. Иначе изначальным accumulator становится последний элемент массива, а как currentValue он будет пропущен. Запуск .reduce() на пустом массиве без initialValue приведет к ошибке TypeError. reduceRight() запускает колбэк-функцию на каждом элементе, представленном в массие, исключая \"дыры\" массива. \nПри первом вызове колбэка accumulator и currentValue могут быть одним из двух значений. Если указан initialValue, то accumulator принимается равным initialValue и currentValue будет равен последнему значению в массиве. Если initialValue не указан, accumulator равен последнему значению в массиве и currentValue равен предпоследнему значению. Соответственно, если в массиве всего один элемент, вне зависимости от его положения, и initialValue не указан, или initialValue указан, но массив пуст - вернется это единственное значение (единственный элемент или initialValue) без запуска колбэка. Лучше всегда предоставлять initialValue, метод будет работать лучше, в т.ч. на пустых и больших массивах.\nПримеры см. у метода Array.prototype.reduce(). Единственное отличие - в направлении обхода массива:\nvar a = ['1', '2', '3', '4', '5'];\nvar left  = a.reduce(function(prev, cur) { return prev + cur; });\nvar right = a.reduceRight(function(prev, cur) { return prev + cur; });\nconsole.log(left);  // \"12345\"\nconsole.log(right); // \"54321\""
        },
        {
          "name": "Array.prototype.reverse()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.141,
          "type": "method",
          "description": "Array.prototype.reverse() - метод в синтаксисе arr.reverse() \"переворачивает\" массив на месте. Первый элемент становится последним, а последний первым. Метод перемещает элементы в массиве и возвращает ссылку на изменившийся массив. \nconst a = [1, 2, 3];\nconsole.log(a); // [1, 2, 3]\na.reverse();\nconsole.log(a); // [3, 2, 1]\nНамеренно разработан общим методом, может быть применен или вызван (при помощи Function.prototype.apply() или Function.prototype.call()) к/на объектах, похожих на массивы. Объекты, не имеющие свойства length, демонстрирующего последний элемент в непрерывном ряду, основанные на начале отсчета с 0 числовые свойства могут вести себя непредсказуемо. \nconst a = {0: 1, 1: 2, 2: 3, length: 3};\nconsole.log(a); // {0: 1, 1: 2, 2: 3, length: 3}\nArray.prototype.reverse.call(a); //same syntax for using apply()\nconsole.log(a); // {0: 3, 1: 2, 2: 1, length: 3}"
        },
        {
          "name": "Array.prototype.shift()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.142,
          "type": "method",
          "description": "Array.prototype.shift() - метод в синтаксисе arr.shift() удаляет первый элемент (по индексу 0) в массиве и возвращает удаленный элемент. Метод изменяет длину массива, \"сдвигая\" значения на 1 единицу вниз в индексе. Если длина уже равна 0, вернет undefined. Метод намеренно сделан общим, так что может быть применен или вызван (при помощи Function.prototype.apply() или Function.prototype.call()) к/на объектах, похожих на массивы. Объекты, не имеющие свойства length, демонстрирующего последний элемент в непрерывном ряду, основанные на начале отсчета с 0 числовые свойства могут вести себя непредсказуемо. Такой же метод для удаления последнего элемента массива - Array.prototype.pop().\nvar myFish = ['angel', 'clown', 'mandarin', 'surgeon'];\nconsole.log('myFish before:', JSON.stringify(myFish));// myFish before: ['angel', 'clown', 'mandarin', 'surgeon']\nvar shifted = myFish.shift();\nconsole.log('myFish after:', JSON.stringify(myFish));// myFish after: ['clown', 'mandarin', 'surgeon']\nconsole.log('Removed this element:', shifted);// Removed this element: angel\nПример с использованием в цикле:\nvar names = [\"Andrew\", \"Edward\", \"Paul\", \"Chris\" ,\"John\"];\nwhile( (i = names.shift()) !== undefined ) {\n    console.log(i);\n}// Andrew, Edward, Paul, Chris, John"
        },
        {
          "name": "Array.prototype.slice()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.143,
          "type": "method",
          "description": "Array.prototype.slice() - метод в синтаксисе arr.slice(start, end) возвращает поверхностную копию части массива arr (начиная с индекса start и до, но не включительно, индекса end) в виде нового объекта массива. Изначальный массив не изменяется. Аргументы необязательные. Индекс start начинает отсчет с 0, негативное значение может быть использовано и означает \"отступ\" от конца массива (slice(-2) выберет два последних элемента). Значение по умолчанию 0, если значение превышает длину массива, будет создан и возвращен пустой массив. Индекс end может быть негативным значением, оно означает \"отступ\" от конца массива (slice(0, -1) выберет все элементы без последнего в массиве). Если индекс не указан, будут выбраны все оставшиеся элементы. \nКак уже было сказано, создается поверхностная копия. Для элементов-объектов в новый массив копируются ссылки на них, и оригинальный, и новый массивы ссылаются на один и тот же объект, так что изменения в нем видны в обоих массивах. Для строк, чисел и булевых значений (не для объектов String, Number или Boolean) метод копирует их в новый массив, их изменения в изначальном массиве не приведут к их изменениям в новом. При добавлении элемента в \"старый\" массив \"новый\" не меняется.\nМетод также привязывается к массивоподобным объектам (при помощи \nFunction.prototype.apply() и Function.prototype.call()).   \nfunction list() {\n  return Array.prototype.slice.call(arguments)\n}\nlet list1 = list(1, 2, 3) // [1, 2, 3]\nВозможен синтаксис [].slice.call(arguments) вместо Array.prototype.slice.call(). Но лучше использовать bind().\nlet unboundSlice = Array.prototype.slice\nlet slice = Function.prototype.call.bind(unboundSlice)\nfunction list() {\n  return slice(arguments)\n}\nlet list1 = list(1, 2, 3) // [1, 2, 3]"
        },
        {
          "name": "Array.prototype.some()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.144,
          "type": "method",
          "description": "Array.prototype.some() - метод в синтаксисе arr.some(callback(element, index, array), thisArg) проверяет, соответствует ли хотя бы один элемент массива arr условиям проверочной функции callback. Возвращает булево значение. Колбэк-функция принимает три аргумента: обязательный параметр element - текущий обрабатываемый элемент, необязательный index - индекс элемента, обрабатываемого в данный момент, и необязательный array - массив, на котором вызван метод. Также необязательный параметр thisArg - значение, используемое как this при вызове колбэк-функции. Колбэк вызывается только для индексов с присвоенными значениями. Функция никогда не будет вызвана для удаленных индексов или индексов, которым ни разу не присваивалось значение ранее. Метод не изменяет массив, на котором вызван. Диапазон рассматриваемых элементов устанавливается до первого вызова колбэк-функции. Элементы, добавленные к массиву после начала работы метода не будут посещены колбэком. Если существующий в массиве, но еще не посещенный элемент изменяется колбэком, значением, передаваемым колбэку, будет то значение, которое было на момент посещения методом данного индекса. Удаленные элементы не посещаются. Вызов метода на пустом массиве всегда вернет false. \nfunction isBiggerThan10(element, index, array) {\n  return element > 10;\n}\n[2, 5, 8, 1, 4].some(isBiggerThan10);  // false\n[12, 5, 8, 1, 4].some(isBiggerThan10); // true\nТо же с использованием стрелочных функций:\n[2, 5, 8, 1, 4].some(x => x > 10);  // false\n[12, 5, 8, 1, 4].some(x => x > 10); // true\nПример с проверкой на существование свойства:\nconst fruits = ['apple', 'banana', 'mango', 'guava'];\nfunction checkAvailability(arr, val) {\n  return arr.some(function(arrVal) {\n    return val === arrVal;\n  });\n}\ncheckAvailability(fruits, 'kela');   // false\ncheckAvailability(fruits, 'banana'); // true\nВариант со стрелочной функцией:\nfunction checkAvailability(arr, val) {\n  return arr.some(arrVal => val === arrVal);\n}\nПример с конвертацией значений в булево значение:\nconst TRUTHY_VALUES = [true, 'true', 1];\nfunction getBoolean(value) {\n  'use strict';\n  if (typeof value === 'string') {\n    value = value.toLowerCase().trim();\n  }\n  return TRUTHY_VALUES.some(function(t) {\n    return t === value;\n  });\n}\ngetBoolean(false);   // false\ngetBoolean('false'); // false\ngetBoolean(1);       // true\ngetBoolean('true');  // true"
        },
        {
          "name": "Array.prototype.sort()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.145,
          "type": "method",
          "description": "Array.prototype.sort() - метод в синтаксисе arr.sort(compareFunction) сортирует элементы массива на месте и возвращает отсортированный массив. По умолчанию метод сортировки - по возрастанию, значения конвертируются в строки и их значением принимается значение кодовых точек в UTF-16. Все элементы со значением undefined переместятся в конец массива, две (или больше) кодовые точки у суррогатных пар оцениваются по раздельности. Затраты времени и ресурсов неоднозначны из-за различий в реализации. \nАргумент compareFunction - функция, определяющая порядок сортировки. Если параметр пропущен, элементы будут конвертироваться в строки, а затем сравниваться по кодовым точкам в Unicode. Если предоставлен - сравнение пойдет по этой функции, все элементы со значением undefined переместятся в конец массива и функция сравнения к ним применяться не будет. Функция оперирует двумя элементами - первым и вторым (a и b): \n- если она возвращает значение меньше 0 - индекс a будет ниже индекса b (сначала в массиве будет идти a, потом b)\n- если функция возвращает 0, положение a и b относительно друг друга не меняется, но меняется по отношению к другим сортируемым элементам; это поведение гарантируется только в ES2019, так что старые браузеры могут это не поддерживать\n- если функция возвращает значение больше 0, положение a и b не изменяется\n- функция должна возвращать всегда одно и то же значение для двух одних и тех же элементов, если возвращаются противоречивые результаты, порядок сортировки определен не будет. \nПри сравнении чисел, а не строк, функция может вычитать b из a. Такая функция отсортирует массив в порядке возрастания (если только не содержит Infinty и NaN). В массиве удобно применять стрелочные функции.\nlet numbers = [4, 2, 5, 1, 3];\nnumbers.sort((a, b) => a - b);\nconsole.log(numbers);// [1, 2, 3, 4, 5]\nПример с сортировкой объектов по одному из их свойств:\nvar items = [\n  { name: 'Edward', value: 21 },\n  { name: 'Sharpe', value: 37 },\n  { name: 'And', value: 45 },\n  { name: 'The', value: -12 },\n  { name: 'Magnetic', value: 13 },\n  { name: 'Zeros', value: 37 }\n];\nitems.sort(function (a, b) {\n  return a.value - b.value;\n});\nitems.sort(function(a, b) {\n  var nameA = a.name.toUpperCase(); // ignore upper and lowercase\n  var nameB = b.name.toUpperCase(); // ignore upper and lowercase\n  if (nameA < nameB) {\n    return -1;\n  }\n  if (nameA > nameB) {\n    return 1;\n  }\n  return 0;\n});\nДля сравнения строк, имеющих символы за пределами языковой плоскости, применяют String.prototype.localeCompare(). \nvar items = ['réservé', 'premier', 'communiqué', 'café', 'adieu', 'éclair'];\nitems.sort(function (a, b) {\n  return a.localeCompare(b);\n});// items is ['adieu', 'café', 'communiqué', 'éclair', 'premier', 'réservé']\nВ зависимости от природы функции сравнения затраты на работу метода сортировки могут быть очень большими. В таких случаях можно применять метод с созданием промежуточного массива с отбором нужных элементов методом Array.prototype.map(), с последующей его сортировкой. При проблемах с производительностью можно использовать бесплатную библиотеку Mapsort.\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.splice()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.146,
          "type": "method",
          "description": "Array.prototype.splice() - метод в синтаксисе let arrDelItems = arr.splice(start, deleteCount, item_1, item_2, ...) изменяет содержание массива, удаляя или передвигая существующие в нем элементы и/или на месте добавляя в него новые. Обязательный аргумент start - начальный индекс, с которого изменяется массив; если значение больше длины массива, будет расцениваться как длина массива и тогда не будет удален ни один существующий элемент, новые будут просто добавляться; если значение отицательное, расценивается как array.length + start (но если сумма станет меньше 0, работать массив начнет с индекса 0). Необязательный аргумент deleteCount - целое число, указывающее количество элементов, подлежащих удалению начиная с индекса start; если аргумент пропущен или его значение равно или больше чем array.length - start (т.е. количество подлежащих удалению элементов превышает количество оставшихся в массиве при отсчете от данного индекса), то будут удалены все элементы от start до конца массива, но такого поведения не будет в IE8; если значение равно 0 или отрицательно, ни один элемент удален не будет, но тогда вы должны обозначить хотя бы один новый элемент для вставки. Необязательные аргументы item_1, item_2... - добавляемые элементы, которые будут вставлены начиная с индекса start (т.е. новый элемент будет размещен именно по индексу start); если они отсутствуют, метод лишь удалит элементы из массива. Метод возвращает массив из удаленных элементов (даже если был удален лишь один, а если не удалялось ни одного - вернется пустой массив). Если число вставляемых элементов больше или меньше числа удаляемых, изменится длина массива.  \nlet myFish = ['angel', 'clown', 'drum', 'mandarin', 'sturgeon'];\nlet removed = myFish.splice(3, 1);\n// myFish is [\"angel\", \"clown\", \"drum\", \"sturgeon\"]\n// removed is [\"mandarin\"]\nremoved = myFish.splice(-2);\n// myFish is [\"angel\", \"clown\", \"sturgeon\"]\n// removed is [\"drum\"]"
        },
        {
          "name": "Array.prototype.toLocaleString()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.147,
          "type": "method",
          "description": "Array.prototype.toLocaleString() - метод в синтаксисе arr.toLocaleString(locales, options) возвращает строку, представляющую перечисленные элементы массива. Элементы конвертируются в строки методом toLocaleString, разделенные знаком вроде запятой. Необязательный параметр locales - строка или массив строк с тегами языка BCP-47. Основные формы и их интерпретация описана у встроенного объекта Intl. Необязательный параметр options - объект с набором конфигурационных свойств, у объектов - Object.prototype.toLocaleString(), у чисел - см. Number.prototype.toLocaleString(), у дат - Date.prototype.toLocaleString(). \nvar prices = ['￥7', 500, 8123, 12];\nprices.toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' });// \"￥7,￥500,￥8,123,￥12\"\nМетод не поддерживается в IE."
        },
        {
          "name": "Array.prototype.toString()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.148,
          "type": "method",
          "description": "Array.prototype.toString() - метод в синтаксисе arr.toString() возвращает строку, представляющую массив и его элементы. У массивов переопределен метод объектов toString. У массивов он объединяет массив и возвращает одну строку, содержащую все элементы массива, разделенные запятыми. JavaScript вызывает этот метод автоматически, когда массив должен быть представлен в виде текстового значения или где массив участвует в конкатенации строк. Метод уже общий, его можно вызвать с любым объектом. Тогда будет вызван Object.prototype.toString(). \nvar arr = ['bla', 'bla-bla-bla', {'name' : 'SomeName', 'age' : 30}, null, [1, 2, 3, [4, 5]]];\nlet str = arr.toString();\nalert(str);// bla,bla-bla-bla,[object Object],,1,2,3,4,5"
        },
        {
          "name": "Array.prototype.unshift()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.149,
          "type": "method",
          "description": "Array.prototype.unshift() - метод в синтаксисе arr.unshift(elem_1, elem_2, ...) добавляет один или больше элементов в начало массива и возвращает новую длину массива. Метод намеренно сделан общим, так что может быть применен или вызван (при помощи \nFunction.prototype.apply() или Function.prototype.call()) к/на объектах, похожих на массивы. Объекты, не имеющие свойства length, демонстрирующего последний элемент в непрерывном ряду, основанные на начале отсчета с 0 числовые свойства могут вести себя непредсказуемо. \nИмейте в виду, что если для вставки передаются несколько элементов, они вставляются \"куском\", целой частью, в начало объекта, в том порядке, в котором они перечислены как параметры. Следовательно, вызов unshift с n аргументов один раз и вызов метода n раз с одним аргументом не одно и то же.\nlet arr = [4, 5, 6]\narr.unshift(1, 2, 3)\nconsole.log(arr);// [1, 2, 3, 4, 5, 6]\narr = [4, 5, 6] // resetting the array\narr.unshift(1)\narr.unshift(2)\narr.unshift(3)\nconsole.log(arr)// [3, 2, 1, 4, 5, 6]"
        },
        {
          "name": "Array.prototype.values()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.151,
          "type": "method",
          "description": "Array.prototype.values() - метод в синтаксисе arr.values() возвращает новый итератор массива Array Iterator - объект, содержащий значения каждого индекса массива. Объект временный, для однократного применения. Является дефолтной реализацией метода Array.prototype[Symbol.iterator]\nArray.prototype.values === Array.prototype[Symbol.iterator];// true\nСоответственно, возможно применение метода .next():\nvar arr = ['a', 'b', 'c', 'd', 'e'];\nvar iterator = arr.values();\niterator.next();// Object { value: \"a\", done: false }\niterator.next().value;// \"b\"\niterator.next()[\"value\"];// \"c\"\niterator.next();// Object { value: \"d\", done: false }\niterator.next();// Object { value: \"e\", done: false }\niterator.next();// Object { value: undefined, done: true }\niteraror.next().value;// undefined\nПример с использованием итератора в цикле:\nvar arr = ['a', 'b', 'c', 'd', 'e'];\nvar iterator = arr.values();\nfor (let letter of iterator) {\n  console.log(letter);\n}  //\"a\" \"b\" \"c\" \"d\" \"e\"\nИтератор не хранит значения, лишь ссылки на них. Так что при изменении значений массива значения в объекте также изменятся. Метод не поддерживается в IE."
        },
        {
          "name": "Array.prototype[Symbol.iterator]()",
          "classDeck": "card",
          "deck": "Array",
          "id": 1.152,
          "type": "method",
          "description": "Array.prototype[Symbol.iterator]() - метод в синтаксисе arr[Symbol.iterator]() - часть протокола итерации, определяющая как синхронно итерировать данный ряд значений. Значение свойства является тем же функциональным объектом, что и значение метода Array.prototype.values(). \nПример с использованием метода с созданием списка:\n<ul id=\"letterResult\">\n</ul>\nconst arr = ['a', 'b', 'c'];\nconst eArr = arr[Symbol.iterator]();\nconst letterResult = document.getElementById('letterResult');\nfor (let letter of eArr) {\n  const li = document.createElement('LI');\n  li.textContent = letter;\n  letterResult.appendChild(li);\n}\nПроверка на итерабельность:\nfunction isIterable(it) {\nif (!(Symbol.iterator in Object.getPrototypeOf(it)\n/* or \"Symbol.iterator in Object.__proto__\"\n    or \"it[Symbol.iterator]\" */)) {\n   console.log(it, ' is not an iterable object...');\n    } else {\n        var iterator = it[Symbol.iterator];\n        return iterator;\n    }\n} \nМетод не поддерживается в IE."
        }
      ]
    },
    {
      "name": "Expressions",
      "classDeck": "deck",
      "id": 3,
      "type": "Expressions",
      "objects": [
        {
          "name": "'use strict'",
          "classDeck": "card",
          "deck": "Expressions",
          "id": 3.1,
          "type": "expression",
          "description": "или \"use strict\", объявление \"строгого\" режима (ES5 и выше). Указывается в самом начале скрипта. Можно указывать в начале функции, над ним могут быть написаны только комментарии. В консоли по умолчанию выключен. Старые консоли директиву не поймут - ее надо обернуть в функцию:\n(function() {\n 'use strict';\n ...\n})()\nКлассы и модули автоматически включают строгий режим, в них директиву можно не указывать."
        },
        {
          "name": "throw",
          "classDeck": "card",
          "deck": "Expressions",
          "id": 3.2,
          "type": "expression",
          "description": "инструкция throw выбрасывает определенное пользователем исключение. Выполнение текущей функции будет остановлено (все инструкции после throw не будут запущены) и контроль перейдет к первому в стеке вызовов блоку catch. Если такого блока среди вызванных функций нет, выполнение кода будет прекращено. Выбрасывать может любое выражение, которое становится значением исключения. \nthrow 'Error2';// generates an exception with a string value\nthrow 42;// generates an exception with the value 42\nthrow true;// generates an exception with the value true\nthrow new Error('Required');// generates an error object with the message of Required\nНо лучше выбрасывать объект ошибки, который можно создавать по собственному конструктору.\nfunction UserException(message) {\n  this.message = message;\n  this.name = 'UserException';\n}\nfunction getMonthName(mo) {\n  mo = mo - 1; // Adjust month number for array index (1 = Jan, 12 = Dec)\n  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',\n    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  if (months[mo] !== undefined) {\n    return months[mo];\n  } else {\n    throw new UserException('InvalidMonthNo');\n  }\n}\ntry {\n  // statements to try\n  var myMonth = 15; // 15 is out of bound to raise the exception\n  var monthName = getMonthName(myMonth);\n} catch (e) {\n  monthName = 'unknown';\n  console.error(e.message, e.name); // pass exception object to err handler\n}\nТакже можно пробрасывать исключение дальше, после того, как вы его отловили. Пробрасываемые исключения всплывают до функции-обертки или до более высокого уровня, где пользователь сможет его увидеть.\ntry {\n  throw n; // throws an exception with a numeric value\n} catch (e) {\n  if (e <= 50) {\n    // statements to handle exceptions 1-50\n  } else {\n    // cannot handle this exception, so rethrow\n    throw e;\n  }\n}"
        },
        {
          "name": "break",
          "classDeck": "card",
          "deck": "Expressions",
          "type": "statement",
          "description": "директива break прерывает цикл или выполнение конструкции switch и передает программный контроль инструкции, следующей за прерванной. В конструкциях switch наличие обязательно в каждом сегменте. В циклах должна находиться внутри цикла или используется с меткой (label), тогда необходимо правильное \"вложение\" (выбросит исключение, например, при использовании внутри функции, помещенной внутрь цикла). Метка должна находиться в начале цикла с двоеточием.\nНеправильное применение:\nblock_1: {\n  console.log('1');\n  ( function() {\n    break block_1; // SyntaxError: Undefined label 'block_1'\n  })();\n}\n\nblock_1: {\n  console.log('1');\n  break block_2; // SyntaxError: label not found\n}\nblock_2: {\n  console.log('2');\n}\n\nПравильное применение (прервет сразу и внешний, и внутренний блок цикла):\nouter_block: {\n  inner_block: {\n    console.log('1');\n    break outer_block; // breaks out of both inner_block and outer_block\n  }\n}\nНельзя применять вместе с тернарным оператором ? (справа от него).",
          "id": 3.21
        },
        {
          "name": "continue",
          "classDeck": "card",
          "deck": "Expressions",
          "type": "statement",
          "description": "При выполнении директивы continue цикл не прерывается, а переходит к следующей итерации (если условие все еще равно true). Позволяет избегать (излишней) вложенности и фигурных скобок. \nfor (let i=0; i<10; i++) {\n    if (i%2==0) continue;\n    alert(i);\n}\nНельзя применять вместе с тернарным оператором ? (справа от него). Применяется также с метками (label), метка должна стоять в начале цикла и иметь двоеточие.",
          "id": 3.22
        },
        {
          "name": "debugger",
          "classDeck": "card",
          "deck": "Expressions",
          "type": "statement",
          "description": "выражение, вызывающее любую доступную функциональность отладки, например такую, как установка брейкпойнта (точки останова). Если никакого подобного функционала нет, выражение не будет иметь эффекта. ",
          "id": 3.23
        }
      ]
    },
    {
      "name": "Function",
      "classDeck": "deck",
      "deck": "Function",
      "type": "Function",
      "description": "функция - это отрывок кода, который может быть вызван другим кодом или самим собой. При вызове аргументы передаются функции как вводные данные и функция может вернуть результат. В JS функция - это объект. Имя функции - идентификатор (набор символов, идентифицирующих функцию, переменную или свойство), являющийся частью объявления функции или ее выражения. Область видимости функции зависит от того, где она объявляется или появляется в виде выражения. Все объявленные внутри функции переменные являются локальными и не видны извне. У функции есть доступ к внешним переменным и она может их изменять. Если локальные перекрывают внешние, они меняются внутри функции, но внешние остаются неизменными. Аргумент, передаваемый внутрь функции, можно изменять внутри функции, но данные внешнего аргумента перезаписаны не будут. \nСуществуют два основных синтаксиса объявления функций: Function Declaration \nfunction foo() {\n ...;\n}\nОбъявляется отдельно, инициализируется движком сразу и ее вызов и выполнение возможно до ее появления в коде, находящаяся внутри блока доступна только внутри него.\nFunction Expression\nlet foo = function() {\n ...;\n};\nСоздается внутри другого выражения или синтаксической конструкции, создается во время своего появления в коде и только после этого может использоваться, можно сделать видимой вне блока, объявив глобальную переменную, а внутри блока присвоив ей функцию.  \nФункции могут быть: \n- анонимными (без имени, только экспрессивная форма, декларативная должна иметь имя);\n(function() {...});\n() => {...};\n- именованными (при объявлении функций);\nfunction foo() {...};\n(function foo() {...});\nlet foo = () => {...};\nПри выборе имени, как правило, берут глагол, точно описывающий действие. Используются префиксы: show – что-то показывается, get – возвращает значение, calc – вычисляется,\ncreate – создается, check – проверяется и возвращается логическое значение.\n- внутренними (внутри другой функции, как two в примере);\nfunction one() {\n function two() {\n  ...;\n }\n};\n- внешними (как one в примере выше);\nрекурсивными (вызывающими сами себя);\nfunction foo(x) {\n if (x < 10) {\n  return; \n }\n foo(x + 1);\n};\n- стрелочными (Arrow functions). Очень удобны для простых однострочных действий.\nlet sum = (a, b) => a + b;\nЕсли аргумент один, скобки можно опустить.\nlet mult = n => n * 2;\nБез аргументов пустые скобки обязательны.\nМожно применять в виде function expression.\nlet age = prompt('Сколько вам лет?', '');\nlet welcome = (age < 18) ?\n            () => alert('Привет!') :\n            () => alert('Здравствуйте!');\nwelcome();\n- Также существует экспрессивный синтаксис функции с немедленным вызовом.\n(function foo() {...}());\n(function foo() {...})();\n(() => {...})();\nВозможно применение параметра по умолчанию: при пропуске аргумента его значением становится undefined, в случае с параметром по умолчанию, будет присвоено дефолтное значение.\nfunction foo(from, text = \"текст не добавлен\") {...};\nРаньше использовали конструкцию text = text || \"текст не добавлен\".\nФункция может (но не обязана) вернуть значение. Принудительный возврат значения в вызвавший код осуществляется директивой return. Return без значения приведет к немедленному выходу из функции, директив со значением (если несколько строк - заключаем его в скобки) может быть несколько. Добавление каких-либо действий (alert() и проч.) крайне нежелательно, функция должна просто возвращать значение. Выполнение нескольких разных действий лучше разбить на несколько разных функций. \n- Функции-коллбэки - функции, передаваемые другой функции в качестве аргументов.\nКаждая функция в JavaScript фактически объект function. Она может рассматриваться как код (function(){}).constructor === Function, который вернет true.",
      "id": 5,
      "objects": [
        {
          "name": "new Function()",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.1,
          "type": "constructor",
          "description": "Конструктор создает новый объект Function. Вызов конструктора напрямую может создавать функции динамически, но они будут небезопасны и с похожей (но не столь очевидной) производительсностью, как у eval(). Тем не менее, в отличие от eval, конструктор Function создает функции, которые будут запускаться в глобальной области видимости. Синтаксис - new Function(arg1, arg2, ..., argN, funcBody), где arg - имена, использующиеся функцией как имена формальных аргументов, каждое из них - строка, отвечающая валидному идентификатору JS, или список таких строк, разделенных запятыми. Например, \"x\", \"theValue\" или \"x, theValue. funcBody - строка с JS-выражением, содержащим определение функции. Объект function, созданный при помощи такого конструктора, парсится еще при создании функции. Это менее эффективно, чем при объявлении функции декларативно или экспрессивно, которые парсятся во время остановки кода. Все передаваемые аргументы расцениваются как имена идентификаторов параметров создаваемой функции, в том порядке, в каком они ей передаются. Если указанный аргумент пропускается, его значением станет undefined. Вызов конструктора Function без оператора new будет иметь тот же эффект, что и вызов конструктора. \nconst adder = new Function('a', 'b', 'return a + b');\nФункции, созданные при помощи конструктора, не создают замыканий в создаваемом контексте, они всегда создаются в глобальной области видимости. При их запуске они доступны только их локальным переменным и глобальным переменным, но не тем, что находятся в той области видимости, где был вызван конструктор."
        },
        {
          "name": "Function.prototype.apply()",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.11,
          "type": "method",
          "description": "метод вызывает функцию с определенным значением this и аргументами, предоставленными в виде массива (или массивоподобного объекта). Синтаксис - \nfunc.apply(thisArg, [argsArray])\nИмейте в виду, что this может не быть актуальным значением, рассматриваемым методом. Если метод применен на функции в нестрогом режиме, null и undefined будут заменены на глобальный объект, а примитивные значения обернуты. Аргумент this обязателен. Параметр argsArray - массивоподобный объект с аргументами, с которыми должна быть вызвана функция, или null или undefined, если аргументы передавать не нужно. Возвращаемое значение метода - результат вызова функции с указанным this и параметрами. Главное отличие от метода call() при их схожести написания - с методом apply() применяется массивоподобный объект с параметрами, а с методом call() - список аргументов. Когда первым аргументом идет undefined или null, похожего результата можно достичь при помощи спред-синтаксиса в массиве (...). Вы можете присваивать уже существующей функции различные объекты this, всегда ссылающиеся на текущий объект (к которому примеяете функцию). \nC методом apply() вы можете написать один метод, а затем наследовать его в других объектах без необходимости переписывать этот метод. В качестве массива аргументов можно применять массив литералов (строк) или даже \"чистый\" массив. Также вместо массива применим объект arguments. В таком случае вы не обязаны знать весь набор аргументов заранее. Применим любой тип массивоподобных абъектов, в т.ч. NodeList. Старые браузеры (Chrome<17, IE<9) не обрабатывают массивоподобные объекты, принимая только массивы. \nПрименить метод можно с методом массива push(), если нужно добавить в существующий массив элементы из другого массива (просто метод push() добавит массив как отдельный элемент внутрь другого, а метод concat() не изменит существующий, а создаст новый массив).\nconst array = ['a', 'b'];\nconst elements = [0, 1, 2];\narray.push.apply(array, elements);\nconsole.info(array); // [\"a\", \"b\", 0, 1, 2] \nДругое мудрое применение - вместе с некоторыми встроенными функциями. Например, для поиска минимальных и максимальных значений в массиве вместо применения циклов.\nconst numbers = [5, 6, 2, 3, 7];\nlet max = Math.max.apply(null, numbers);\nlet min = Math.min.apply(null, numbers);\nЕдинственное - следите за количеством аргументов, при сильном превышении лимита движка возможны проблемы. Тогда используйте гибридный метод.\nfunction minOfArray(arr) {\n  let min = Infinity;\n  let QUANTUM = 32768;\n  for (var i = 0, len = arr.length; i < len; i += QUANTUM) {\n    var submin = Math.min.apply(null,\n                                arr.slice(i, Math.min(i+QUANTUM, len)));\n    min = Math.min(submin, min);\n  }\n  return min;\n}\nlet min = minOfArray([5, 6, 2, 3, 7]);\nЕще одно применение - создание цепочек конструкторов.\nFunction.prototype.construct = function(aArgs) {\n  let oNew = Object.create(this.prototype);\n  this.apply(oNew, aArgs);\n  return oNew;\n};\nfunction MyConstructor() {\n  for (let nProp = 0; nProp < arguments.length; nProp++) {\n    this['property' + nProp] = arguments[nProp];\n  }\n}\nlet myArray = [4, 'Hello world!', false];\nlet myInstance = MyConstructor.construct(myArray);\nconsole.log(myInstance.property1);                // logs 'Hello world!'\nconsole.log(myInstance instanceof MyConstructor); // logs 'true'\nconsole.log(myInstance.constructor);              // logs 'MyConstructor'"
        },
        {
          "name": "Function.prototype.bind()",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.12,
          "type": "method",
          "description": "метод создает новую функцию, которая при вызове имеет в качестве this предоставленное значение с набором аргументов, предшествующих любым другим аргументам, передаваемым функции. Синтаксис - \nlet boundFunc = func.bind(thisArg, arg1, arg2, ..., argN)\nthisArg - значение, передаваемое как this целевой функции при ее \"привязанном\" вызове, оно игнорируется, если привязываемая функция создана при помощи конструктора с оператором new. Когда используется bind() при создании функции (как колбэк-функции) внутри setTimeout, любые примитивные значения, передаваемые в качестве this, конвертируются в объекты. Если никаких аргументов не передается или thisArg равно null или undefined, this текущей области видимости расценивается как rhisArg. arg1... - аргументы, предшествующие любым другим, передаваемым в функцию. Возвращаемое значение метода - копия функции с установленным this и инициализированными аргументами (если они есть). Другими словами - метод bind() создает новую привязанную функцию, являющуюся экзотическим объектом функции, обернутой вокруг оригинального функционального объекта. Вызов привязанной функции в основном является запуском функции-обертки."
        },
        {
          "name": "Function.prototype.call()",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.13,
          "type": "method",
          "description": "метод вызывает функцию с данным значением this и индивидуально предлагаемыми аргументами. Синтаксис - \nfunc.call(thisArg, arg1, arg2, ..., argN)\nВозвращаемое значение - результат вызова функции с указанным this и аргументами. Метод позволяет принадлежащий одному объекту функциональный метод назначить и вызвать на другом объекте. Метод предлагает новое значение this функции или методу. С ним вы можете написать метод один раз и затем наследовать его в других объектах без необходимости вновь его писать. Главное отличие от метода apply() - в методе call() указывается список аргументов, в apply() - массив или массивоподобный объект. "
        },
        {
          "name": "Function.prototype.displayName",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.14,
          "type": "property",
          "description": "нестандартизованное свойство, возвращающее отображаемое имя функции.\nfunction doSomething() {}\nconsole.log(doSomething.displayName); // \"undefined\"\nvar popup = function(content) { console.log(content); };\npopup.displayName = 'Show Popup';\nconsole.log(popup.displayName); // \"Show Popup\""
        },
        {
          "name": "Function.prototype.length",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.15,
          "type": "property",
          "description": "свойство, показывающее количество ожидаемых функцией параметров. Свойство неперезаписываемое, неперечисляемое, изменяемое. Это длина объекта функции. Учитывает только параметры до первого, указанного со значением по умолчанию и не учитываем параметр \"остальное\" (rest parameter, ...). В противовес ему, arguments.length считается отдельно для функции и предоставляет количество всех актуальных аргументов, переданных функции. Длина конструктора функции всегда равна 1. Свойство length у прототипа Function равно 0."
        },
        {
          "name": "Function.prototype.name",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.16,
          "type": "property",
          "description": "свойство только для чтения, демонстрирующее установленное при ее создании имя функции, значением также может быть anonymous (для анонимных функций или созданных конструктором) или '' (пустая строка, для анонимных экспрессивных и стрелочных функций). Свойство неперезаписываемое, неперечисляемое, но изменяемое (до ES6 было неизменяемым). Будьте осторожны при использовании этого свойства и изменении сырого кода, выполняемого минификаторами и обфускаторами JS. Одна из задач этих инструментов - уменьшить размер кода перед деплоингом, такие трансформации часто меняют названия функций. Разархивированный код запускается в первоначальном виде, но поведение метода декомпрессии не всегда одинаково, поэтому, если задействуете свойство Function.name, убедитесь, что процесс сборки не изменит имя или не давате функциям конкретных имен. Начиная с ECMA2015, именами могут быть именя переменных и методов, у методов в т.ч. в короткой форме их обозначения. \nlet f = function() {};\nlet object = {\n  someMethod: function() {}\n};\nconsole.log(f.name); // \"f\"\nconsole.log(object.someMethod.name); // \"someMethod\"\nvar o = {\n  foo(){}\n};\no.foo.name; // \"foo\";\nИмена методов обычным присваиванием не изменить, только через Object.defineProperty(). У \"привязанных\" методом bind функций перед именем будет приставка bound, у методов-геттеров и сеттеров - приставки get/set. У созданных через конструктор класса имя будет именем класса, но только если в конструкторе не будет статического метода name (static name()). На безупречную работу с именами классов у этого свойства лучше не полагаться. Если в качестве имени метода применен символ, значением свойства будет описание символа в скобках (если оно задавалось).\nlet sym1 = Symbol(\"foo\");\nlet sym2 = Symbol();\nlet o = {\n  [sym1]: function(){},\n  [sym2]: function(){}\n};\no[sym1].name; // \"[foo]\"\no[sym2].name; // \"\""
        },
        {
          "name": "Function.prototype.toString()",
          "classDeck": "card",
          "deck": "Function",
          "id": 5.17,
          "type": "method",
          "description": "метод возвращает строку, представляющую исходный код функции. Синтаксис - \nfunc.toString()\nМетод перезаписывает унаследованный от Object. Для объектов Function, определенных пользователем, метод возвращает строку с текстовым сегментом, использованным для определения функции. JavaScript вызывает метод toString() автоматически, когда функция представляется как текстовое значение, например, при конкатенации со строкой. Метод выбросит исключение TypeError, если значением this не будет являться объект function. Возможен \"короткий\" вызов с конкатенацией с пустой строкой.\nfunction foo() { return 'bar' }\nconsole.log(foo + ''); // \"function foo() { return 'bar' }\""
        }
      ]
    },
    {
      "name": "Operators",
      "classDeck": "deck",
      "type": "operators",
      "id": 2,
      "objects": [
        {
          "name": "!",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.1,
          "type": "operator",
          "description": "логический оператор НЕ. Приводит операнд к логическому типу и возвращает противоположное логическое значение. \nalert(!true);//false"
        },
        {
          "name": "!!",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.2,
          "type": "operator",
          "description": "Двойной оператор !! принудительно приводит значение к логике (как Boolean()). Самый высокий приоритет из всех логических операторов."
        },
        {
          "name": "!=",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.3,
          "type": "operator",
          "description": "оператор неравенства"
        },
        {
          "name": "!==",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.4,
          "type": "operator",
          "description": "оператор строгого неравенства"
        },
        {
          "name": "%",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.5,
          "type": "operator",
          "description": "оператор modulo, оператор взятия остатка\nlet n = 20 % 4;// 0"
        },
        {
          "name": "&&",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.6,
          "type": "operator",
          "description": "логический оператор И. В традиционном программировании возвращает true только если оба операнда true:\nalert(true && false);//false\nalert(false && true);//false\nalert(false && false);//false\nalert(true && true);// true\nВ JS перебирает операнды слева направо, конвертирует их в логику, если результат false, останавливается и возвращает его исходное значение, если все результаты true, возвращает исходное значение последнего операнда. В итоге, возвращается первое ложное значение или последнее (если ничего не найдено).\nМожет заменять if:\nlet x=1;\n(x>0) && alert('первый операнд true, поэтому ты видишь эту надпись');"
        },
        {
          "name": "&&=",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.7,
          "type": "operator",
          "description": "если операнд а имеет истинное значение, то присвоить ему значение операнда b:\na = 1;\nb = 2;\na &&= b;\nconsole.log(a);// 2"
        },
        {
          "name": "**",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.8,
          "type": "operator",
          "description": "оператор возведения в степень и извлечения корня, целые значения - степень, нецелые - корень\nlet n = 2 ** 3;// 8\nlet n = 4 ** (1/2);// 2, квадратный корень\nlet n = 9 ** (1/3);// 3, кубический корень"
        },
        {
          "name": "+",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.9,
          "type": "operator",
          "description": "унарный плюс. Суммирует числа. Приводит нечисловые данные к числу. Иначе - осуществляет конкатенацию строк. Если первое значение число, второе строка - сконкатенирует их. Если несколько первых значений - числа, потом идет строка - сложит числа и сконкатенирует результат со строкой. В любом случае, если хотя бы один операнд строка, результатом будет строка."
        },
        {
          "name": "++",
          "classDeck": "card",
          "deck": "operators",
          "id": 2.11,
          "type": "operator",
          "description": "инкремент. Префиксная форма возвращает увеличенное значение на 1. Постфиксная возвращает старое значение. Работает только с переменными.\nlet i=0;\nwhile(++i<5) alert(i);// 1, 2, 3, 4\nно\nwhile(i++<5) alert(i);// 1, 2, 3, 4, 5. "
        },
        {
          "name": ",",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "оператор coma (запятая), позволяет вычислять несколько выражений, но возвращает результат только последнего. Очень низкий приоритет, даже ниже присваивания.\nlet a = (3 + 2, 4 + 4);\nalert(a);// 8\nно\nlet a = 3 + 2, 4 + 4;\nalert(a);// 5",
          "id": 2.12
        },
        {
          "name": "--",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "декремент. Префиксная форма возвращает уменьшенное значение на 1. Постфиксная возвращает старое значение. Работает только с переменными",
          "id": 2.13
        },
        {
          "name": "... (spread operator)",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "spread-оператор, оператор расширения. Spread-синтаксис позволяет \"разложить\" итерабельный объект, такой как массив или строка, там, где предусматриваются 0 или более аргументов (для вызова функции), предполагаются элементы (у литеральных массивов), или экспрессивно объявленный объект распаковывается на месте там, где ожидается 0 или более пар \"ключ/значение\" (у объектных литералов). \nfunction sum(x, y, z) {\n  return x + y + z;\n}\nconst numbers = [1, 2, 3];\nconsole.log(sum(...numbers));// 6\nБез spread-оператора понадобилась бы конструкция с Function.prototype.apply():\nfunction.apply(null, numbers);\nЕсли функции передается массив с числом элементов больше, чем требуемых аргументов, будет взято столько элементов (от начала массива), сколько нужно аргументов, остальные будут проигнорированы.\nfunction sum(x, y, z) {\n  return x + y + z;\n}\nconst numbers = [1, 2, 3, 4, 5];\nconsole.log(sum(...numbers));// 6\nВ этом случае общий синтаксис - \nfunction(...iterableObj)\nУказывать оператор в передаваемых параметрах можно несколько раз:\nmyFunction(-1, ...args, 2, ...[3]);\nВторое важное применение - с оператором new, с которым невозможно прямое применение массива и .apply(). \nlet dateFields = [1970, 0, 1];  // 1 Jan 1970\nlet d = new Date(...dateFields);\nДругой синтаксис - \n[iterableObj, value1, value2...] \nпозволяет \"обновлять\" массив новыми значениями, они будут добавлены в конец существующего массива. И не надо использовать всевозможные .push(), .splice(), .concat()...\nlet numberStore = [0, 1, 2];\nlet newNumber = 12;\nnumberStore = [...numberStore, newNumber];\nКроме того, можно обеспечить порядок нахождения элементов в новом массиве (сначала из одного массива, потом из другого) - просто меняя местами аргументы со spread-операторами: \nlet arr1 = [0, 1, 2];\nlet arr2 = [3, 4, 5];\narr1 = [...arr1, ...arr2];// [0, 1, 2, 3, 4, 5]\narr1 = [...arr2, ...arr1];// [3, 4, 5, 0, 1, 2]\nВозможно простое создание копии массива:\nlet arr = [1, 2, 3];\nlet arr2 = [...arr]; // like arr.slice()\narr2.push(4);//  arr2 becomes [1, 2, 3, 4]\nНо это хорошо работает только с одномерными массивами, нельзя применять на многомерных, т.к. изменения в копии повлекут за собой изменения в изначальном массиве (такая же проблема с spread-синтаксисом в Object.assign()):\nlet a = [[1], [2], [3]];\nlet b = [...a];\nb.shift();//  \nconsole.table(b);// [[2], [3]]\nconsole.table(a);// [[1], [2], [3]]\na = [[1], [2], [3]];\nb.shift().shift();\nconsole.table(b);// [[2], [3]]\nconsole.table(a);//[[], [2], [3]]\nСинтаксис для объектных литералов - \nlet objClone = {...obj}\nКопируются собственные перечисляемые свойства в новый объект:\nlet obj1 = { foo: 'bar', x: 42 };\nlet obj2 = { foo: 'baz', y: 13 };\nlet clonedObj = { ...obj1 };// Object { foo: \"bar\", x: 42 }\nlet mergedObj = { ...obj1, ...obj2 };// Object { foo: \"baz\", x: 42, y: 13 }\nСинтаксис не поддерживается в IE.\nSpread-синтаксис в параметрах функций похож на rest-синтаксис (...), но как раз его полная противоположность. Spread-оператор \"раскладывает\" массив по элементам, в то время как rest-оператор собирает множественные значения в один элемент.",
          "id": 2.14
        },
        {
          "name": "... (rest parameter)",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "синтаксис с rest-параметром (в функциях) позволяет функции принимать неустановленное количество аргументов как массив, это один из способов представления многоарной функции. \nfunction sum(...theArgs) {\n  return theArgs.reduce((previous, current) => {\n    return previous + current;\n  });\n}\nconsole.log(sum(1, 2, 3));// 6\nconsole.log(sum(1, 2, 3, 4));// 10\nСинтаксис - \nfunction f(a, b, ...theArgs) {...}\nRest-параметр всегда только один и должен идти последним. \nДаже если на месте rest-параметра окажется один аргумент, он станет единственным элементом передаваемого внутрь функции массива. Если аргументов совсем не будет - будет передан пустой массив. У массива, конечно, есть длина и соответствующее свойство:\nfunction fun1(...theArgs) {\n  console.log(theArgs.length)\n}\nfun1();// 0\nfun1(5);// 1\nfun1(5, 6, 7);// 3\nТри главных отличия параметра rest от arguments:\n1. Arguments - не настоящий массив, в то время как rest - экземпляр Array, а значит все методы массивов - sort(), map(), forEach(), pop() - могут применяться непосредственно к нему. А arguments сначала надо преобразовать в \"нормальный\" массив.\n2. Объект arguments обладает дополнительной функциональностью, свойственной только ему (например, свойство callee)\n3. ...restParam собирает все дополнительные параметры в один массив, вследствие чего этот массив не будет содержать именованный аргумент, стоящий перед rest-параметром. А вот объект arguments как раз содержит все параметры функции - включая те, что не попадают в rest.\nНет поддержки в IE.",
          "id": 2.15
        },
        {
          "name": "; (empty statement)",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "empty statement. В отличие от \"обычной\" точки с запятой, отделяющей инструкции, означает \"пустое предписание\". Применяется в \"пустых циклах\". Следует указывать назначение в комментариях.\nlet arr = [1, 2, 3];\n// Assign all array values to 0\nfor (let i = 0; i < arr.length; arr[i++] = 0) /* empty statement */ ;\nconsole.log(arr);// [0, 0, 0]",
          "id": 2.16
        },
        {
          "name": "==",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "оператор сравнения. В JS при таком сравнении данные приводятся к числу. При таком сравнении null == undefined и ничему больше, при строгом сравнении они не равны",
          "id": 2.17
        },
        {
          "name": "===",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "оператор строгого сравнения, данные разных типов к одному типу не приводятся.",
          "id": 2.18
        },
        {
          "name": "===",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "оператор строгого сравнения, данные разных типов к одному типу не приводятся.",
          "id": 2.19
        },
        {
          "name": "?",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "условный (тернарный) оператор для создания переменной в зависимости от условий. Конструкции: \nlet result = condition_1 ? statement_1 : statement_2: если условие равно true - выполнится инструкция_1, если false - инструкция_2.\nlet result = (cond_1) ? statement_1 :\n                  (cond_2) ? statement_2 :\n                  ... :\n                  statement_x;\nПроверяются сразу несколько вариантов условий.\n\"Нетрадиционное\" применение ? - вместо if. \n(variable = cond_1) ? statement_1 : statement_2;",
          "id": 2.2
        },
        {
          "name": "?.",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "условный (тернарный) оператор для создания переменной в зависимости от условий. Конструкции: \nlet result = condition_1 ? statement_1 : statement_2: если условие равно true - выполнится инструкция_1, если false - инструкция_2.\nlet result = (cond_1) ? statement_1 :\n                  (cond_2) ? statement_2 :\n                  ... :\n                  statement_x;\nПроверяются сразу несколько вариантов условий.\n\"Нетрадиционное\" применение ? - вместо if. \n(variable = cond_1) ? statement_1 : statement_2;",
          "id": 2.21
        },
        {
          "name": "??",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "оператор сравнения с нулем (nullish coalescing operator) - логический оператор, возвращающий его правый операнд, когда его левый операнд - null или undefined, иначе - возвращает левый операнд. В этом его отличие от логического оператора OR (||), который возвращает правый операнд, если левый - любое false-значение (не только null или undefined). Другими словами, если вы используете || для создания неких дефолтных значений для некой переменной foo, вы можете столкнуться с непредсказуемым поведением при появлении некоторых значений (например, пустой строки \"\" или 0). \nПример с сокращенным вычислением:\nfunction A() { console.log('A was called'); return undefined;}\nfunction B() { console.log('B was called'); return false;}\nfunction C() { console.log('C was called'); return \"foo\";}\nconsole.log( A() ?? C() );\n// logs \"A was called\" then \"C was called\" and then \"foo\"\n// as A() returned undefined so both expressions are evaluated\nconsole.log( B() ?? C() );\n// logs \"B was called\" then \"false\"\n// as B() returned false (and not null or undefined), the right\n// hand side expression was not evaluated\nНевозможно прямое использование вместе с логическими операторами AND, OR, будет выброшено исключение. А вот с оператором опциональной последовательности (?.) - запросто:\nlet foo = { someFooProp: \"hi\" };\nconsole.log(foo.someFooProp?.toUpperCase() ?? \"not available\"); // \"HI\"\nconsole.log(foo.someBarProp?.toUpperCase() ?? \"not available\"); // \"not available\"",
          "id": 2.22
        },
        {
          "name": "??=",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "Если операнд равен undefined или null, то присвоить ему некое значение\nlet a;\na ??= 1;\nconsole.log(a);// 1",
          "id": 2.23
        },
        {
          "name": "const",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "оператор объявления и (обязательно) инициализации константы. Имеет блочную область видимости. Имена констант не могут совпадать с именами функций или переменных той же области видимости. При применении в качестве псевдонимов (для запоминания кодов цветов, например), имена констант обычно пишутся ЗАГЛАВНЫМИ буквами. \nconst COLOR_WHITE = \"#fff\";\nlet color = COLOR_WHITE;\nconsole.log(color);// #fff",
          "id": 2.24
        },
        {
          "name": "delete",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "оператор удаляет свойство из объекта; если на это же свойство больше нети никаких ссылок, оно будет удалено окончательно автоматически. Синтаксис - \ndelete object.property\nили\ndelete object['property']\nВозвратит true во всех случаях, кроме тех, когда свойство - собственное неизменяемое (non-configurable), тогда в нестрогом режиме вернется false, в строгом - будет выброшено исключение TypeError. Также вернет true в случае отсутстия указанного свойства. Если у объекта удаляется свойство, а в цепочке прототипов есть свойство с таким же именем, объект станет использовать его (т.е. delete повлияет только на собственное свойство объекта). Любые свойства, объявленные при помощи var, не могут быть удалены из глобальной области видимости или области видимости функции, из чего следует, что delete не может удалить функцию в глобальной области (где присутствует часть определения функции или экспрессивное ее объявление), а функции, являющиеся частью объекта (отделенного от глобальной области видимости) могут быть удалены. Любые свойства, объявленные при помощи let или const, не могут быть удалены из той области видимости, где они были объявлены. Не могут удаляться неизменяемые (non-configurable) свойства - сюда входят свойства встроенных объектов Math, Array, Object и свойства, созданные неизменяемыми, например, при помощи метода Object.defineProperty(). ",
          "id": 2.25
        },
        {
          "name": "if",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "if - условный оператор, образует конструкцию if (condition) {statement), выполняющую код statement, если условие равно true, или if (condition_1) {statement_1} else {statement_2} или if (condition_1) {statement_1}; if (condition_2) {statement_2} ... else {statement}. Преобразует условие к логическому типу. Блок else выполняется, если условие равно false. ",
          "id": 2.26
        },
        {
          "name": "in",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "реляционный (логический) оператор in в конструкции key in object возвращает true или false в зависимости от того, содержится ли свойство key (строка, символ или индекс) в объекте object или в цепочке его прототипов. Объектом может быть массив, объект, даже объект String (строка-литерал, не объект) или существующий объект Math. Для удаленного свойства выдаст false, для свойства со значением undefined - true. Не путать этот оператор с оператором in в конструкции for (... in ...)",
          "id": 2.27
        },
        {
          "name": "let",
          "classDeck": "card",
          "deck": "Operators",
          "type": "operator",
          "description": "директива, объявляющая локальную переменную с блочной областью видимости. Позволяет объявлять переменные, ограниченные областью видимости блока инструкций или выражения, в отличие от ключевого слова var, объявляющего переменную глобально (или локально в целой функции вне зависимости от блока видимости). Другое отличие - переменная, объявленная с let, инициализируется только когда парсер начнет ее обрабатывать. Как и const, let не создает свойств у объекта window при объявлении глобально (в наивысшей области видимости). \nvar x = 'global_x';\nlet y = 'global_y';\nconsole.log(this.x); // 'global_x'\nconsole.log(this.y); // undefined\nВо многих случаях следует избегать объявления в этой области видимости переменных с let (это может влиять на читаемость кода).",
          "id": 2.28
        }
      ]
    },
    {
      "name": "Proxy",
      "classDeck": "deck",
      "deck": "build-in object",
      "id": 4,
      "type": "Proxy",
      "description": "объект Proxy позволяет создавать прокси - объект-посредник - для другого объекта, который может перехватывать и переопределять основные операции с этим объектом. Создается с двумя параметрами: target - целевой объект, который нужно проксировать, и handler - объект (ловушка), определяющий, какие операции необходимо перехватывать и как их переопределять. Пустой объект укажет поведение, как с целевым объектом:\nconst target = {\n  message1: \"hello\",\n  message2: \"everyone\"\n};\nconst handler1 = {};\nconst proxy1 = new Proxy(target, handler1);\nconsole.log(proxy1.message1); // hello\nconsole.log(proxy1.message2); // everyone\nЗадаем правила поведения для всех подобных операций - например, при получении свойства:\nconst handler2 = {\n  get: function(target, prop, receiver) {\n    return \"world\";\n  }\n};\nconst proxy2 = new Proxy(target, handler2);\nconsole.log(proxy2.message1); // world\nconsole.log(proxy2.message2); // world\nДля обеспечения \"изначального\" поведения у одних свойств и другого, измененного, у других - используем в связке с Reflect (в примере выше функция переопределения запроса по-сути являлась reflect-функцией):\nconst target = {\n  message1: \"hello\",\n  message2: \"everyone\"\n};\nconst handler1 = {};\nconst proxy1 = new Proxy(target, handler1);\nconsole.log(proxy1.message1); // hello\nconsole.log(proxy1.message2); // everyone\nconst target = {\n  message1: \"hello\",\n  message2: \"everyone\"\n};\nconst handler3 = {\n  get: function (target, prop, receiver) {\n    if (prop === \"message2\") {\n      return \"world\";\n    }\n    return Reflect.get(...arguments);\n  },\n};\nconst proxy3 = new Proxy(target, handler3);\nconsole.log(proxy3.message1); // hello\nconsole.log(proxy3.message2); // world\nНет поддержки в IE.\n\nПрокси могут помочь в предварительной проверке передаваемых объекту свойств:\nlet validator = {\n  set: function(obj, prop, value) {\n    if (prop === 'age') {\n      if (!Number.isInteger(value)) {\n        throw new TypeError('The age is not an integer');\n      }\n      if (value > 200) {\n        throw new RangeError('The age seems invalid');\n      }\n    }\n    obj[prop] = value; // The default behavior to store the value\n    return true; // Indicate success\n  }\n};\nconst person = new Proxy({}, validator);\nperson.age = 100;\nconsole.log(person.age); // 100\nperson.age = 'young';    // Throws an exception\nperson.age = 300;        // Throws an exception\nМожно легко расширять конструкторы другими конструкторами:\nfunction extend(sup, base) {\n  var descriptor = Object.getOwnPropertyDescriptor(\n    base.prototype, 'constructor'\n  );\n  base.prototype = Object.create(sup.prototype);\n  var handler = {\n    construct: function(target, args) {\n      var obj = Object.create(base.prototype);\n      this.apply(target, obj, args);\n      return obj;\n    },\n    apply: function(target, that, args) {\n      sup.apply(that, args);\n      base.apply(that, args);\n    }\n  };\n  var proxy = new Proxy(base, handler);\n  descriptor.value = proxy;\n  Object.defineProperty(base.prototype, 'constructor', descriptor);\n  return proxy;\n}\nvar Person = function(name) {\n  this.name = name;\n};\nvar Boy = extend(Person, function(name, age) {\n  this.age = age;\n});\nBoy.prototype.gender = 'M';\nvar Peter = new Boy('Peter', 13);\nconsole.log(Peter.gender);  // \"M\"\nconsole.log(Peter.name);    // \"Peter\"\nconsole.log(Peter.age);     // 13\nПереключаем значения атрибутов или меняем классы в DOM:\nlet view = new Proxy({\n  selected: null\n},\n{\n  set: function(obj, prop, newval) {\n    let oldval = obj[prop];\n    if (prop === 'selected') {\n      if (oldval) {\n        oldval.setAttribute('aria-selected', 'false');\n      }\n      if (newval) {\n        newval.setAttribute('aria-selected', 'true');\n      }\n    }\n    // The default behavior to store the value\n    obj[prop] = newval;\n    // Indicate success\n    return true;\n  }\n});\nlet i1 = view.selected = document.getElementById('item-1');  //giving error here, i1 is null\nconsole.log(i1.getAttribute('aria-selected'));//  'true'\nlet i2 = view.selected = document.getElementById('item-2');\nconsole.log(i1.getAttribute('aria-selected'));//  'false'\nconsole.log(i2.getAttribute('aria-selected'));//  'true'\nКорректировка значений и дополнительные свойства:\nlet products = new Proxy({\n  browsers: ['Internet Explorer', 'Netscape']\n},\n{\n  get: function(obj, prop) {\n    // An extra property\n    if (prop === 'latestBrowser') {\n      return obj.browsers[obj.browsers.length - 1];\n    }\n    // The default behavior to return the value\n    return obj[prop];\n  },\n  set: function(obj, prop, value) {\n    // An extra property\n    if (prop === 'latestBrowser') {\n      obj.browsers.push(value);\n      return true;\n    }\n    // Convert the value if it is not an array\n    if (typeof value === 'string') {\n      value = [value];\n    }\n    // The default behavior to store the value\n    obj[prop] = value;\n    // Indicate success\n    return true;\n  }\n});\nconsole.log(products.browsers);//  ['Internet Explorer', 'Netscape']\nproducts.browsers = 'Firefox';//  pass a string (by mistake)\nconsole.log(products.browsers);//  ['Firefox'] <- no problem, the value is an array\nproducts.latestBrowser = 'Chrome';\nconsole.log(products.browsers);//  ['Firefox', 'Chrome']\nconsole.log(products.latestBrowser);//  'Chrome'\nСоздание механизма поиска объекта в массиве объектов по определенным свойствам объекта:\nlet products = new Proxy([\n  { name: 'Firefox', type: 'browser' },\n  { name: 'SeaMonkey', type: 'browser' },\n  { name: 'Thunderbird', type: 'mailer' }\n],\n{\n  get: function(obj, prop) {\n    // The default behavior to return the value; prop is usually an integer\n    if (prop in obj) {\n      return obj[prop];\n    }\n    // Get the number of products; an alias of products.length\n    if (prop === 'number') {\n      return obj.length;\n    }\n    let result, types = {};\n    for (let product of obj) {\n      if (product.name === prop) {\n        result = product;\n      }\n      if (types[product.type]) {\n        types[product.type].push(product);\n      } else {\n        types[product.type] = [product];\n      }\n    }\n    // Get a product by name\n    if (result) {\n      return result;\n    }\n    // Get products by type\n    if (prop in types) {\n      return types[prop];\n    }\n    // Get product types\n    if (prop === 'types') {\n      return Object.keys(types);\n    }\n    return undefined;\n  }\n});\nconsole.log(products[0]);          // { name: 'Firefox', type: 'browser' }\nconsole.log(products['Firefox']);  // { name: 'Firefox', type: 'browser' }\nconsole.log(products['Chrome']);   // undefined\nconsole.log(products.browser);     // [{ name: 'Firefox', type: 'browser' }, { name: 'SeaMonkey', type: 'browser' }]\nconsole.log(products.types);       // ['browser', 'mailer']\nconsole.log(products.number);      // 3",
      "objects": [
        {
          "name": "Proxy()",
          "classDeck": "card",
          "deck": "Proxy",
          "type": "constructor",
          "description": "Proxy() - конструктор в синтаксисе var proxy = new Proxy(target. handler) создает объекты Proxy. target - целевой объект для заворачивания в прокси, это может быть объект любого рода, включая массив, функцию или даже другой прокси. handler - объект, чьи свойства и функции определяют поведение прокси при проведении операций с ним. Оба аргумента обязательны. \nФункции-обработчики - перечень всех возможных ловушек: handler.apply(), handler.construct(), handler.defineProperty(), handler.deleteProperty(), handler.get(), handler.getOwnPropertyDescriptor(), handler.getPrototypeOf(), handler.has(), handler.isExtensible(), handler.ownKeys(), handler.preventExtentions(), handler.set(), handler.setPrototypeOf()",
          "id": 4.1
        },
        {
          "name": "handler.apply()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.2,
          "type": "Proxy handler",
          "description": "ловушка для перехвата вызова функции - proxy(...args), Function.prototype.call(), Function.prototype.apply(), Reflect.apply(). Синтаксис - \nconst p = new Proxy(target, {\n  apply: function(target, thisArg, argumentsList) {\n  }\n});\nМетоду передаются следующие параметры, this привязывается к обработчику. target - целевой объект, thisArg - аргумент this для вызова, argumentsList - список аргументов.\nМожет возвращать любое значение. Инварианты: target должен быть вызываемым объектом - т.е. это должна быть функция. \nfunction sum(a, b) {\n  return a + b;\n}\nconst handler = {\n  apply: function(target, thisArg, argumentsList) {\n    console.log(`Calculate sum: ${argumentsList}`);\n    // expected output: \"Calculate sum: 1,2\"\n    return target(argumentsList[0], argumentsList[1]) * 10;\n  }\n};\nconst proxy1 = new Proxy(sum, handler);\nconsole.log(sum(1, 2));\n// expected output: 3\nconsole.log(proxy1(1, 2));\n// expected output: 30"
        },
        {
          "name": "handler.construct()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.3,
          "type": "Proxy handler",
          "description": "ловушка для перехвата оператора new. Для того, чтобы новая операция была работоспособной на итоговом объекте Proxy, целевой объект, иницииализирующий прокси, должен иметь внутренний метод [[Construct]] (т.е. должен срабатывать new target). Синтаксис - \nconst p = new Proxy(target, {\n  construct: function(target, argumentsList, newTarget) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, argumentsList - список аргументов для передачи конструктору, newTarget - для кого вызывается оригинальный constructor. Метод должен возвращать объект. Перехватывает операции: new myFunction(...args), Reflect.construct(). Инварианты: будет выброшено TypeError, если метод возвратит не объект. \nconst p = new Proxy(function() {}, {\n  construct: function(target, argumentsList, newTarget) {\n    console.log('called: ' + argumentsList.join(', '));\n    return { value: argumentsList[0] * 10 };\n  }\n});\nconsole.log(new p(1).value); // \"called: 1\"\n                             // 10"
        },
        {
          "name": "handler.defineProperty()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.4,
          "type": "Proxy handler",
          "description": "метод-ловушка для Object.defineProperty() и Reflect.defineProperty(). Синтаксис - \nconst p = new Proxy(target, {\n  defineProperty: function(target, property, descriptor) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя или Symbol свойства, чьи дескрипторы извлекаются, descriptor - дескриптор свойства, устанавливаемый или подвергающийся изменению. Метод возвращает булево значение, демонстрирующее, было ли успешно установлено или изменено свойство. Инварианты (будет выброшеноTypeError): свойство не может быть добавлено, если целевой объект не расширяемый; свойство не может быть добавлено как или изменено на неконфигурируемое, если оно не существует как неконфигурируемое собственное свойство целевого объекта; свойство не может быть неконфигурируемым, если у объекта есть  соответствующее конфигурируемое свойство; если свойство имеет соответствующее целевое свойство, то исключение не будет выброшено; в строгом режиме возвращаемое обработчиком значение false выбросит исключение TypeError. \nconst p = new Proxy({}, {\n  defineProperty: function(target, prop, descriptor) {\n    console.log('called: ' + prop);\n    return true;\n  }\n});\nconst desc = { configurable: true, enumerable: true, value: 10 };\nObject.defineProperty(p, 'a', desc); // \"called: a\"\nПри вызове Object.defineProperty() или Reflect.defineProperty() передаваемый ловушке descriptor имеет некоторые ограничения - будут переданы только поля со стандартными свойствами (enumerable, configurable, writable, value, set, get) нестандартные будут проигнорированы.\nconst p = new Proxy({}, {\n  defineProperty(target, prop, descriptor) {\n    console.log(descriptor);\n    return Reflect.defineProperty(target, prop, descriptor);\n  }\n});\nObject.defineProperty(p, 'name', {\n  value: 'proxy',\n  type: 'custom'\n});  // { value: 'proxy' }"
        },
        {
          "name": "handler.deleteProperty()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.5,
          "type": "Proxy handler",
          "description": "метод-ловушка для оператора delete. Перехватывает delete proxy[foo], delete proxy.foo и Reflect.deleteProperty(). Синтаксис - \nconst p = new Proxy(target, {\n  deleteProperty: function(target, property) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя или Symbol свойства. Возвращает булево значение - удачно ли было удалено указанное свойство. Инварианты (будет выброшено исключение): свойство не может быть удалено, если оно существует как собственное неконфигурируемое своство целевого объекта. \nconst p = new Proxy({}, {\n  deleteProperty: function(target, prop) {\n    if (prop in target){\n      delete target[prop]\n      console.log('property removed: ' + prop)\n      return true\n    }\n    else {\n      console.log('property not found: ' + prop)\n      return false\n    }\n  }\n});"
        },
        {
          "name": "handler.get()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.6,
          "type": "Proxy handler",
          "description": "метод-ловушка получения значения свойства. Перехватывает proxy[foo], proxy.foo, Object.create(proxy)[foo], Reflect.get(). Синтаксис - \nconst p = new Proxy(target, {\n  get: function(target, property, receiver) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя или Symbol свойства, receiver - прокси или объект, наследующий от прокси. Метод может вернуть любое значение. Инварианты (будет выброшено исключение): значение, объявляемое у свойства, должно быть таким же, что и у соответствующего свойства целевого объекта, если это неперезаписываемое, неконфигурируемое собственное свойство данных; значение, объявляемое у свойства, должно быть undefined, если соответствующее свойство целевого объекта - неконфигурируемое собственное свойство доступа и имеет значение undefined, как и его атрибут [[Get]]. \nconst p = new Proxy({}, {\n  get: function(target, property, receiver) {\n    console.log('called: ' + property);\n    return 10;\n  }\n});\nconsole.log(p.a); // \"called: a\"\n                  // 10"
        },
        {
          "name": "handler.getOwnPropertyDescriptor()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.7,
          "type": "Proxy handler",
          "description": "метод-ловушка для Object.getOwnPropertyDescriptor() и Reflect.getOwnPropertyDescriptor(). Синтаксис - \nconst p = new Proxy(target, {\n  getOwnPropertyDescriptor: function(target, property) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя свойства, чей дескриптор нужно получить. Метод возвращает объект (дескриптор свойства) или undefined. Инварианты (будет выброшено TypeError): метод обязан возвращать только объект или undefined; свойство не может быть объявлено несуществующим, если оно существует как неконфигурируемое собственное свойство целевого объекта; свойство не может быть объявлено несуществующим, если оно существует как собственное свойство целевого объекта и сам целевой объект нерасширяемый; свойство не может быть объявлено существующим, если оно не существует в виде собственного свойства целевого объекта и объект нерасширяемый; свойство не может объявляться как неконфигурируемое, если оно не существует как собственное свойство целевого объекта или существует как конфигурируемое собственное свойство; результат метода Object.getOwnPropertyDescriptor(target) может применяться к целевому объекту посредством Object.defineProperty() и это не вызовет ошибку. \nconst p = new Proxy({ a: 20}, {\n  getOwnPropertyDescriptor: function(target, prop) {\n    console.log('called: ' + prop);\n    return { configurable: true, enumerable: true, value: 10 };\n  }\n});"
        },
        {
          "name": "handler.getPrototypeOf()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.8,
          "type": "Proxy handler",
          "description": "метод-ловушка для внутреннего метода [[GetPrototypeOf]]. Перехватит Object.getPrototypeOf(), Reflect.getPrototypeOf(), __proto__, Object.prototype.isPrototypeOf(), instanceof. Синтаксис - \nconst p = new Proxy(target, {\n  getPrototypeOf: function(target) {\n  }\n});\nИнварианты (будет выброшено исключение): метод должен возвращать объект или null; если целевой объект нерасширяем, метод Object.getPrototypeOf(proxy) должен вернуть то же значение, что и метод Object.getPrototypeOf(target). \nconst obj = {};\nconst p = new Proxy(obj, {\n    getPrototypeOf(target) {\n        return Array.prototype;\n    }\n});\nconsole.log(\n    Object.getPrototypeOf(p) === Array.prototype,  // true\n    Reflect.getPrototypeOf(p) === Array.prototype, // true\n    p.__proto__ === Array.prototype,               // true\n    Array.prototype.isPrototypeOf(p),              // true\n    p instanceof Array                             // true\n);"
        },
        {
          "name": "handler.has()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.9,
          "type": "Proxy handler",
          "description": "метод-ловушка для оператора in. Перехватывает запрос foo in proxy, foo in Object.create(proxy), оператор with (проверка with(proxy) { (foo); }), Reflect.has(). Синтаксис - \nconst p = new Proxy(target, {\n  has: function(target, property) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя или Symbol свойства, чье существование проверяется. Инварианты (будет выброшено исключение): свойство не может быть объявлено несуществующим, если оно существует как неконфигурируемое собственное свойство целевого объекта; свойство не может быть объявлено несуществующим, если оно существует как собственное свойство нерасширяемого объекта.\nconst p = new Proxy({}, {\n  has: function(target, prop) {\n    console.log('called: ' + prop);\n    return true;\n  }\n});\nconsole.log('a' in p); // \"called: a\"\n                       // true"
        },
        {
          "name": "handler.isExtensible()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.91,
          "type": "Proxy handler",
          "description": "метод-ловушка для Object.isExtensible() и Reflect.isExtensible(). Синтаксис - \nconst p = new Proxy(target, {\n  isExtensible: function(target) {\n  }\n});\nМетод возвращает булево значение. Инварианты (будет выброшено исключение): метод Object.isExtensible(proxy) должен возвращать то же значение, что и метод Object.isExtensible(target).\nonst p = new Proxy({}, {\n  isExtensible: function(target) {\n    console.log('called');\n    return true;\n  }\n});\nconsole.log(Object.isExtensible(p)); // \"called\"\n                                     // true"
        },
        {
          "name": "handler.ownKeys()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.92,
          "type": "Proxy handler",
          "description": "метод-ловушка для Reflect.ownKeys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbils() и Object.keys(). Синтаксис - \nconst p = new Proxy(target, {\n  ownKeys: function(target) {\n  }\n});\nМетод должен вернуть перебираемый объект (итератор). Инварианты (будет выброшено исключение): результатом метода должен быть массив; элементы этого массива - строки или символы; итоговый список должен содержать ключи всех неконфигурируемых собственных свойств целевого объекта; если целевой объект нерасширяемый, итоговый список должен включать ключи всех собственных свойств объекта и больше никаких значений. \nconst p = new Proxy({}, {\n  ownKeys: function(target) {\n    console.log('called');\n    return ['a', 'b', 'c'];\n  }\n});\nconsole.log(Object.getOwnPropertyNames(p)); // 'called'\n                                                                           // [ 'a', 'b', 'c' ]"
        },
        {
          "name": "handler.preventExtentions()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.93,
          "type": "Proxy handler",
          "description": "метод ловушка для Object.preventExtentions() и Reflect.preventExtentions(). Синтаксис - \nconst p = new Proxy(target, {\n  preventExtentions: function(target) {\n  }\n});\nМетод должен возвращать булево значение. Инварианты (будет выброшено исключение): Object.preventExtentions(proxy) должен возвращать только true, если Object.isExtensible(proxy) возвращает false. \nconst p = new Proxy({}, {\n  preventExtensions: function(target) {\n    console.log('called');\n    Object.preventExtensions(target);\n    return true;\n  }\n});\nconsole.log(Object.preventExtensions(p)); // \"called\"\n                                          // false"
        },
        {
          "name": "handler.set()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.94,
          "type": "Proxy handler",
          "description": "метод-ловушка для перехвата установки свойств. Перехватывает операции присваивания proxy[foo] = bar и proxy.foo = bar, присваивание наследуемому свойству Object.create(proxy)[foo] = bar и Reflect.set(). Синтаксис - \nconst p = new Proxy(target, {\n  set: function(target, property, value, receiver) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, property - имя или Symbol устанавливаемого свойства, value - новое значение свойства, receiver - объект, которому прямо адресовано присваивание, обычно это сам прокси, но обработчик может также быть вызван не прямо, а через цепочку наследования или другим образом (предположим, есть скрипт с obj.name = 'jen', и obj - не прокси и не имеет собственного свойства name, но имеет прокси в цепочке прототипов, тогда при вызове set() указываем в качестве receiver obj). Метод возвращает булево значение: true, если присваивание прошло успешно; если он возвращает false и присваивание производилось в строгом режиме, будет выброшено исключение TypeError. Инварианты (будет выброшено исключение): нельзя изменять значение свойства, отличное от значения соответствующего свойства целевого объекта, если это свойство целевого объекта неперезаписываемое, неконфигурируемое свойство данных; нельзя устанавливать значение свойства, если соответствующее свойство целевого объекта неконфигурируемое свойство доступа, имеющее в качестве своего атрибута [[Set]] значение undefined; в строгом режиме возврат значения false обязательно приведет к выбросу исключения. \nconst p = new Proxy({}, {\n  set: function(target, prop, value, receiver) {\n    target[prop] = value;\n    console.log('property set: ' + prop + ' = ' + value);\n    return true;\n  }\n})\nconsole.log('a' in p);  // false\np.a = 10;               // \"property set: a = 10\"\nconsole.log('a' in p);  // true\nconsole.log(p.a);       // 10"
        },
        {
          "name": "handler.setPrototypeOf()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.95,
          "type": "Proxy handler",
          "description": "метод-ловушка для перехвата Object.setPrototypeOf() и Reflect.setPrototypeOf(). Синтаксис - \nconst p = new Proxy(target, {\n  setPrototypeOf: function(target, prototype) {\n  }\n});\nМетоду передаются следующие аргументы, this привязан к обработчику. target - целевой объект, prototype - новый объект-прототип или null. Возвращает true при успешном изменении прототипа, иначе - false. Инварианты (будет выброшено исключение): если целевой объект нерасширяем, параметр prototype должен быть равен значению метода Object.getPrototypeOf(target). Метод можно применять для предотвращения изменения прототипа объекта - тогда он должен возвращать false или выбрасывать исключение. \nconst handlerReturnsFalse = {\n    setPrototypeOf(target, newProto) {\n        return false;\n    }\n};\nconst newProto = {}, target = {};\nconst p1 = new Proxy(target, handlerReturnsFalse);\nObject.setPrototypeOf(p1, newProto); // throws a TypeError\nReflect.setPrototypeOf(p1, newProto); // returns false"
        },
        {
          "name": "Proxy.revocable()",
          "classDeck": "card",
          "deck": "Proxy",
          "id": 4.96,
          "type": "static property",
          "description": "статический метод в синтаксисе Proxy.revocable(target, handler) используется для создания отзываемых (revocable) прокси. target - целевой объект для оборачивания в прокси, может быть объектом любого типа, включая обычный массив, функцию или даже другой прокси. handler - объект, чьи свойства и функции определяют поведение прокси при проведении операций с ним. Метод возвращает новый отзываемый прокси. Это объект с двумя значениями: {proxy: proxy, revoke: revoke}, где proxy - новый объект прокси, созданный вызовом new Proxy(target, handler), а revoke - функция, \"выключающая\" этот прокси, делающая его невалидным. При вызове proxy.revoke() прокси становится неиспользуемым, любая установленная у обработчика handler ловушка выбросит исключение, если прокси уже отозван - он отозван навсегда и становится целью сборщика мусора. Повторный вызов revoke() не даст никакого результата. \nvar revocable = Proxy.revocable({}, {\n  get: function(target, name) {\n    return \"[[\" + name + \"]]\";\n  }\n});\nvar proxy = revocable.proxy;\nconsole.log(proxy.foo); // \"[[foo]]\"\nrevocable.revoke();\nconsole.log(proxy.foo); // TypeError is thrown\nproxy.foo = 1; // TypeError again\ndelete proxy.foo;  // still TypeError\ntypeof proxy; // \"object\", typeof doesn't trigger any trap"
        }
      ]
    },
    {
      "name": "Spec. characters",
      "classDeck": "deck",
      "deck": "Spec. characters",
      "type": "Spec. characters",
      "description": "",
      "id": 6,
      "objects": [
        {
          "name": "\"",
          "classDeck": "card",
          "deck": "Spec. characters",
          "type": "escape sequence",
          "description": "двойная кавычка",
          "id": 6.1
        }
      ]
    },
    {
      "name": "Attr",
      "classDeck": "deck",
      "deck": "Attr",
      "type": "Attr",
      "description": "интерфейс Attr - это атрибуты одного отдельно взятого элемента DOM, представленные в виде объекта. В большинстве методов DOM вы будете получать атрибут в виде строки (например, при помощи Element.getAttribute()), но некоторые функции (Element.getAttributeNode()) или результат итерации вернут объект типа Attr. Некоторые браузеры сообщают об определенных устаревших и запрещенных атрибутах сообщениями в консоли.",
      "objects": [
        {
          "name": "Attr.name",
          "classDeck": "card",
          "deck": "Attr",
          "type": "property",
          "description": "имя атрибута",
          "id": 7.1
        },
        {
          "name": "Attr.localName",
          "classDeck": "card",
          "deck": "Attr",
          "type": "property",
          "description": "свойство только для чтения, возвращающее \"локальную часть\" составного имени атрибута (ранее этот API принадлежал интерфейсу Node). Локальное имя - часть составного имени атрибута в XML в виде foo:localName где первая часть (foo) - это имя пространства имен, а вторая часть после двоеточия (localName) - локальное имя.",
          "id": 7.11
        },
        {
          "name": "Attr.name",
          "classDeck": "card",
          "deck": "Attr",
          "type": "property",
          "description": "имя атрибута",
          "id": 7.12
        },
        {
          "name": "Attr.namespaceURI",
          "classDeck": "card",
          "deck": "Attr",
          "type": "property",
          "description": "свойство только для чтения, возвращающее пространство имен URI, использующееся для атрибута, или null, если атрибут вне пространства имен.\nif (attribute.localName == \"value\" && \n    attribute.namespaceURI == \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\") {\n  // this is a XUL value \n}\nЭто не вычисляемое значение, а результат поиска, основанного на проверке пространства имен, использованного при объявлении переменной. Пространство имен URI данного атрибута фиксируется в момент его создания. В ранних версиях браузеров у HTML-атрибутов это был null, сейчас, в связи с требованиями HTML5, это https://www.w3.org/1999/xhtml как в XHTML. Вы можете создать атрибут с именем определенного пространства, используя старый метод Element.setAttributeNS. В соответствии со спецификацией пространств имен в XML, атрибут не наследует именное пространство от элемента, к которому он добавляется. Если атрибуту не дается определенное пространство, он не имеет пространства. DOM не обрабатывает и не принуждает проверять пространство имен. Необходимая валидация устанавливается у DOM-приложения дополнительно, если она необходима. Помните также, что префикс пространства имен, однажды установленный у конкретного узла, не может быть изменен.",
          "id": 7.13
        },
        {
          "name": "Attr.prefix",
          "classDeck": "card",
          "deck": "Attr",
          "type": "property",
          "description": "свойство только для чтения, возвращающее префикс пространства имен установленного атрибута или null, если пространство не указано (ранее свойство принадлежало интерфейсу Node). Свойство работает только с MIME-типом XML, с HTML не работает.",
          "id": 7.14
        },
        {
          "name": "Attr.specified",
          "classDeck": "card",
          "deck": "Attr",
          "type": "property",
          "description": "только для чтения, всегда возвращает true. Первоначально должно было возвращать true, если специально было создано в коде или скрипте, а false - если  устанавливалось автоматически в документах DTD.",
          "id": 7.15
        },
        {
          "name": "Attr.value",
          "classDeck": "card",
          "deck": "Attr",
          "type": "property",
          "description": "значение атрибута",
          "id": 7.16
        }
      ],
      "id": 7
    },
    {
      "name": "CanvasGradiant",
      "classDeck": "deck",
      "deck": "CanvasGradiant",
      "type": "CanvasGradiant",
      "description": "интерфейс представляет закрытый объект, описывающий градиент. Возвращается методами \nCanvasRenderingContext2D.createLinearGradient(), \nCanvasRenderingContext2D.createConicGradient() \nили \nCanvasRenderingContext2D.createRadialGradient(). Может использоваться как значение свойств CanvasRenderingContext2D.fillStyle и .strokeStyle. \nМетод всего один.",
      "id": 8,
      "objects": [
        {
          "name": "CanvasGradiant.addColorStop()",
          "classDeck": "card",
          "deck": "CanvasGradiant",
          "type": "method",
          "description": "метод в синтаксисе \nvoid gradient.addColorStop(offset, color) \nдобавляет новую цветовую опорную точку, устанавливающую цвет и смещение у данного канвас-градиента. offset - число от 0 до 1 включительно, 0 - начало градиента, 1 - его конец, будет выброшено исключение при выходе за эти границы. color - любое принятое CSS-значение цвета. ",
          "id": 8.1
        }
      ]
    },
    {
      "name": "CanvasPattern",
      "classDeck": "deck",
      "deck": "CanvasPattern",
      "type": "CanvasPattern",
      "description": "интерфейс, представляющий собой закрытый объект, описывающий паттерн, основанный на изображении, холсте канвас или видео, созданный методом CanvasRenderingContext2D.createPattern(). Может использоваться как значение свойтв CanvasRenderingContext2D.fillStyle или .strokeStyle. \nНе наследует ничьих методов, из собственных только один.",
      "id": 9,
      "objects": [
        {
          "name": "CanvasPattern.setTransform()",
          "classDeck": "card",
          "deck": "CanvasPattern",
          "type": "method",
          "description": "метод в синтаксисе \nvoid pattern.setTransform(matrix) \nиспользует SVG-матрицу (исключена из рекомендаций) или DOM-матрицу (DOMMatrix) для преобразований паттерна. Не поддерживается в IE.\nimg.onload = function() {\n  var pattern = ctx.createPattern(img, 'repeat');\n  pattern.setTransform(matrix.rotate(-45).scale(1.5));\n  ctx.fillStyle = pattern;\n  ctx.fillRect(0, 0, 400, 400);\n};",
          "id": 9.1
        }
      ]
    },
    {
      "name": "CanvasRenderingContext2D",
      "classDeck": "deck",
      "deck": "CanvasRenderingContext2D",
      "type": "CanvasRenderingContext2D",
      "description": "этот интерфейс - часть Canvas API, предоставляющий изобразительный двумерный контекст на поверхности элемента <canvas>. Используется для отрисовки фигур, текста и других объектов.",
      "id": 10,
      "objects": [
        {
          "name": "CanvasRenderingContext2D.getTransform()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nlet storedTransform = ctx.getTransform() \nобеспечивает доступ и возвращает текущую матрицу преобразований в виде объекта DOMMatrix, примененную к контексту. Возвращает \"неживой\" объект, так что обновление матрицы не скажется на свойствах этого объекта, как и обновление объекта не отразится на матрице. Не поддерживается в IE",
          "id": 10.1
        },
        {
          "name": "CanvasRenderingContext2D.arc()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise) \nдобавляет дугу окружности к текущему под-пути. Создает окружность с центром в точке x, y с радиусом radius. Линия начинается с точки в startAngle (в радианах) и заканчивается в endAngle в направлении по часовой стрелке (по умолчанию, значение false последнего аргумента) или против часовой стрелки (true). Угол в 2пи радиана - 360 градусов, 1пи - 180, пи/2 - 90, пи/4 - 45... Можно считать по формуле: radians = (Math.PI / 180) * degrees.",
          "id": 10.11
        },
        {
          "name": "CanvasRenderingContext2D.arcTo()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.arcTo(x1,y1, x2, y2, radius) \nдобавляет дугу окружности к текущему под-пути, используя указываемые контрольные точки и радиус. Дуга автоматически подсоединяется к последней точке пути прямой линией, если это указать в дополнительных опциях. Метод широко используется для создания округленных углов. При достаточно большом значении радиуса результат не совсем предсказуем, т.к. линия, соединяющая арку с путем, может уйти далеко за пределы canvas. Угол в 2пи радиана - 360 градусов, 1пи - 180, пи/2 - 90, пи/4 - 45... Можно считать по формуле: radians = (Math.PI / 180) * degrees.",
          "id": 10.12
        },
        {
          "name": "CanvasRenderingContext2D.beginPath()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод, запускающий создание нового пути (path) путем очистки списка под-путей (sub-paths). Синтаксис - \nvoid ctx.beginPath()\nДля создания нового под-пути есть метод .moveTo(). ",
          "id": 10.13
        },
        {
          "name": "CanvasRenderingContext2D.beginPath()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод, запускающий создание нового пути (path) путем очистки списка под-путей (sub-paths). Синтаксис - \nvoid ctx.beginPath()\nДля создания нового под-пути есть метод .moveTo(). ",
          "id": 10.14
        },
        {
          "name": "CanvasRenderingContext2D.bezierCurveTo()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) \nдобавляет кривую Безье к текущему под-пути. Метод требует указания трех точек: первые две - контрольные точки (центры окружностей Безье) и третья - конечная. Начальная точка - последняя опорная точка текущего пути, которую можно изменить методом .moveTo() перед созданием кривой. ",
          "id": 10.15
        },
        {
          "name": "CanvasRenderingContext2D.canvas",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство только для чтения, представляющее собой ссылку на объект HTMLCanvasElement, который ассоциирован с данным контекстом. Это может быть null, если с данным контекстом нет ассоциированного элемента <canvas>. Синтаксис - \nctx.canvas",
          "id": 10.16
        },
        {
          "name": "CanvasRenderingContext2D.clearRect()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "один из трех методов прямоугольников, в синтаксисе \nvoid ctx.clearRect(x, y, width, height) \nстирает все пиксели в указанной прямоугольной зоне, устанавливая их значение в прозрачный черный - rgba(0,0,0,0). Метод может стать причиной неожиданных побочных эффектов при неправильном рисовании путей (paths). Убедитесь, что вызвали метод .beginPath() до начала рисования новой фигуры после вызова .clearRect(). Метод создает прямоугольник, начиная в точке с координатами x, y с установленными шириной и высотой. Позитивные значения ширины распространят прямоугольник вправо, отрицательные - влево. Позитивные значения высоты распространят его вниз, отрицательные - вверх относительно начала его координат. Одно из применений - очистка всего холста разом, что делается при смене каждого кадра в анимации.\nctx.clearRect(0, 0, canvas.width, canvas.height);",
          "id": 10.17
        },
        {
          "name": "CanvasRenderingContext2D.clip()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.clip(fillRule) \nили \nvoid ctx.clip(fillRule, path) \nпревращает текущий или указанный путь в вырезанный участок. Предыдущая вырезанная часть, если такая есть, накладывается на текущий или указанный путь, создавая новую - общую - вырезанную часть. Соответственно видимыми на холсте остаются лишь элементы внутри вырезанной части. Такие \"трафареты\" создаются только фигурами, добавленными к текущему пути. Их нельзя создать из фигур, отрисованных прямо в холст, как, например, с .fillRect() - вместо этого следует использовать .rect(), добавляя прямоугольник к текущему пути и затем вызывая .clip(). fillRule - алгоритм, определяющий контрольную точку внутри или снаружи вырезаемого участка: \"nonzero\" (по умолчанию) или \"evenodd\" (места пересечения фигур вырезаются). Возможный аргумент path - указанный путь, по которому надо сделать обрезку. Сначала создается вырезанный участок, потом рисуется остальной контент. ",
          "id": 10.18
        },
        {
          "name": "CanvasRenderingContext2D.closePath()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.closePath() \nсоединит текущую опорную точку с точкой начала под-пути прямой линией. Если фигура уже замкнута или имеет только одну опорную точку, метод не сделает ничего. Метод не рисует ничего в canvas напрямую, ничего не будет отрисовано без применения .fill() или .stroke(). Можно, к примеру дорисовать треугольник, дойдя до второй опорной точки и вызвав этот метод. Можно дорисовать полукруг из арки и т.д.",
          "id": 10.19
        },
        {
          "name": "CanvasRenderingContext2D.createConicGradient()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nlet gradient = ctx.createConicGradient(startAngle, x, y) \nсоздает градиент в виде окружности вокруг указанной точки с координатами (x, y). Возвращает объект CanvasGradient с коническим градиентом. Перед применением объект нужно присвоить свойству .fillStyle или .strokeStyle. Координаты градиента считаются относительно всей координатной сетки, так что при применении они все так же будут находиться относительно общего пространства. Аргумент startAngle укажет направление конуса градиента (старт на 12 часах по часовой стрелке). Почти нет браузерной поддержки, поддерживается только Firefox.",
          "id": 10.2
        },
        {
          "name": "CanvasRenderingContext2D.createImageData()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nconst imageData = ctx.createImageData(width, height) \nили \nconst imageData = ctx.createImageData(anotherImageData) \nсоздает новый \"чистый\" объект ImageData указанных размеров. Все пиксели нового объекта - прозрачные черные. Отрицательные значения ширины и высоты будут \"тянуть\" объект в противоположную сторону (влево и вверх). anotherImageData - другой объект ImageData, значения ширины и высоты которого заимствуются для нового объекта. Сам объект не копируется. Если хотя бы один из параметров ширины и высоты равен 0, будет выброшено исключение. \nconst imageData = ctx.createImageData(100, 50);\nconsole.log(imageData); // ImageData { width: 100, height: 50, data: Uint8ClampedArray[20000] }\nЗаполнение пикселей пурпурным цветом (на каждый пиксель приходитс 4 значения (rgba):\nfor (let i = 0; i < imageData.data.length; i += 4) {\n  imageData.data[i + 0] = 190;  // R value\n  imageData.data[i + 1] = 0;    // G value\n  imageData.data[i + 2] = 210;  // B value\n  imageData.data[i + 3] = 255;  // A value\n}\nctx.putImageData(imageData, 20, 20);",
          "id": 10.21
        },
        {
          "name": "CanvasRenderingContext2D.createLinearGradient()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nlet gradient = ctx.createLinearGradient(x1, y1, x2, y2) \nсоздает линейный градиент относительно линии между двумя точками с указанными координатами. Возвращает объект линейного градиента CanvasGradient. Для применения градиент сначала нужно присвоить свойству .fillStyle или .strokeStyle. Координаты \"опорной\" линии градиента считаются относительно всей координатной сетки, так что при применении они все так же будут находиться относительно общего пространства. После создания объекта градиента к нему добавляются цветовые точки его собственным методом \nCanvasGradient.addColorStop() ",
          "id": 10.22
        },
        {
          "name": "CanvasRenderingContext2D.createPattern()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nlet canvasPattern = ctx.createPattern(image, repitition) \nсоздает паттерн (шаблон), используя указанное изображение и метод его репликации. Метод возвращает объект \nCanvasPattern. Метод ничего не отрисовывает в canvas напрямую. Паттерн нужно присвоить в виде значения свойству .fillStyle или .strokeStyle, чтобы затем применить к холсту. В качестве аргумента image выступает объект внутреннего типа данных CanvasImageSource: в качестве допустимых интерфейсов для данного метода - HTMLImageElement, SVGImageElement, HTMLVideoElement, HTMLCanvasElement, ImageBitmap, OffscreenCanvas. repitition - строка, обозначающая как надо реплицировать изображение: \"repeat\" - в обоих направлениях, \"repeat-x\" - только по горизонтали, \"repeat-y\" - только по вертикали, \"no-repeat\" - не повторять ни в каком из направлений. Установка значения в виде пустой строки \"\" или null применит \"no-repeat\". Пример с созданием паттерна offscreen, который затем берем как паттерн для заполнения основного холста.\n// Create a pattern, offscreen\nconst patternCanvas = document.createElement('canvas');\nconst patternContext = patternCanvas.getContext('2d');\n// Give the pattern a width and height of 50\npatternCanvas.width = 50;\npatternCanvas.height = 50;\n// Give the pattern a background color and draw an arc\npatternContext.fillStyle = '#fec';\npatternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);\npatternContext.arc(0, 0, 50, 0, .5 * Math.PI);\npatternContext.stroke();\n// Create our primary canvas and fill it with the pattern\nconst canvas = document.createElement('canvas');\nconst ctx = canvas.getContext('2d');\nconst pattern = ctx.createPattern(patternCanvas, 'repeat');\nctx.fillStyle = pattern;\nctx.fillRect(0, 0, canvas.width, canvas.height);\n// Add our primary canvas to the webpage\ndocument.body.appendChild(canvas);",
          "id": 10.23
        },
        {
          "name": "CanvasRenderingContext2D.createRadialGradient() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nlet canvasGradient = ctx.createRadialGradient(x1, y1, r1, x2, y2, r2) \nсоздает радиальный градиент. Возвращает объект \nCanvasGradient. Перед применением объект нужно присвоить свойству .fillStyle или .strokeStyle. Координаты градиента считаются относительно всей координатной сетки, так что при применении они все так же будут находиться относительно общего пространства. Аргументы - координаты центра стартовой окружности и ее диаметр (нельзя применять отрицательные значения и Infinity) и координаты и радиус конечной окружности (также к радиусу неприменимы отрицательные значения и бесконечность). После создания объекта градиента к нему добавляются цветовые точки его собственным методом CanvasGradient.addColorStop(). \nctx.arc(600, 300, 250, 0, 2 * Math.PI, false);\nlet gradient = ctx.createRadialGradient(600, 300, 250, 790, 200, 1);\ngradient.addColorStop(0, \"grey\");\ngradient.addColorStop(.7, \"lightgrey\");\ngradient.addColorStop(1, \"whitesmoke\");\nctx.fillStyle = gradient;\nctx.fill();",
          "id": 10.24
        },
        {
          "name": "CanvasRenderingContext2D.direction",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "экспериментальное свойство (не поддерживается в IE и Firefox), определяющее направление написания текста. Значения - \"ltr\", \"rtl\" и \"inherit\" (значение по умолчанию, использует указываемый для <canvas> или всего документа тип написания).",
          "id": 10.25
        },
        {
          "name": "CanvasRenderingContext2D.drawFocusIfNeeded()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.drawFocusIfNeeded(element) \nили \nvoid ctx.drawFocusIfNeeded(path, element) \nотрисовывает кольцо фокусировки вокруг текущего или указанного пути, если указанный элемент в фокусе. Не поддерживается в IE.",
          "id": 10.26
        },
        {
          "name": "CanvasRenderingContext2D.drawImage() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в одном из трех синтаксисов, отрисовывающий указанное изображение на холсте. Аргумент image - обязательный во всех вариантах. Это может быть любой валидный ресурс CanvasImageResource - CSSImageValue, HTMLImageElement, SVGImageElement, HTMLVideoElement, ImageBitmap, HTMLCanvasElement или OffscreenCanvas.\nvoid ctx.drawImage(image, dx, dy) \n- dx, dy - координаты на целевом (destination canvas) холсте, откуда начнет отрисовываться изображение. В целом, просто помещает изображение в нужной позиции.\nvoid ctx.drawImage(image, dx, dy, dwidth, dheight) \n- dwidth и dheight - итоговая ширина и высота изображения на целевом (destination) холсте. Позволяют масштабировать изображение. Каждый из этих аргументов по-отдельности не входят в синтаксис с 3-мя  аргументами. В целом, помещает изображение в нужной позиции с указанными размерами.\nvoid ctx.drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) \n- sx, sy - координаты верхнего левого угла исходного изображения для вписывания в целевой контекст. Каждый из этих аргументов по-отдельности не входят в синтаксис с 3-мя или 5-ю аргументами. swidth, sheight - ширина и высота исходного изображения для вписывания в целевой контекст. Если не указаны, координаты sx и sy будут применены к правому нижнему углу изображения при отрисовке. Каждый из этих аргументов по-отдельности не входят в синтаксис с 3-мя или 5-ю аргументами. В целом, берет от указанной точки изображения прямоугольник указанных размеров и помещает в нужном месте на холст с заданными - другими, если нужно, размерами. Пример с масштабированием:\nlet width = img.width;\nlet height = img.height;\nctx.drawImage(img, 0, 0, width, height, 200, 200, width / 5, height / 5);\nОтрисовку необходимо выполнять строго после загрузки всех задействованных изображений - с применением обработчика onload или проверкой .complete === true. У SVG-элементов характеристики ширины и высоты должны быть указаны в корневом теге <svg>. Метод использует реальные размеры изображения. Т.е., если задать конструктором изначальный размер (new Image(50, 50)), то при работе с изображением нужно будет работать с параметрами \nHTMLImageElement.naturalWidth и \nHTMLImageElement.naturalHeght. Это касается и видео в элементах HTMLVideoElement. \nfunction drawImageActualSize() {\n  // Use the intrinsic size of image in CSS pixels for the canvas element\n  canvas.width = this.naturalWidth;\n  canvas.height = this.naturalHeight;\n  // Will draw the image as 300x227, ignoring the custom size of 50x50\n  // given in the constructor\n  ctx.drawImage(this, 0, 0);\n  // To use the custom size we'll have to specify the scale parameters\n  // using the element's width and height properties - lets draw one\n  // on top in the corner:\n  ctx.drawImage(this, 0, 0, this.width, this.height);\n}",
          "id": 10.27
        },
        {
          "name": "CanvasRenderingContext2D.ellipse() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise)\nдобавляет к текущему под-пути эллиптическую дугу с центром в точке (x, y) и радиусами radiusX (главная ось) и radiusY (вторичная ось). rotation - поворот эллипса в радианах, startAngle - угол, с которого начинается эллипс, отсчитывается по часовой стрелке в положительных значениях на оси x в радианах, endAngle - угол, на котором эллипс заканчивается, отсчитывается по часовой стрелке в положительных значениях на оси x в радианах. Опционально указывается counterclockwise (по умолчанию false) - рисовать ли эллипс против часовой стрелки. Угол в 2пи радиана - 360 градусов, 1пи - 180, пи/2 - 90, пи/4 - 45... Можно считать по формуле: radians = (Math.PI / 180) * degrees.",
          "id": 10.28
        },
        {
          "name": "CanvasRenderingContext2D.fill()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.fill(fillRule) \nили \nvoid ctx.fill(path, fillRule) \nзаполнит текущий или указанный (path) путь в соответствии с заданным в свойстве .fillStyle стилем заливки. fillRule - алгоритм заливки: \"nonzero\" (по умолчанию, зальет весь путь вне зависимости от пересечения линий и проч) или \"evenodd\", тогда места, нарисованные, например, против часовой стрелки, не будут залиты. path - сохраненный 2D-путь (не поддерживается в IE). Вызывая .fill(), можно не волноваться, что фигура не осталась замкнутой (не использовался .closePath() - в отличие от применения .stroke(). ",
          "id": 10.29
        },
        {
          "name": "CanvasRenderingContext2D.fillRect()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "один из трех методов рисования прямоугольников, в синтаксисе \nvoid ctx.fillRect(x, y, width, height) \nрисует прямоугольник, заполненный (залитый) цветом, градиентом или другим наполнением в соответствии со свойством CanvasRenderingContext2D.fillStyle. Метод рисует прямо в canvas без изменения существующего контура, так что вызов впоследствии любых методов вроде .fill() или .stroke() не возымеет эффекта на фигуру. Метод рисует прямоугольник, начиная в точке с координатами x, y с установленными шириной и высотой. Позитивные значения ширины распространят прямоугольник вправо, отрицательные - влево. Позитивные значения высоты распространят его вниз, отрицательные - вверх относительно начала его координат. Распространен способ создания прямоугольника на весь холст, играющего роль заднего фона для остальной композиции. \nctx.fillRect(0, 0, canvas.width, canvas.height);",
          "id": 10.3
        },
        {
          "name": "CanvasRenderingContext2D.fillStyle",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, устанавливающее цвет, градиент или паттерн для заливки фигур. По умолчанию - черный цвет #000. Устанавливаемое значение - строка, обозначение цвета, принятое в CSS (rgb, rgba, hsl, ключевые слова и т.д.), объект CanvasGradient (возвращается методами \nCanvasRenderingContext2D.createLinearGradient(), CanvasRenderingContext2D.createConicGradient() или CanvasRenderingContext2D.createRadialGradient(), также может использоваться в свойстве .fillStyle) или объект CanvasPattern (паттерн, основанный на изображении, канвасе или видео, созданный при помощи CanvasRenderingContext2D.createPattern(), также может использоваться в .fillStyle).",
          "id": 10.31
        },
        {
          "name": "CanvasRenderingContext2D.fillText()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.fillText(text, x, y, maxWidth) \nрисует текстовую строку в указанных координатах, заполняя символы заливкой в соответствии со свойством .fillStyle. Необязательный параметр maxWidth устанавливает максимальную ширину текста, которую пользовательский агент должен обеспечить при помощи сжатия текста (кернинг) или уменьшения его размера. Рисует напрямую в холст, так что не изменяет текущего пути и на отрисовку не влияют последующие вызовы fill() или stroke(). Текст отрисовывается в соответствии со значениями свойств .font, .textAlign, .textBaseLine и .direction. Возвращает undefined. ",
          "id": 10.32
        },
        {
          "name": "CanvasRenderingContext2D.filter",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "экспериментальное свойство, позволяющее применять на холсте CSS-фильтры, такие как размытие или сепировние. Похоже на CSS-свойство filter и принимает такие же значения. Синтаксис - \nvoid ctx.filter = \"filter-function-1 filter-function-2 ...\" \nили \nvoid ctx.filter = \"none\"\nНексолько фильтров пишутся через пробел. url(\"url\") приводит ссылку на внедряемый SVG-объект. blur(number) применить размытие по Гауссу (чем больше значение number, ознакчающее количество пикселей, на которое проникают друг в друга границы изображений, тем больше размытие, 0 не изменит ничего). brightness(%) применит линейный множитель к отрисованному, делая его светлее или темнее, значение меньше 100% затемняет изображение, больше 100% осветляет, 0 сделает изображение полностью черным, 100% оставит его неизмененным. contrast(%) установит контраст, 0% сделает изображение полностью черным, 100% оставит все неизмененным. drop-shadow() - накладывает эффект отбрасываемой тени, эффектнее всего тень будет смотреться, если она размыта, со смещением, маска отрисована в определенном цвете и расположена под элементом; функция принимает до 5 аргументов - offset-x (горизонтальная \"длина\" тени), offset-y (вертикальный размер тени), blur-radius (размытие, чем больше значение - тем больше размытие, а тень становится больше и светлее, отрицательные значения неприменимы), color (цвет, ключевые слова, hex, rgb...). grayscale(%) конвертирует изображение в серую гамму, значение в 100% - полностью серые цвета, 0% - без изменений. hue-rotate(angle) - применяет поворот к изображению, 0deg оставит все без изменений. invert(%) - инвертирует цвета, 100% - полная инверсия, 0% - без изменений. opacity(%) делает изображение прозрачным, 0% - полностью прозрачное, 100% - непрозрачное. saturate(%) - насыщенность изображения, 0% - полностью ненасыщенное, 100% - без изменений. sepia(%) - сепирование, 100% - полное, 0% - без изменений. \"none\" - без фильтров, изначальное состояние. Нет поддержки в IE и Safari",
          "id": 10.33
        },
        {
          "name": "CanvasRenderingContext2D.font",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, устанавливающее стиль текста. Значение - DOMString (строка) - такое же, как у CSS-свойства font, с перечнем CSS-свойств: размер (font-size) и семейство (font-family, должен идти последним параметром) шрифтов (обязательные параметры), начертание (font-style), вариант (font-variant, в \"общем\" свойстве возможно применение только двух значений - normal и small-caps) и \"вес\" (font-weight) шрифта (должны предшествовать размеру), растяжение (font-stretch) и межстрочный интервал (line-height, должен идти сразу за размером, отделяясь от него слэшом /). ",
          "id": 10.34
        },
        {
          "name": "CanvasRenderingContext2D.getContextAttributes()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nctx.getContextAttributes() \nвернет объект CanvasRenderingContext2DSettings, содержащий в виде свойств актуальные параметры контекста холста: alpha - булево значение присутствия альфа-канала, если false - задний фон холста непрозрачный, что позволяет ускорить отрисовку прозрачного контента и изображений; desynchronized - булево значение, определяющее, уменьшено ли время задержки установкой пользовательским агентом десинхронизации рисующего цикла холста и событийного цикла. Атрибуты холста можно установить при создании контекста методом \nHTMLCanvasElement.getContext(). Нет поддержки в IE и Firefox",
          "id": 10.35
        },
        {
          "name": "CanvasRenderingContext2D.getImageData() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.getImageData(x, y, w, h) \nвозвращает объект ImageData, представляющий собой набор данных о пикселях указываемого участка холста (в указанном координатами прямоугольнике, чей левый верхний угол находится в координатах x, y, отрицательные значения ширины и высоты \"потянут\" прямоугольник влево и вверх соответственно, а координатами нижнего правого угла будут x+w, y+h). На метод не влияет матрица изменений холста. Если указанный прямоугольник выходит за рамки холста, пиксели за пределами холста в возвращаемом объекте ImageData будут прозрачными черными. Полученные данные можно отрисовать на холсте методом .putImageData(). Если хотя бы одно из значений ширины или высоты равно 0, будет выброшено IndexSizeError. Также возможно появление ошибки SecurityError, если источник изображения отличен от источника документа - тогда требуется настройка CORS. ",
          "id": 10.36
        },
        {
          "name": "CanvasRenderingContext2D.getLineDash()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.getLineDash() \nиспользуется для получения текущего паттерна штриховки контура (созданный методом .setLineDash()). Возвращаемое значение - массив значений, устанавливающих размер прерывистой линии и промежутка между ними (именно в таком порядке). Если число нечетное, элементы массива копируются и объединяются в один сдвоенный.",
          "id": 10.37
        },
        {
          "name": "CanvasRenderingContext2D.globalAlpha",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, устанавливающее альфа-канал (полупрозрачность) фигурам и изображениям перед тем, как они будут размещены на холсте. Значение - число от 0.0 (полностью прозрачный) до 1.0 (абсолютно непрозрачный, значение по умолчанию). Любые другие значения, включая Infinity и NaN не будут применены и свойство сохранит свое прежнее значение. \nctx.fillStyle = '#FD0';\nctx.fillRect(0, 0, 75, 75);\nctx.fillStyle = '#6C0';\nctx.fillRect(75, 0, 75, 75);\nctx.fillStyle = '#09F';\nctx.fillRect(0, 75, 75, 75);\nctx.fillStyle = '#F30';\nctx.fillRect(75, 75, 75, 75);\nctx.fillStyle = '#FFF';\n// Set transparency value\nctx.globalAlpha = 0.2;\n// Draw transparent circles\nfor (let i = 0; i < 7; i++) {\n  ctx.beginPath();\n  ctx.arc(75, 75, 10 + 10 * i, 0, Math.PI * 2, true);\n  ctx.fill();\n}",
          "id": 10.38
        },
        {
          "name": "CanvasRenderingContext2D.globalCompositeOperation ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "устанавливает тип композиции, применяемый при рисовании новых фигур. Синтаксис - \nvoid ctx.globalCompositeOperation = type; \nПрисваиваемое значение type - строка, описывающая тип композиции: source-over - новый контент рисуется поверх существующего, source-in - новый контент рисуется только там, где новое изображение и холст, где оно должно появиться, накладываются друг на друга, все остальное становится прозрачным, source-out - новые изображения рисуются там, где они не накладываются на существующие, \nsource-atop - новые изображения рисуются только там, где они накладываются на старые, destination-over - новые изображения рисуются позади существующего контента, \ndestination-in - существующий контент сохраняется там, где он накладывается на новые изображения, все остальное делается прозрачным, destination-out - существующий контент сохраняется там, где на него не накладываются новые изображения (которые сами становятся прозрачными), destination-atop - существующий контент сохраняется там, где на него не накладываются новые изображения (а они сами рисуются позади уже существующих фигур), lighter - там, где новые и старые изображения накладываются друг на друга, их цвета смешиваются аддитивно - основываясь на технологии излучения света, что дает эффект осветления (смешение всех цветов даст белый), copy - на холсте показываются только новые изображения, xor - и старые, и новые изображения становятся прозрачными при наложении друг на друга, multiply - пиксели рисуемого поверх слоя перемножаются на пиксели подлежащего слоя, в результате получается затемненное изображение, screen - пиксели накладывающихся мест инвертируются, умножаются и снова инвертируются, в результате получается осветленное изображение (противоположность multiply), overlay - смешение multiply с screen, в результате при наложении слоев темные места становятся еще темнее, светлые - еще светлее, darken - остаются лишь наиболее темные пиксели обоих слоев, lighten - остаются лишь наиболее светлые пиксели обоих слоев, color-dodge - делит нижний слой на инвертированный верхний слой, color-burn - инвертированный нижний слой делится на верхний и результат инвертируется, hard-light - смесь multiply и screen, только нижни и верхний слой меняются местами, soft-light - более \"мягкая\" версия hard-light, чистый черный чистый белый по результатам не будут чистыми, difference - из верхнего слоя вычитается нижний - или (другими словами) - все значения округлаются до положительных, exclusion - похоже на difference, но не такой контрастный, hue - сохраняет яркость и насыщенность цвета нижнего слоя, при этом подстраивая цветовой тон (оттенок) верхнего слоя, saturation - сохраняет яркость и цветовой тон нижнего слоя, в то же время подстраивая насыщенность верхнего слоя, color - сохраняет яркость нижнего слоя, подстраивая цветовой тон и насыщенность верхнего, luminosity - сохраняет яркость и цветовой тон (оттенок) нижнего слоя, подстраивая яркость верхнего слоя. В браузерах на WebKit и Blink вместо свойства используется удаленный из стандарта метод ctx.globalCompositeOperation(). ",
          "id": 10.39
        },
        {
          "name": "CanvasRenderingContext2D.imageSmoothingEnabled ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, определяющее, должны ли изображения сглаживаться при их масштабировании (true по умолчанию). Полезно для игр и растровой графики. Для установки или отключения сглаживания нужно применять префиксы производителей:\nctx.mozImageSmoothingEnabled = false;\nctx.webkitImageSmoothingEnabled = false;\nctx.msImageSmoothingEnabled = false;\nctx.imageSmoothingEnabled = false;\nСтепень сглаживания можно установить в свойстве \n.imageSmoothingQuality. ",
          "id": 10.4
        },
        {
          "name": "CanvasRenderingContext2D.imageSmoothingQuality ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, определяющее качество сглаживания при масштабировании изображений (для работы необходимо включенное (true) свойство .imageSmoothingEnabled). Cинтаксис - ctx.imageSmoothingQuality = \"low\"; Возможные значения - \"low\", \"medium\" и \"high\". Не поддерживается в IE и Firefox. ",
          "id": 10.41
        },
        {
          "name": "CanvasRenderingContext2D.lineCap",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, устанавливающее вид \"заглушки\" на концах линий (линии рисуются методами .stroke(), strokeRect() и \n.strokeText()). Имеет одно из трех возможных\nзначений: \"butt\" - обычный \"отруб\" линии, углы прямые,\n\"round\" - углы закруглены (радиус окружности равен половине ширины линии, соответственно, линия удлиняется на половину толщины), \"square\" - к концам линий добавляются прямоугольники такой же ширины, что и толщина линии, и высотой в ее половину. Свойство помогает \"выравнивать\" линии до конца пикселя (отрисовка линий с толщиной, например, в 1px от \"круглых\" значений становится причиной неточной толщины линии, если только не начинать отрисовку с позиции в 1.5px - тогда линия будет занимать по полпикселя с каждой стороны - ровно до границы со следующим, с нечетными значениями толщины линию можно рисовать от границы пикселя; также нужно осторожно работать с пиксельной сеткой и линиями при изменениях масштаба векторной графики).",
          "id": 10.42
        },
        {
          "name": "CanvasRenderingContext2D.lineDashOffset",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, устанавливающее отступ начала рисования штриховой линии в синтаксисе \nctx.lineDashOffset = value, \nгде value - число с плавающей запятой (по умолчанию 0.0). На свойстве основан известный старый трюк с эффектом \"марширующих муравьев\":\nlet offset = 0;\nfunction draw() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.setLineDash([4, 2]);\n  ctx.lineDashOffset = -offset;\n  ctx.strokeRect(10, 10, 100, 100);\n}\nfunction march() {\n  offset++;\n  if (offset > 16) {\n    offset = 0;\n  }\n  draw();\n  setTimeout(march, 20);\n}",
          "id": 10.43
        },
        {
          "name": "CanvasRenderingContext2D.lineJoin",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, определяющее характер стыковки линий (линии рисуются методами .stroke(), strokeRect() и .strokeText()). Не будет иметь силы, если две линии идут в одном направлении (не стыкуются). В ситуации, когда длина линии сведена к нулю (например, когда все конечные и контрольные точки находятся на одной и той же позиции) также приводит к игнорированию этого свойства. Три возможных значения: \"miter\" - значение по умолчанию, стыкующиеся сегменты соединяются друг с другом, удлинняя свои внешние границы до контрольной точки и заполняя цветом образовавшееся ромбовидное пространство (стык в виде конуса), на свойство влияет другое свойство - CanvasRenderingContext2D.miterLimit; \n\n\"round\" - скруглит углы фигуры заполнением дополнительного пространства в виде окружности с центром в точке стыковки и радиусом в размере толщины линии; \n\n\"bevel\" - заполняет дополнительно образовавшийся треугольник между точкой стыковки и отдельными внешними прямыми углами каждого из сегментов.",
          "id": 10.44
        },
        {
          "name": "CanvasRenderingContext2D.lineTo() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.lineTo(x, y) \nдобавляет прямую линию к текущему под-пути, соединяя последнюю опорную точку с указанной координатами x, y. Метод не рендерит ничего напрямую, отрисовывать его нужно при помощи .fill() или .stroke(). Возвращаемое значение - undefined.",
          "id": 10.45
        },
        {
          "name": "CanvasRenderingContext2D.lineWidth",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, устанавливающее толщину линий (линии рисуются методами .stroke(), strokeRect() и .strokeText()). Значение - число в единицах координатного пространства. 0, отрицательные значения, Infinity и NaN игнорируются, по умолчанию - 1.0. Значение не накладывается одно на другое, при отрисовке одного пути берется одно - последнее - значение (если была попытка установить несколько во время рисования пути). Синтаксис - \nvoid ctx.lineWidth = 10;",
          "id": 10.46
        },
        {
          "name": "CanvasRenderingContext2D.measureText() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nlet measuredText = ctx.measureText(text) \nвозвращает объект интерфейса TextMetrics, содержащий подробную информацию об измеряемом тексте (строка text) в данном контексте (ширина и т.д.). ",
          "id": 10.47
        },
        {
          "name": "CanvasRenderingContext2D.miterLimit",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, устанавливающее ограничение на длину образующегося при стыке линий конуса. Значение - число в единицах координатного пространства. 0, отрицательные значения, Infinity и NaN игнорируются. По умолчанию - 10.0. Это значение обрежет конус у линий, стыкующихся под углом меньше 11 градусов. Максимальное значение свойства основано на ширине линии и равно 1/sin(min W/2). Установка значения в корень из 2 (примерно 1.41421...) обрежет лишнее у всех острых углов, оставив нетронутыми прямые и тупые. Значение в 1.0 приведет к отсутствию конусного продолжения у любых стыкующихся линий. ",
          "id": 10.48
        },
        {
          "name": "CanvasRenderingContext2D.moveTo()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.moveto(x, y) \nначнет новый под-путь с точки с координатами x, y. ",
          "id": 10.49
        },
        {
          "name": "CanvasRenderingContext2D.putImageData()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.putImageData(imageData, dx, dy) \nили \nvoid ctx.putImageData(imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) \nили \nvoid ctx.putImageData(context, imageData, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) \nотрисовывает на холсте данные, взятые из объекта ImageData. Если указаны данные прямоугольника dirty, будут отрисованы только входящие в него пиксели, так что dirtyX и dirtyY - начало (левый верхний угол) выбранной части ImageData (по умолчанию 0), а dirtyWidth и dirtyHeight - его ширина и высота (по умолчанию равны ширине и высоте всего ImageData). Параметры dx, dy - начальные координаты, от которых надо отрисовывать прямоугольник с данными. На метод не влияет матрица изменений холста. Получить данные из холста можно методом .getImageData(). Исключение NotSupportedError будет выброшено, если хоть одно из значений бесконечно (некоторые движки игнорируют ошибку без выброса исключения). В некоторых движках разрешена реализация только синтаксиса с 3 или 7 параметрами, иначе будет выброшена ошибка. Исключение ImvalidStateError - если объект ImageData недостижим. Данные из отрисовываемого на холст объекта и затем взятые с холста могут отличаться из-за оптимизации браузером (неиспользуемых) данных альфа-канала. \nconst canvas = document.createElement(\"canvas\");\ncanvas.width = 1;\ncanvas.height = 1;\nconst context = canvas.getContext(\"2d\");\nconst imgData = context.getImageData(0, 0, canvas.width, canvas.height);\nconst pixels = imgData.data;\npixels[0 + 0] = 1;\npixels[0 + 1] = 127;\npixels[0 + 2] = 255;\npixels[0 + 3] = 1;\nconsole.log(\"before:\", pixels);\ncontext.putImageData(imgData, 0, 0);\nconst imgData2 = context.getImageData(0, 0, canvas.width, canvas.height);\nconst pixels2 = imgData2.data;\nconsole.log(\"after:\", pixels2);\n//before: Uint8ClampedArray(4) [ 1, 127, 255, 1 ]\n//after: Uint8ClampedArray(4) [ 255, 255, 255, 1 ]",
          "id": 10.5
        },
        {
          "name": "CanvasRenderingContext2D.quadraticCurveTo()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.quadraticCurveTo(cpx, cpy, x, y) \nдобавляет квадратичную кривую Безье к текущему под-пути. Требует указания двух точек: контрольной точки и второй - конечной. Стартовой точкой станет последняя опорная точка под-пути, которую можно изменить методом .moveTo(). ",
          "id": 10.51
        },
        {
          "name": "CanvasRenderingContext2D.rect()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.rect(x, y, width, height) \nдобавляет прямоугольник к текущему под-пути. По-сути, отрисовывает путь в виде прямоугольника. Ничего не отрисовывает напрямую, как и другие path-методы. Для отрисовки используйте .fill() или .stroke(). Отрицательные значения высоты или ширины \"потянут\" прямоугольник вверх или влево относительно начала его координат. ",
          "id": 10.52
        },
        {
          "name": "CanvasRenderingContext2D.resetTransform()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.resetTransform()\n\"обнуляет\" текущую матрицу преобразований до идентификационной матрицы (identity matrix). Нужно вызывать этот метод каждый раз, как вы закончили с преобразованиями и приступаете к рисованию чего-либо еще. В качестве аналога и полифилла в неподдерживаемых (IE) браузерах можно использовать метод .setTransform(1, 0, 0, 1, 0, 0).",
          "id": 10.53
        },
        {
          "name": "CanvasRenderingContext2D.restore()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.restore() \nвосстанавливает самое позднее сохранение состояния холста, доставая его (popping) из стека. Т.е. раз за разом мы достаем более раннее сохранение. Если в стеке нет сохраненного состояния, метод не делает ничего. Состояние состоит из: текущей матрицы примененных изменений (перемещение, сращение, масштабирование...), текущей вырезанной области, текущего списка набросков и текущих значений атрибутов strokeStyle, fillStyle, globalAlpha и т.д. Часто используется для сохранения \"дефольных\" значений стиля, которые потом можно применять, восстановив состояние.",
          "id": 10.54
        },
        {
          "name": "CanvasRenderingContext2D.rotate() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.rotate(angle) \nдобавляет поворот холста по часовой стрелке относительно его начала координат к матрице преобразований. angle - угол поворота в радианах (значение в радианах = градусы * (Math.PI / 180)). Центр поворота - всегда начало координат. Для его смещения нужен сдвиг холста методом .translate(). Напримем, для поворота фигуры вокруг своей оси нужно сдвинуть холст, чтобы начало его координат совпадало с центром фигуры. ",
          "id": 10.55
        },
        {
          "name": "CanvasRenderingContext2D.save()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.save() \nсохраняет текущее общее состояние холста, помещая (push) его в стек. Состояние состоит из: текущей матрицы изменений  (перемещение, сращение, масштабирование...), текущей вырезанной области, текущего списка набросков и текущих значений атрибутов strokeStyle, fillStyle, globalAlpha и т.д. Часто используется для сохранения \"дефольных\" значений стиля, которые потом можно применять, восстановив состояние (метод .restore()). ",
          "id": 10.56
        },
        {
          "name": "CanvasRenderingContext2D.scale() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.scale(x. y) \nприменяет к холсту изменение масштаба по горизонтали и/или вертикали. Разрешение холста (по умолчанию 1px) этот метод меняет разрешение соответственно указанному значению с плавающей запятой (2.0 увеличит в 2 раза, 0.5 уменьшит в 2 раза, отрицательные значения для x повернут ось в обратном направлении, для y - тоже). ",
          "id": 10.57
        },
        {
          "name": "CanvasRenderingContext2D.scrollPathIntoView() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "пока еще экспериментальный метод с очень плохой поддержкой. Делает видимым (оконтуривает) текущий или указываемый путь. Похож на Element.scrollIntoView() и отрисовывающий фокусировочные кольца .drawFocusIfNeeded(). Синтаксис - \nvoid ctx.scrollPathIntoView() \nили \nvoid ctx.scrollPathIntoView(path).",
          "id": 10.58
        },
        {
          "name": "CanvasRenderingContext2D.setLineDash() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nctx.setLineDash([segments]) \nустанавливает шаблон штриховой линии. Он использует массив (segments) из устанавливающих длину штриха и расстояние между ними значений. Если число нечетное, элементы массива копируются и объединяются в один сдвоенный ([размер, расстояние, размер] нужно дорастить до [размер, расстояние, размер, расстояние (размер), размер (расстояние), расстояние (размер)]. Для возврата к отрисовке сплошной линии обнулите массив. Возвращает undefined. ",
          "id": 10.59
        },
        {
          "name": "CanvasRenderingContext2D.setTransform() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод, обнуляющий (перезаписывающий) текущую матрицу преобразований и затем вызывающий метод .transform() с описанными в аргументах преобразованиями. Синтаксис ctx.setTransform(a, b, c, d, e, f) \nили \nctx.setTransform(matrix)\nБолее старая версия метода принимает параметры a - f: a - горизонтальное (х) масштабирование (scale, 1 - тот же масштаб), b -  вертикальный наклон (skew), c - горизонтальный наклон, d - вертикальное (у) масштабирование (1 - тот же масштаб), e - перемещение (translate) по горизонтали, f - перемещение по вертикали. Обновленный метод принимает один параметр - матрицу 2-D-преобразований (это объект DOMMAtrix или, технически, любой объект, содержащий указанные выше данные как свойства). Объект можно получить (.getTransform()) от одного холста и применить все указанные в нем преобразования на другом холсте.",
          "id": 10.6
        },
        {
          "name": "CanvasRenderingContext2D.shadowBlur ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, определяющее степень размытия тени. Значение - число с плавающей запятой, отрицательные значения Infinity и NaN игнорируются. По умолчанию - 0. Тени отрисовываются только тогда, когда свойство .shadowColor \nимеет значение непрозрачности. Значения свойств \n.shadowBlur, .shadowOffsetX и .shadowOffsetY также должны иметь ненулевые значения. ",
          "id": 10.61
        },
        {
          "name": "CanvasRenderingContext2D.shadowColor",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, задающее цвет тени. По умолчанию - полностью прозрачный черный. Имейте в виду, что на прозрачность рисуемой тени влияет прозрачность цвета в свойстве \n.fillStyle при заливке и .strokeStyle при отрисовке контура (т.е. цвет заливки и контура фигур). Тени отрисовываются только тогда, когда свойство .shadowColor имеет значение непрозрачности. Значения свойств .shadowBlur, .shadowOffsetX и .shadowOffsetY также должны иметь ненулевые значения. Значение - строка с валидным значением CSS-цвета. ",
          "id": 10.62
        },
        {
          "name": "CanvasRenderingContext2D.shadowOffsetX",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, определяющее распространение тени по горизонтали (оси x). Тени отрисовываются только тогда, когда свойство .shadowColor имеет значение непрозрачности. Значения свойств .shadowBlur, .shadowOffsetX и \n.shadowOffsetY также должны иметь ненулевые значения. Значение свойства - число с плавающей точкой, задающее длину тени, положительные значения \"тянут\" тень вправо, отрицательные - влево. Значение по умолчанию - 0. Infinity и NaN игнорируются.  ",
          "id": 10.63
        },
        {
          "name": "CanvasRenderingContext2D.shadowOffsetY",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, определяющее распространение тени по вертикали (оси y). Тени отрисовываются только тогда, когда свойство .shadowColor имеет значение непрозрачности. Значения свойств .shadowBlur, .shadowOffsetX и \n.shadowOffsetY также должны иметь ненулевые значения. Значение свойства - число с плавающей точкой, задающее длину тени, положительные значения \"тянут\" тень вниз, отрицательные - вверх. Значение по умолчанию - 0. Infinity и NaN игнорируются.    ",
          "id": 10.64
        },
        {
          "name": "CanvasRenderingContext2D.stroke()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "отрисовывает контур текущего \nvoid ctx.stroke() \nили заданного пути\nvoid ctx.stroke(path)\nгде path - сохраненный путь, не поддерживается в IE) пути в соответствии с заданным в свойстве .strokeStyle стилем контура. Линия отрисовываетсся относительно центральной линии пути - т.е. ее края идут на одном расстоянии от центра. Если не задать новое начало пути, на новых его этапах будет \"накладываться\" стиль предыдущего этапа (если он, конечно, меняется). Иногда это используют, создавая нужный рисунок линий и т.п. Если применять к пути и отрисовку контура и заливку (.fill()), то на результат будут влиять порядок применения этих методов. ",
          "id": 10.65
        },
        {
          "name": "CanvasRenderingContext2D.strokeRect()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "один из трех методов рисования прямоугольников, в синтаксисе \nvoid ctx.strokeRect(x, y, width, height) \nрисует контурный прямоугольник в соответствии с текущим значением свойства \nCanvasRenderingContext2D.strokeStyle и других настроек контекста. Метод рисует прямо в canvas без изменения существующего контура, так что вызов впоследствии любых методов вроде .fill() или .stroke() не возымеет эффекта на фигуру. Метод рисует прямоугольник, начиная в точке с координатами x, y с установленными шириной и высотой. Позитивные значения ширины распространят прямоугольник вправо, отрицательные - влево. Позитивные значения высоты распространят его вниз, отрицательные - вверх относительно начала его координат. ",
          "id": 10.66
        },
        {
          "name": "CanvasRenderingContext2D.strokeStyle",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, устанавливающее цвет, градиент или паттерн для отрисовки контуров фигур. По умолчанию - черный цвет #000. Устанавливаемое значение - строка, обозначение цвета, принятое в CSS (rgb, rgba, hsl, ключевые слова и т.д.), объект CanvasGradient (возвращается методами \nCanvasRenderingContext2D.createLinearGradient(), CanvasRenderingContext2D.createConicGradient() или CanvasRenderingContext2D.createRadialGradient(), также может использоваться в свойстве .strokeStyle) или объект \nCanvasPattern (паттерн, основанный на изображении, канвасе или видео, созданный при помощи \nCanvasRenderingContext2D.createPattern(), также может использоваться в .strokeStyle). ",
          "id": 10.67
        },
        {
          "name": "CanvasRenderingContext2D.strokeText()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.strokeText(text, x, y, maxWidth) \nотрисовывает контур текстовой строки в указанных координатах в соответствии со свойством .strokeStyle. Необязательный параметр maxWidth устанавливает максимальную ширину текста, которую пользовательский агент должен обеспечить при помощи сжатия текста (кернинг) или уменьшения его размера. Рисует напрямую в холст, так что не изменяет текущего пути и на отрисовку не влияют последующие вызовы fill() или stroke(). Текст отрисовывается в соответствии со значениями свойств .font, .textAlign, .textBaseLine и .direction. \nВозвращает undefined. Рекомендуется отдавать предпочтение методу отрисовки текста с заливкой .fillText().",
          "id": 10.68
        },
        {
          "name": "CanvasRenderingContext2D.textAlign",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, определяющее как должен выравниваться отрисовываемый текст относительно начальных координат его отрисовки (позиция x). Возможные значения: \"left\", right\", \"center\", \"start\" (значение по умолчанию, обычное выравнивание по левому краю для языков слева направо и по правому краю для языков, пишущихся справа налево) и \"end\" (наоборот). ",
          "id": 10.69
        },
        {
          "name": "CanvasRenderingContext2D.textBaseLine",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "property",
          "description": "свойство, устанавливающее текущее значение базовой линии отрисовываемого текста. Возможные значения: \"top\" (базовая линия - вершина прямоугольника em), \"hanging\" (\"висячая\" базовая линия - у тибетских, индийских языков), \"middle\" (базовая линия проходит по середине em), \"alphabetic\" (по умолчанию, базовая линия в своем нормальном положении), \"ideographic\" \n(идеографическая базовая линия, если у алфавитной линии некоторые выступающие части символов заходят ниже линии, то тут линия располагается еще ниже, на ней \"стоят\" самые низкорасположенные части символов - китайский, японский, корейский языки), \"bottom\" (базовая линия находится внизу прямоугольника em, отличается от идеографической линии тем, что идеографическая линия не учитывает подстрочные элементы). ",
          "id": 10.7
        },
        {
          "name": "CanvasRenderingContext2D.toBlob()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \ncanvas.toBlob(callback, type, quality) \nсоздает объект Blob, представляющий собой изображение, взятое с холста. Объект можно кэшировать или сохранять в памяти по усмотрению пользовательского агента. Изображение сохраняется в разрешении 96dpi. callback - колбэк-функция, результатом которой будет объект Blob, type - строка с нужным форматом (по умолчанию image/png, этот же формат будет использоваться, если указываемый не поддерживается), необязательный аргумент quality (не поддерживается в IE) - число от 0 до 1 - желаемое качество изображения в форматах со сжатием с потерей качества (jpeg, webp). Любые отличные от этого диапазона значения будут расценены и установлены в дефолтнst величины - 0.92 для jpeg и 0.80 для webp. Метод ничего не возвращает. При попытке сохранить изображение с другого источника без соответствующего параметра CORS crossorigin: \"anonymous\" будет выброшено исключение. Сниппет, позволяющий сохранять в Blob изображение с холста и присоединяющий это изображение \"в хвост\" документа:\nvar canvas = document.getElementById('canvas');\ncanvas.toBlob(function(blob) {\n  var newImg = document.createElement('img'),\n      url = URL.createObjectURL(blob);\n  newImg.onload = function() {\n    // no longer need to read the blob so it's revoked\n    URL.revokeObjectURL(url);\n  };\n  newImg.src = url;\n  document.body.appendChild(newImg);\n});\nВ Mozilla поддерживается метод, способный превратить blob-изображение в иконку:\nvar canvas = document.getElementById('canvas');\nvar d = canvas.width;\nctx = canvas.getContext('2d');\nctx.beginPath();\nctx.moveTo(d / 2, 0);\nctx.lineTo(d, d);\nctx.lineTo(0, d);\nctx.closePath();\nctx.fillStyle = 'yellow';\nctx.fill();\nfunction blobCallback(iconName) {\n  return function(b) {\n    var a = document.createElement('a');\n    a.textContent = 'Download';\n    document.body.appendChild(a);\n    a.style.display = 'block';\n    a.download = iconName + '.ico';\n    a.href = window.URL.createObjectURL(b);\n  }\n}\ncanvas.toBlob(blobCallback('passThisString'), 'image/vnd.microsoft.icon',\n              '-moz-parse-options:format=bmp;bpp=32');",
          "id": 10.71
        },
        {
          "name": "CanvasRenderingContext2D.toDataURL()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \ncanvas.toDataURL(type, encoderOptions) \nвозвращает строку DOMString c data URI, содержащий представление изображения в указанном в параметре type формате (по умолчанию PNG). Возвращаемое изображение будет в разрешении 96dpi. Если ширина и высота холста равны 0 или больше максимально возможных размеров холста, вернется пустая строка \"data:,\". Если требуемый формат - не PNG, но возвращенная строка начинается на data: image/png, значит установить требуемый формат у данного изображения невозможно. В Chrome также поддерживается формат webp. Необязательный аргумент encoderOptions - число от 0 до 1 - желаемое качество изображения в форматах со сжатием с потерей качества (jpeg, webp). Любые отличные от этого диапазона значения будут расценены и установлены в дефолтную величину - 0.92. Все остальные аргументы игнорируются. При попытке сохранить изображение с другого источника без соответствующего параметра CORS crossorigin: \"anonymous\" будет выброшено исключение, а холст заблокируется. Сохраненное изображение можно использовать в качестве источника для элемента <image> или, например, на него можно сделать ссылку для загрузки на диск. ",
          "id": 10.72
        },
        {
          "name": "CanvasRenderingContext2D.transform()",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод, применяющий сразу несколько преобразований, описанных в аргументах. Синтаксис - \nvoid ctx.transform(a, b, c, d, e, f)\na - горизонтальное (х) масштабирование (scale, 1 - тот же масштаб), b -  вертикальный наклон (skew), c - горизонтальный наклон, d - вертикальное (у) масштабирование (1 - тот же масштаб), e - перемещение (translate) по горизонтали, f - перемещение по вертикали.",
          "id": 10.73
        },
        {
          "name": "CanvasRenderingContext2D.translate() ",
          "classDeck": "card",
          "deck": "CanvasRenderingContext2D",
          "type": "method",
          "description": "метод в синтаксисе \nvoid ctx.translate(x, y) \nдобавляет к текущей матрице преобразований сдвиг холста на x единиц по горизонтали и y единиц по вертикали. Положительные значения x означают перемещение вправо, отрицательные - влево. Для y положительные значения сдвигают холст вниз, отрицательные - вверх. Для \"обнуления\" текущей матрицы (возвращаем холст на место) используется метод .setTransform() или (что быстрее, но сложнее работает в циклах) предварительно сохраняем и затем восстанавливаем состояние холста (.save()/.restore()).",
          "id": 10.74
        }
      ]
    },
    {
      "name": "ClipboardEvent",
      "classDeck": "deck",
      "deck": "ClipboardEvent",
      "type": "ClipboardEvent",
      "description": "экспериментальный интерфейс ClipboardEvent представляет события, связанные с изменениями буфера обмена, такими как cut, copy и paste. ",
      "objects": [
        {
          "name": "ClipboardEvent()",
          "classDeck": "card",
          "deck": "ClipboardEvent",
          "type": "constructor",
          "description": "в синтаксисе var clipboardevent = new ClipboardEvent(type, options) возвращает новосозданный экземпляр ClipboardEvent, представляющий событие, связанное с изменениями буфера обмена, такими как cut, copy, paste и clipboardchange. Наследует в числе прочих аргументы от интерфейса Event. Среди собственных аргументов: - type (регистрозависимая строка, наименование типа аргумента - 'copy', 'cut' или 'paste'), clipboardData (содержит экземпляр класса (Web-API интерфейса) DataTransfer (в нем хранятся перетаскиваемые при помощи Drag`n`drop данные, один или более объектов одного или более типов данных, объекты доступны из свойства dataTransfer всеч событий перетаскивания), dataType (строка, MIME-тип аргумента data), data (строка, содержащая данные касательно события буфера обмена). \n('text/plain', 'Hello, world!')",
          "id": 11.1
        },
        {
          "name": "ClipboardEvent.clipboardData",
          "classDeck": "card",
          "deck": "ClipboardEvent",
          "type": "property",
          "description": "хранит объект интерфейса DataTransfer, который может использоваться для установки данных, которые должны быть помещены в буфер обмена обработчиками событий cut или copy, обычно с вызовом setData(format, data) или для получения данных, которые будут вставлены обработчиком события paste, обычно с вызовом getData(format). Синтаксис - data = ClipboardEvent.clipboardData.",
          "id": 11.11
        }
      ],
      "id": 11
    },
    {
      "name": "UI Events",
      "classDeck": "deck",
      "deck": "UI Events",
      "type": "UI Events",
      "description": "",
      "objects": [
        {
          "name": "compositionend",
          "classDeck": "card",
          "deck": "UI Events",
          "type": "event",
          "description": "композиционное событие compositionend запускается, когда система создания текста, такая как редактор разных методов ввода (IME, китайский, японский и проч. языки), завершает или отменяет текущую сессию создания. Интерфейс: CompositionEvent, свойство-обработчик: нет, всплытие: да, отменяемость: да.",
          "id": 12.1
        },
        {
          "name": "compositionstart",
          "classDeck": "card",
          "deck": "UI Events",
          "type": "event",
          "description": "композиционное событие compositionstart запускается, когда система создания текста, такая как редактор разных методов ввода (IME, китайский, японский и проч. языки), начинает новую сессию создания. Интерфейс: CompositionEvent, свойство-обработчик: нет, всплытие: да, отменяемость: да.",
          "id": 12.11
        },
        {
          "name": "compositionupdate",
          "classDeck": "card",
          "deck": "UI Events",
          "type": "event",
          "description": "композиционное событие compositionupdate запускается, когда новый символ появляется в контексте сессии создания текста под контролем системы создания текста, такой как редактор разных методов ввода (IME). Интерфейс: CompositionEvent, свойство-обработчик: нет, всплытие: да, отменяемость: да.",
          "id": 12.12
        },
        {
          "name": "IUEvent.view",
          "classDeck": "card",
          "deck": "UI Events",
          "type": "property",
          "description": "свойство только для чтения, возвращающее объект WindowProxy, с которого был сгенерирован ивент. В браузерах это объект Window, в котором произошло событие. Синтаксис var view = event.view. view - ссылка на объект AbstractView. Стандарт устаревает.",
          "id": 12.13
        }
      ],
      "id": 12
    },
    {
      "name": "Crypto",
      "classDeck": "deck",
      "deck": "Crypto",
      "type": "Crypto",
      "description": "интерфейс, представляющий основные криптографические возможности, доступные в текущем контексте. Дает доступ к криптографически защищенному генератору случайных чисел и криптографическим примитивам. Возможность доступна в Web Workers. Доступ к API осуществляется через свойство Window.crypto, являющееся объектом Crypto. \nИзбегайте использования Web Crypto API в небезопасном контексте, даже если в нем представлен интерфейс Crypto, как это реализовано со свойством Window.crypto. Вдобавок к этому, метод getRandomValues() доступен в небезопасном контексте, но свойство subtle - нет.",
      "objects": [
        {
          "name": "Crypto.getRandomValues()",
          "classDeck": "card",
          "deck": "Crypto",
          "type": "method",
          "description": "единственный метод,Crypto, доступный в небезопасном контексте. Синтаксис - \ntypedArray = cryptoObj.getRandomValues(typedArray)\nгде typedArray - основанный на целых числах типизированный массив, это может быть Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array или Uint32Array. Все элементы в массиве перезаписываются на случайные числа. Метод возвращает тот же массив, но уже с замененными, обновленными случайными значениями. Копия (старого массива) не сохраняется. Может быть выброшено исключение при превышении длины массива в 65,536 байт. Не используйте этот метод для генерации криптоключей, лучше используйте SubtleCrypto.generateKey(). Для этого есть несколько причин: например, не гарантируется работа метода .getRandomValues() в безопасном контексте. \nСпецификация не указывает никаких ограничений в применяемом уровне энтропии. Пользовательские агенты предоставляют тот уровень, что могут предоставить при генерации случайных чисел хорошо настроенным собственным генератором, но зерно \"случайности\" берется из внешнего источника псевдослучайных чисел, таких как внутриплатформенные функции случайных чисел, /dev/urandom устройства в Unix или других источников псевдослучайных данных. \nvar array = new Uint32Array(10);\nwindow.crypto.getRandomValues(array);\nconsole.log(\"Your lucky numbers:\");\nfor (var i = 0; i < array.length; i++) {\n  console.log(array[i]);\n}",
          "id": 13.1
        },
        {
          "name": "Crypto.subtle",
          "classDeck": "card",
          "deck": "Crypto",
          "type": "property",
          "description": "свойство только для чтения, возвращаюшее объект SubtleCrypto, используемый для выполнения низкоуровневых криптографических операций (для взаимодействия с возможностями Web Crypto API). Синтаксис - \nvar crypto = crypto.subtle",
          "id": 13.11
        }
      ],
      "id": 13
    },
    {
      "name": "CryptoKey",
      "classDeck": "deck",
      "deck": "CryptoKey",
      "type": "CryptoKey",
      "description": "CryptoKey - интерфейс Web Crypto API, представляющий собой криптографический ключ, получаемый одним из методов интерфейса SubtleCrypto - .generateKey(), .deriveKey(), .importKey() или .unwrapKey(). По причинам безопасности может использоваться только в безопасном контексте. ",
      "objects": [
        {
          "name": "CryptoKey.algorithm",
          "classDeck": "card",
          "deck": "CryptoKey",
          "type": "property",
          "description": "объект, описывающий алгоритм, для которого используется данный ключ и любые ассоциированные с этим алгоритмом параметры. Объект AesKeyGenParams для любого из алгоритмов семейства AES, RsaHashedKeyGenParams - для разновидностей алгоритма RSA, EcKeyGenParams для разновидностей алгоритма EC, HmacKeyGenParams - для алгоритма HMAC. ",
          "id": 14.1
        },
        {
          "name": "CryptoKey.extractable",
          "classDeck": "card",
          "deck": "CryptoKey",
          "type": "property",
          "description": "булево свойство, показывающее, является ли этот ключ извлекаемым при помощи SubtleCrypto.exportKey() или \nSubtleCrypto.wrapKey(). Если нет, при попытке обработать его этими методами будет выброшено исключение.",
          "id": 14.11
        },
        {
          "name": "CryptoKey.type",
          "classDeck": "card",
          "deck": "CryptoKey",
          "type": "property",
          "description": "строка, имеющая одно из следующих значений: \"secret\" - этот ключ является секретным для использования в симметричных алгоритмах; \"private\" - этот ключ является приватной частью пары CryptoKeyPair у ассиметричных алгоритмов; \"public\" - этот ключ является открытой частью пары CryptoKeyPair у ассиметричных алгоритмов",
          "id": 14.12
        },
        {
          "name": "CryptoKey.usages",
          "classDeck": "card",
          "deck": "CryptoKey",
          "type": "property",
          "description": "массив строк, демонстрирующий, что можно делать с этим ключом. Возможные значения элементов массива: encrypt - ключ можно использовать для расшифровки сообщений, decrypt - для их зашифровки, sign - ключ можно использовать для подписи сообщений, verify - для проверки подписи, deriveKey - ключ можно использовать для получения другого ключа (метод SubtleCrypto.deriveKey()), deriveBits - ключ можно использовать для получения массива битов (метод SubtleCrypto.deriveBits()), wrapKey - ключ можно \nиспользовать для упаковки ключа (метод \nSubtleCrypto.wrapKey()), unwrapKey - ключ можно использовать для распаковки ключа (метод SubtleCrypto.unwrapKey()). \nИнтерфейс не поддерживается в IE и Safari.",
          "id": 14.13
        }
      ],
      "id": 14
    },
    {
      "name": "CSSStyleDeclaration",
      "classDeck": "deck",
      "deck": "CSSStyleDeclaration",
      "type": "CSSStyleDeclaration",
      "description": "интерфейс, представляющий собой объект-блок объявлений CSS с информацией о стилях и свойствах элемента. Может быть представлен с помощью трех различных API: через HTMLElement.style, CSSStyleSheets[x].cssRules[x].style (возвращает объект для х-правила в х-таблице стилей) и Window.getComputedStyle().",
      "objects": [
        {
          "name": "CSSStyleDeclaration.getPropertyPriority()",
          "classDeck": "card",
          "deck": "CSSStyleDeclaration",
          "type": "method",
          "description": "в синтаксисе \nlet priority = style.getPropertyPriority(property) \nвернет DOMString, содержащую все флаги (например, !important), установленные у свойства property. \nvar isImportant = declaration.getPropertyPriority('margin') === 'important';",
          "id": 15.1
        },
        {
          "name": "CSSStyleDeclaration.getPropertyValue()",
          "classDeck": "card",
          "deck": "CSSStyleDeclaration",
          "type": "method",
          "description": "в синтаксисе \nlet value = style.getPropertyValue(property) возвращает DOMString - значение свойства property.",
          "id": 15.11
        },
        {
          "name": "CSSStyleDeclaration.item()",
          "classDeck": "card",
          "deck": "CSSStyleDeclaration",
          "type": "method",
          "description": "в синтаксисе let propertyName = style.item(index) возвращает имя CSS-свойства по его индексу. Не выбросит никакх исключений, пока указываются аргументы. Если индекс выходит за пределы, вернется пустая строка, при отсутствии аргумента выбросит TypeError. Есть более простой способ получения имени свойства: let propertyName = style[index]. ",
          "id": 15.12
        },
        {
          "name": "CSSStyleDeclaration.removeProperty()",
          "classDeck": "card",
          "deck": "CSSStyleDeclaration",
          "type": "method",
          "description": "в синтаксисе \nlet oldValue = style.removeProperty(propertyName) удаляет свойство propertyName из объекта объявленных CSS-стилей.\nvar declaration = document.styleSheets[0].rules[0].style;\nvar oldValue = declaration.removeProperty('background-color');   \nПри попытке удалить свойство \"только для чтения\" выбросит NO_MODIFICATION_ALLOWED_ERR",
          "id": 15.13
        },
        {
          "name": "CSSStyleDeclaration.setProperty()",
          "classDeck": "card",
          "deck": "CSSStyleDeclaration",
          "type": "method",
          "description": "в синтаксисе \nstyle.setProperty(propertyName, value, priority) \nустанавливает новое значение value у свойства propertyName в объекте объявленных CSS-свойств. Атрибут priority - возможность установки флага \"important\". Более простой и удобный вариант установки нового значения у свойства - style.cssPropertyName = \"value\"",
          "id": 15.14
        }
      ],
      "id": 15
    },
    {
      "name": "Date",
      "classDeck": "deck",
      "deck": "Date",
      "type": "Date",
      "description": "объекты Date представляют один момент времени в платформенно-независимом формате. Объекты Date содержат числовой тип (Number), представляющий собой количество прошедших с 1 января 1970 года по Гринвичу миллисекунд. Важно помнить, что в то время как в основе Date-объектов значение времени по UTC, все их основные методы работают по локальному часовому поясу с соответствующим ему смещением. Отсюда - добавленные методы с установкой и запросами компонентов дат по Гринвичу. Стоит также отметить, что максимально допустимая дата - это не Number.MAX_SAFE_INTEGER, а +-100 миллионов дней относительно начала эпохи Unix.",
      "objects": [
        {
          "name": "Date()",
          "classDeck": "card",
          "deck": "Date",
          "type": "constructor",
          "description": "конструктор, создающий экземпляр объекта Date, представляющий момент времени в платформенно-независимом формате. Объект Date содержит число (Number), представляющее собой количество миллисекунд с 1 января 1970 по Гринвичу. При этом, созданные для одного и того же момента времени объекты не равны друг другу.\nconst date1 = new Date('December 17, 1995 03:24:00');// Sun Dec 17 1995 03:24:00 GMT...\nconst date2 = new Date('1995-12-17T03:24:00');// Sun Dec 17 1995 03:24:00 GMT...\nconsole.log(date1 === date2);// false;\nconsole.log(date1 - date2);// 0\nПравильное создание - только с оператором new. Без него вернется не объект, а строка. Синтаксис - \nnew Date() - вызов конструктора без параметров создаст новый объект Date, представляющий текущую дату и время, когда он был создан.\nnew Date(value) - вызов с параметром - целым числом value, представляющим timestamp - количество миллисекунд с начала эпохи Unix (1 января 1970 UTC), разница в секундах будет проигнорирована (все функции, работающие с timestamp, имеют точность с округлением до ближайшей секунды). \nnew Date(dateString) - dateString - строка, представляющая дату в формате, понятном методу Date.parse(). Как конструктор в таком синтаксисе, так и сам метод крайне не рекомендуются к использованию из-за различий и противоречий в браузерных реализациях. \nnew Date(year, month, day, hours, minutes, seconds, milliseconds) - создает объект на основе всех предоставленных данных в виде чисел. Обязательные параметры - только year и month. Пропуск параметра устанавливает для относящегося к нему компонента даты наименьшее значение (1 для day и 0 для всех остальных параметров). Все параметры расцениваются по локальному времени, не UTC. year - двузначное число от 0 до 99 для 1900-1999гг. и 4-значное для всех остальных дат. month - число от 0 до 11. day - день месяца, от 1 (по умолчанию) до 31. hours - часы, по умолчанию 0 (полночь). minutes - минуты, по умолчанию 0 (в начале часа)...\nlet today = new Date();\nlet birthday = new Date('December 17, 1995 03:24:00');\nlet birthday = new Date('1995-12-17T03:24:00');\nlet birthday = new Date(1995, 11, 17); // the month is 0-indexed\nlet birthday = new Date(1995, 11, 17, 3, 24, 0);",
          "id": 16.1
        },
        {
          "name": "Date.now()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "статический метод в синтаксисе \nvar rightNow = Date.now() \nвозвращает timestamp, количество миллисекунд, прошедших с 1 января 1970. В целях безопасности, для защиты от фингерпринтинга (fingerprinting - получение \"цифрового отпечатка\" клиентского устройства для его идентификации и отслеживания), точность Date.now() может округляться в зависимости от настроек браузера. У Firefox глобальный параметр privacy.reduceTimerPrecision включен по умолчанию и его дефолтное значение - 2ms. Также вы можете включить опцию privacy.resistFingerprinting, точность значений будет 100ms. ",
          "id": 16.11
        },
        {
          "name": "Date.parse()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "статический метод в синтаксисе \nDate.parse(dateString) (прямой вызов) \nили \nnew Date(dateString) (неявный вызов) \nпарсит строку, представляющую дату, и возвращает timestamp или NaN, если строка нераспознана или, в некоторых случаях, имеет неправильные значения даты (например, 2015-02-31). Не рекомендуется использовать Date.parse() в стандарте до ES5, т.к. тогда он зависел исключительно от реализации. Сейчас также существует ряд отличий, в зависимости от окружения работы метода, так что лучше парсить строки с датами вручную (может помочь библиотека, работающая с разными форматами дат). Строка должна быть в формате ISO-8601: '\"yyyy-mm-dd\", \"yyyy-mm-ddThh:mm:ss\" или \"yyyy-mm-ddThh:mm:ss.msmsms+09:00\" (месяцы - от 0 до 11, если часовой пояс пропущен, время считается UTC). ",
          "id": 16.12
        },
        {
          "name": "Date.prototype.getDate()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getDate() \nвозвращает день в месяце указанной даты (число от 1 до 31) в соответствии с местным временем. \nvar Xmas95 = new Date('December 25, 1995 23:15:30');\nvar day = Xmas95.getDate();\nconsole.log(day); // 25",
          "id": 16.13
        },
        {
          "name": "Date.prototype.getDay() ",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getDay() \nвозвращает день недели установленной даты date по местному времени, где отсчет начинается с 0 (воскресенье) и до 6 (суббота). \nvar Xmas95 = new Date('December 25, 1995 23:15:30');\nvar weekday = Xmas95.getDay();\nconsole.log(weekday); // 1\nДля получения именно названия дня, а не числа, используйте метод Intl.DateTimeFormat(). \nvar options = { weekday: 'long'};\nconsole.log(new Intl.DateTimeFormat('en-US', options).format(Xmas95));// Monday\nconsole.log(new Intl.DateTimeFormat('de-DE', options).format(Xmas95));// Montag",
          "id": 16.14
        },
        {
          "name": "Date.prototype.getFullYear()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getFullYear() \nвозвращает год из указанной в объекте date даты по местному времени. Метод был введен для решения проблемы \"2000\", так что используйте его вместо устаревшего .getYear(), особенно для дат после 2000г. Возвращает 4-значное число от 1000 до 9999.\nvar today = new Date();\nvar year = today.getFullYear();\nalert(year);// 2021",
          "id": 16.15
        },
        {
          "name": "Date.prototype.getHours()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getHours() \nвозвращает часы указанной в объекте date даты по местному времени - целое число от 0 до 23. \nlet Xmas95 = new Date('December 25, 1995 23:15:30');\nlet hours = Xmas95.getHours();\nconsole.log(hours); // 23",
          "id": 16.16
        },
        {
          "name": "Date.prototype.getMilliseconds()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getMilliseconds() \nвозвращает миллисекунды приведенной в объекте date даты по местному времени - число от 0 до 999.",
          "id": 16.17
        },
        {
          "name": "Date.prototype.getMinutes()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getMinutes() \nвозвращает минуты указанного временного объекта date по местному времени - число от 0 до 59. \nvar Xmas95 = new Date('December 25, 1995 23:15:30');\nvar minutes = Xmas95.getMinutes();\nconsole.log(minutes); // 15",
          "id": 16.18
        },
        {
          "name": "Date.prototype.getMonth()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе\ndate.getMonth() \nвозвращает месяц объекта даты date по местному времени на основе отсчета от 0 (0 - январь, 11 - декабрь). \nvar Xmas95 = new Date('December 25, 1995 23:15:30');\nvar month = Xmas95.getMonth();\nconsole.log(month); // 11\nДля получения именно названия месяца и даже на определенном языке используйте Intl.DateTimeFormat(). ",
          "id": 16.19
        },
        {
          "name": "Date.prototype.getSeconds()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getSeconds() \nвозвращает секунды объекта времени date по местному времени.\nconst moonLanding = new Date('July 20, 69 00:20:18');\nconsole.log(moonLanding.getSeconds());// 18",
          "id": 16.2
        },
        {
          "name": "Date.prototype.getTime()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getTime() \nвозвращает timestamp. Метод всегда работает по UTC. Метод, запущенный на двух разных клиентах в разных часовых поясах, покажет разный результат. Вы можете использовать его, чтобы помочь переприсвоить значения даты и времени другому объекту Date. Функционально метод похож на Date.prototype.valueOf(). \nvar birthday = new Date(1994, 12, 10);\nvar copy = new Date();\ncopy.setTime(birthday.getTime());\nТакже можно применять при вычислении временной разницы между двумя объектами Date, с использованием третьего объекта. Например, для вычисления времени, потраченного на определенную операцию.\nvar end, start;\nstart = new Date();\nfor (var i = 0; i < 1000; i++) {\n  Math.sqrt(i);\n}\nend = new Date();\nconsole.log('Operation took ' + (end.getTime() - start.getTime()) + ' msec');",
          "id": 16.21
        },
        {
          "name": "Date.prototype.getTimezoneOffset()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getTimezoneOffset() \nвозвращает разничу часовых поясов между местным временем (не конкретным объектом Date, а именно временем ОС среды) и UTC в минутах. В поясах до Гринвича это отрицательные значения, после - положительные. Если система сконфигурирована учитывать переход на летнее время, он будет учитываться методом также. \nconst date1 = new Date('August 19, 1975 23:15:30 GMT+07:00');\nconst date2 = new Date('August 19, 1975 23:15:30 GMT-02:00');\nconsole.log(date1.getTimezoneOffset());// expected output: your local timezone offset in minutes, (eg -120). NOT the timezone offset of the date object.\nconsole.log(date1.getTimezoneOffset() === date2.getTimezoneOffset());// true",
          "id": 16.22
        },
        {
          "name": "Date.prototype.getUTCDate()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getUTCDate() \nвозвращает день в месяце указанной даты date (число от 1 до 31) по Гринвичу (UTC) (метод Date.prototype.getDate() возвращает день по местному времени).",
          "id": 16.23
        },
        {
          "name": "Date.prototype.getUTCDay()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getUTCDay() \nвозвращает день недели установленной даты date по Гринвичу (UTC), где отсчет начинается с 0 (воскресенье) и до 6 (суббота). Метод Date.prototype.getDay() возвращает ден недели по местному времени.",
          "id": 16.24
        },
        {
          "name": "Date.prototype.getUTCFullYear()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getUTCFullYear() \nвозвращает год установленной в объекте date даты по всемирному времени (UTC). Метод Date.prototype.getFullYear() возвращает год по местному времени.",
          "id": 16.25
        },
        {
          "name": "Date.prototype.getUTCHours()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getUTCHours() \nвозвращает часы объекта date по Гринвичу (метод Date.prototype.getHours() возвращает часы по местному времени). Число от 0 до 23.",
          "id": 16.26
        },
        {
          "name": "Date.prototype.getUTCMilliseconds()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getUTCMilliseconds() \nвозвращает миллисекунды установленного в объекте date времени по Гринвичу (UTC). Число от 0 до 999. Метод Date.prototype.getMilliseconds() возвращает миллисекунды по местному времени.",
          "id": 16.27
        },
        {
          "name": "Date.prototype.getUTCMinutes()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getUTCMinutes() \nвозвращает минуты времени объекта Date (Date.prototype.getMinutes() возвращает минуты по местному времени). ",
          "id": 16.28
        },
        {
          "name": "Date.prototype.getUTCMonth()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getUTCMonth() \nвозвращает месяц даты объекта Date по Гринвичу (UTC) (метод Date.prototype.getMonth() возвращает месяц по местному времени). Отсчет идет с 0, 0 - январь, 11 - декабрь.",
          "id": 16.29
        },
        {
          "name": "Date.prototype.getUTCSeconds()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.getUTCSeconds() \nвозвращает секунды даты Date по всемирному (UTC) времени (метод Date.prototype.getSeconds() возвращает секунды по местному времени). ",
          "id": 16.3
        },
        {
          "name": "Date.prototype.setDate() ",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setDate(dayValue) \nустанавливает у объекта date день месяца dayValue (число от 1 до 31). Возвращает timestamp измененного объекта (он изменяется на месте). Возможны отрицательные значения и 0 (0 задаст последний день предыдущего месяца, -1 - предпоследний день предыдущего месяца и т.д.). Это же касается и значений больше 31.\nvar theBigDay = new Date(1962, 6, 7); // 1962-07-07 (7th of July 1962)\ntheBigDay.setDate(24);  // 1962-07-24 (24th of July 1962)\ntheBigDay.setDate(32);  // 1962-08-01 (1st of August 1962)",
          "id": 16.31
        },
        {
          "name": "Date.prototype.setFullYear() ",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setFullYear(yearValue, monthValue, dateValue) \nустанавливает год у объекта date по местному времени. Возвращает обновленный timestamp. Необязательные параметры monthValue (месяц от 0 до 11) и dateValue (день месяца от 1 до 31). Если указываете dateValue, параметр monthValue становится тоже обязательным. Если необязательные параметры не указываются, для их получения используются методы Date.prototype.getMonth() и \nDate.prototype.getDate(). При выходе значений параметров за пределы значений они будут высчитываться соответственно с изменением других параметров (например, указание 15-го месяца приведет к увеличению значения года на 1 и установит значением месяца 3). ",
          "id": 16.32
        },
        {
          "name": "Date.prototype.setHours()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setHours(hoursValue, minutesValue, secondsValue, msValue)\nустанавливает часы у объекта даты Date по местному времени и возвращает обновленный timestamp. hoursValue - единственный обязательный параметр - значение от 0 до 23, minutes - от 0 до 59 и т.д. Значения могут выходить за эти пределы и будут подсчитаны с влиянием на другие значения (например, 100 секунд прибавят одну минуту и установят значение 40 у секунд). Если указываете секунды, минуты тоже становятся обязательным параметром, если миллисекунды - обязательными становятся минуты и секунды. Если не приводятся необязательные параметры, их значения берутся из пременения методов Date.prototype.getMinutes(), Date.prototype.getSeconds() и Date.prototype.getMilliseconds().",
          "id": 16.33
        },
        {
          "name": "Date.prototype.setMilliseconds()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setMilliseconds(msValue) \nустанавливает значение миллисекунд msValue у объеатс даты date по местному времени (число от 0 до 999). Возвращает обновленный timestamp. При выходе значения за пределы, оно будет подсчитано с влиянием на другие значения. ",
          "id": 16.34
        },
        {
          "name": "Date.prototype.setMinutes()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setMinutes(minutesValue, secondsValue, msValue) \nустанавливает минуты у объекта даты date. Необязательные параметры - секунды и миллисекунды, если указываются миллисекунды, секунды тоже обязательны. Если необязательные параметры не приводятся, соответствующие данные берутся из методов Date.prototype.getSeconds() и Date.prototype.getMilliseconds(). Возвращает обновленный timestamp. Выходы за пределы значений высчитываются соответственно с влиянием на другие параметры.",
          "id": 16.35
        },
        {
          "name": "Date.prototype.setMonth()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setMonth(monthtValue, dateValue) \nустанавливает месяц у объекта даты date. Параметр dateValue необязателен. Выходы значений за свои пределы (0-11 и 1-31) высчитываются в соответствии с их воздействием на другие параметры. Если параметр dateValue не указывается, его значение будет взято из метода Date.prototype.getDate(). Текущий день месяца влияет на поведение метода. Теоретически метод добавит количество дней, соответствующее текущему дню месяца, к первому дню устанавливаемого месяца. Например, установка .setMonth(1) у даты 31 августа 2016 г. приведет к дате 2 марта (т.к. в том году в феврале было 29 дней). ",
          "id": 16.36
        },
        {
          "name": "Date.prototype.setSeconds()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setSeconds(secondsValue, msValue) \nустанавливает секунды у объекта даты date. Возвращает timestamp. Необязательный параметр msValue - миллисекунды. Если он не приводится, то берется из Date.prototype.getMilliseconds(). Превышение значений высчитывается с учетом влияния на другие параметры. ",
          "id": 16.37
        },
        {
          "name": "Date.prototype.setTime() ",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setTime(timeValue) \nустанавливает у объекта date время, соответствующее timestamp, указанному как параметр timeValue. Возвращает новый timestamp. Используется для присваивания известного времени другому объекту даты в связке с Date.prototype.getTime().\nvar theBigDay = new Date('July 1, 1999');\nvar sameAsBigDay = new Date();\nsameAsBigDay.setTime(theBigDay.getTime());",
          "id": 16.38
        },
        {
          "name": "Date.prototype.setUTCDate()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setUTCDate(dateValue) \nустанавливает у объекта даты date день месяца по всемирному времени (UTC). Значение - от 1 до 31. Выход за пределы значений влияет на другие параметры. Возвращает timestamp. ",
          "id": 16.39
        },
        {
          "name": "Date.prototype.setUTCFullYear()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setFullYear(yearValue, monthValue, dateValue) \nустанавливает у объекта date полный год по всемирному (UTC) времени. Необязательные параметры - месяц (monthValue, от 0 до 11) и день месяца (dateValue, от 1 до 31, если указан - параметр monthValue становится обязательным, если ни один из параметров не указан - их значения берутся из методов \nDate.prototype.getUTCMonth() и Date.prototype.getUTCDate()). Возвращает timestamp. Выход значений за свои пределы влияет на установку других (соседних) значений.",
          "id": 16.4
        },
        {
          "name": "Date.prototype.setUTCHours() ",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setUTCHours(hoursValue, minutesValue, secondsValue, msValue)\nустанавливает часы в объекте date по всемирному времени и возвращает (обновленный) timestamp. Параметры минут, секунд и миллисекунд необязательные, если указываются секунды - обязателен параметр с минутами, если миллисекунды - обязательны все остальные. Выход значений за свои пределы влияет на установку других (соседних) значений. Если параметры пропускаются, их значения берутся из соответствующих методов .getUTC...",
          "id": 16.41
        },
        {
          "name": "Date.prototype.setUTCMilliseconds()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setUTCMilliseconds(msValue) \nустанавливает у объекта date указанное количество миллисекунд по всемирному времени. Возвращает обновленный timestamp. Выход значения за пределы (0-999) повлияет на соседние значения.",
          "id": 16.42
        },
        {
          "name": "Date.prototype.setUTCMinutes()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setUTCMinutes(minutesValue, secondsValue, msValue) \nустанавливает у объекта date минуты по всемирному времени. Параметры секунд и миллисекунд необязательны, если указаны миллисекунды - секунды тоже обязательны. Выход за пределы значений влияет на соседние значения. Если необязательные параметры пропущены - их значения берутся из методов .getUTC... ",
          "id": 16.43
        },
        {
          "name": "Date.prototype.setUTCMonth()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе\ndate.setUTCMonth(monthValue, dateValue) \nустанавливает у объекта date месяц по всемирному времени. Параметр dateValue с установкой дня месяца (1-31) необязателен, иначе значение берется из Date.prototype.getUTCDate(). Возвращает обносленный timestamp. Выход значений за пределы влияет на соседние значения. ",
          "id": 16.44
        },
        {
          "name": "Date.prototype.setUTCSeconds()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.setUTCSeconds(secondsValue, msValue) \nустанавливает количество секунд у объекта date по Гринвичу. Параметр миллисекунд необязателен, если пропущен - берется из Date.prototype.getUTCMilliseconds(). Выход за пределы значений влияет на соседние значения. Возвращает обносленный timestamp.",
          "id": 16.45
        },
        {
          "name": "Date.prototype.toDateString()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.toDateString() \nвозвращает часть объекта date в \"человекочитаемом\" формате на английском в следующем виде (значения разделены пробелами): первые три буквы дня недели, певые три буквы названия месяца, две цифры дня месяца (с 0 впереди для дней с 1 по 9), четыре цифры года (с 0 впереди, если необходимо). \nvar d = new Date(1993, 5, 28, 14, 39, 7);\nconsole.log(d.toString());// Mon Jun 28 1993 14:39:07 GMT-0600 (PDT)\nconsole.log(d.toDateString()); // Mon Jun 28 1993\nПо сравнению с методом Date.prototype.toString() дает более короткую строку, когда этого достаточно. Полезен еще и тем, что .toString() часто реализован в разных движках по разному, представляя разную \"нарезку\" итоговой строки. ",
          "id": 16.46
        },
        {
          "name": "Date.prototype.toISOString()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.toISOString() \nвозвращает строку в упрощенном унифицированном формате ISO8601. Это всегда строка из 24 или 27 символов вида YYYY-MM-DDTHH:mm:ss.sssZ или +-YYYYYY-MM-DDTHH:mm:ss.sssZ. Часовой пояс всегда 0 (UTC), что и означает суффикс Z. \nlet today = new Date('05 October 2011 14:48 UTC');\nalert( today.toISOString() );// 2011-10-05T14:48:00.000Z",
          "id": 16.47
        },
        {
          "name": "Date.prototype.toJSON()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.toJSON() \nвозвращает строку, представляющую объект date. Метод разработан для возможности сериализации объектов Date в JSON. Он вызывает метод Date.prototype.toISOString() и возвращает строку, пригодную для использования в JSON.",
          "id": 16.48
        },
        {
          "name": "Date.prototype.toLocaleDateString()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.toLocaleDateString(locales, options) \nвозвращает строку с языкозависимым представлением части даты. Новые аргументы locales и options позволяют приложениям устанавливать язык, в соответствии с коротым будет вести себя функция. В старых реализациях эти аргументы игнорировались и локализация зависела от конкретной среды. Подробное описание параметров - в Intl.DateTimeFormat(). Значения по умолчанию у каждого компонента даты - undefined, но если день недели, год, месяц, день месяца все undefined, то год, месяц и день месяца расцениваются как числа. Для улучшения производительности, при форматировании большого числа дат, лучше создайте объект Intl.DateTimeFormat и используйте функцию его свойства format.\nvar date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));\nconsole.log(date.toLocaleDateString('en-US'));// → \"12/19/2012\"\nconsole.log(date.toLocaleDateString('en-GB'));// → \"20/12/2012\"\nconsole.log(date.toLocaleDateString('ko-KR'));// → \"2012. 12. 20.\"\nconsole.log(date.toLocaleDateString('fa-IR'));// → \"۱۳۹۱/۹/۳۰\"\nconsole.log(date.toLocaleDateString('ar-EG'));// → \"٢٠‏/١٢‏/٢٠١٢\"",
          "id": 16.49
        },
        {
          "name": "Date.prototype.toLocaleFormat()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "конвертирует дату в строку при помощи форматирующей строки",
          "id": 16.5
        },
        {
          "name": "Date.prototype.toLocaleString()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.toLocaleString(locales, options) \nвозвращает строку в языкозависимом формате, представляющую дату date. Новые аргументы locales и options позволяют приложениям устанавливать язык, в соответствии с коротым будет вести себя функция. В старых реализациях эти аргументы игнорировались и локализация зависела от конкретной среды. Подробное описание параметров - в Intl.DateTimeFormat(). Значения по умолчанию у каждого компонента даты - undefined, но если день недели, год, месяц, день месяца все undefined, то год, месяц и день месяца расцениваются как числа. \nlet date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));\nconsole.log(date.toLocaleString('en-US'));// → \"12/19/2012, 7:00:00 PM\"\nconsole.log(date.toLocaleString('en-GB'));// → \"20/12/2012 03:00:00\"\nconsole.log(date.toLocaleString('ko-KR'));// → \"2012. 12. 20. 오후 12:00:00\"",
          "id": 16.51
        },
        {
          "name": "Date.prototype.toLocaleTimeString()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.toLocaleTimeString(locales, options) \nвозвращает языкозависимую строку, представляющую временной компонент даты date. Новые аргументы locales и options позволяют приложениям устанавливать язык, в соответствии с коротым будет вести себя функция. В старых реализациях эти аргументы игнорировались и локализация зависела от конкретной среды. Подробное описание параметров - в Intl.DateTimeFormat(). Значения по умолчанию у каждого компонента даты - undefined, но если часы, минуты и секунды - все undefined, расцениваются они как числа. Для улучшения производительности, при форматировании большого числа дат, лучше создайте объект Intl.DateTimeFormat и используйте функцию его свойства format.\nvar date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0));\nconsole.log(date.toLocaleTimeString('en-US'));// → \"7:00:00 PM\"\nconsole.log(date.toLocaleTimeString('en-GB'));// → \"03:00:00\"\nconsole.log(date.toLocaleTimeString('ko-KR'));// → \"오후 12:00:00\"",
          "id": 16.52
        },
        {
          "name": "Date.prototype.toString()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.toString() \nвозвращает строку, представляющую объект даты date. Экземпляры Date наследуют метод toString() от Date.prototype, не от Object.prototype. Date.prototype.toString() вернет строку, представляющую объект Date в формате, установленном стандартом ECMA-262, который можно вкратце определить так:\n- День недели - 3 буквы английского названия дня, например, \"Sat\"\n- пробел\n- Месяц - 3 буквы английского названия месяца, например, \"Sep\"\n- пробел\n- День месяца - две цифры, например, \"02\"\n- пробел\n- Год - 4 цифры, например, \"2016\"\n- пробел\n- Час - 2 цифры, например, \"14\"\n- двоеточие\n- Минуты - 2 цифры, например, \"45\"\n- двоеточие\n- Секунды - 2 цифры, например \"26\"\n- пробел\n- строка \"GMT\"\n- Знак часового пояса, + или -\n- Часовой пояс в часах - 2 цифры, например \"14\"\n- Часовой пояс в минутах - 2 цифры, например \"00\"\n- Опционально - название часового пояса в скобках, аббревиатура или полное название, например, \"Line Islands Time\" (\"LINT\"). Точный вид зависит от конкретной реализации.\nИтого: \"Sat Sep 02 2016 14:45:26 GMT +1400 (LINT)\"\nМетод вызывается автоматически в случаях, когда дата представляется в виде строки - например, console.log(new Date()) или когда объект даты участвует в конкатенации - var today = \"today is\" + new Date(). Это общий метод, что значит, что его значением this не обязательно является объект Date. Тем не менее, он должен иметь внутреннее свойство [[TimeValue]], которое нельзя создать обычными средствами JavaScript, так что оно может использоваться  только в объектах Date. Если метод будет вызван не на объекте Date, выбросится исключение TypeError. \nlet date = new Date();\nlet string = date.toString();\nalert(string);// Fri Feb 26 2021 09:29:57 GMT+0300 (Москва, стандартное время)",
          "id": 16.53
        },
        {
          "name": "Date.prototype.toTimeString()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "метод в синтаксисе \ndate.toTimeString() \nвозвращает временной компонент даты date  вчеловекочитаемом формате на английском (в виде строки). \nvar d = new Date(1993, 6, 28, 14, 39, 7);\nconsole.log(d.toString());// Wed Jul 28 1993 14:39:07 GMT-0600 (PDT)\nconsole.log(d.toTimeString()); // 14:39:07 GMT-0600 (PDT)",
          "id": 16.54
        },
        {
          "name": "Date.prototype.toUTCString()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "внутренний метод в синтаксисе \ndate.toUTCString() \nконвертирует дату date в строку, используя часовой пояс Гринвича (UTC). Общий вид возвращаемой строки - Www, dd Mmm yyyy hh:mm:ss GMT\nlet date = new Date();\nlet string = date.toUTCString();\nalert(string);// Fri, 26 Feb 2021 06:41:15 GMT",
          "id": 16.55
        },
        {
          "name": "Date.prototype.valueOf()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "внутренний метод в синтаксисе \ndate.valueOf() \nвозвращает примитивное значение объекта date - timestamp. Является аналогом метода Date.prototype.getTime(). Обычно вызывается внутри JavaScript, но не прямо в коде. ",
          "id": 16.56
        },
        {
          "name": "Date.UTC()",
          "classDeck": "card",
          "deck": "Date",
          "type": "method",
          "description": "статический метод в синтаксисе \nDate.UTC(yyyy, mm, dd, hh, mnmn, ss, msmsms) \nработает похоже на конструктор Date(), но расценивает принимаемые параметры как UTC и возвращая timestamp, а не объект Date. Сейчас обязательным параметром является только год, до ES2017 обязательным параметром был еще и месяц. Для создания объекта по UTC используйте конструкцию\nlet utcDate = new Date(Date.UTC(2018, 11, 1, 0, 0, 0));",
          "id": 16.57
        }
      ],
      "id": 16
    },
    {
      "name": "Global functions",
      "classDeck": "deck",
      "deck": "Global functions",
      "type": "Global functions",
      "description": "",
      "objects": [
        {
          "name": "decodeURI()",
          "classDeck": "card",
          "deck": "Global functions",
          "type": "function",
          "description": "глобальная функция, декодирующая цельный URI, созданный при помощи encodeURI() или другим похожим способом.\ndecodeURI(URI)\nВозвращает строку, представляющую раскодированную версию данного URI. Выбросит исключение URIError (искаженная URI-последовательность), если раскодируемая строка содержит неверную последовательность символов. Не перекодирует # и некоторые другие знаки. \nconst encoded = encodeURI(uri);\nconsole.log(encoded);// \"https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\"\nconsole.log(decodeURI(encoded));// \"https://mozilla.org/?x=шеллы\"",
          "id": 17.1
        },
        {
          "name": "decodeURIComponent()",
          "classDeck": "card",
          "deck": "Global functions",
          "type": "function",
          "description": "глобальная функция в синтаксисе \ndecodeURIComponent(encodedURI) \nраскодирует часть (компонент) URI, созданный при помощи encodeURIComponent() или другим похожим способом. Возвращает строку, превращая каждую специальную последовательность символов в символы, которые могут быть отображены в строке. Для декодирования поискового компонента нужно применить заплатку:\nfunction decodeQueryParam(p) {\n  return decodeURIComponent(p.replace(/\\+/g, ' '));\n}\ndecodeQueryParam('search+query%20%28correct%29');// 'search query (correct)'",
          "id": 17.11
        },
        {
          "name": "encodeURI()",
          "classDeck": "card",
          "deck": "Global functions",
          "type": "function",
          "description": "функция кодирования всего URI целиком, методом замены каждого экземпляра конкретного знака в один, два, три или четыре экранированные последовательности, представляющих кодировку знака в UTF-8 (четыре последовательности кодируют знак, состоящий из двух суррогатных знаков). \nencodeURI(URI)\nВозвращает строку, представляющую собой кодированный URI. \nconst uri = 'https://mozilla.org/?x=шеллы';\nconst encoded = encodeURI(uri);\nconsole.log(encoded);// \"https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\"\nНе кодирует знаки, имеющие специальное значение (зарезервированные символы).\nБазируется на несколько устаревшем стандарте, заменяющем квадратные скобки в IPv6-адресах на escape-последовательности. Для соответствия более современному стандарту, предусматривающему кодирование применительно к IPv6 (с квадратными скобками), можно применить \"заплатку\":\nfunction fixedEncodeURI(str) {\n    return encodeURI(str).replace(/%5B/g, '[').replace(/%5D/g, ']');\n}\nИспользуйте эту функцию для кодирования вводимых пользователем данных в форму, отправляемую на сервер методом POST. Она правильно закодирует случайно добавляемые в данные символы & при формировании некоторых HTML-сущностей. Например, если пользовательнапишет Jack & Jill, текст может закодироваться как Jack &amp; Jill. В этом случае, если не применить encodeURIComponent(), сервер примет знак амперсанда за начало нового поля ввода.",
          "id": 17.12
        },
        {
          "name": "encodeURIComponent()",
          "classDeck": "card",
          "deck": "Global functions",
          "type": "function",
          "description": "глобальная функция, кодирующая часть (компонент) URI методом замены каждого экземпляра конкретного знака в один, два, три или четыре экранированные последовательности, представляющих кодировку знака в UTF-8 (четыре последовательности кодируют знак, состоящий из двух суррогатных знаков). \nconsole.log(`?x=${encodeURIComponent('test?')}`);// \"?x=test%3F\"\nСинтаксис - \nencodeURIComponent(str), где str - часть URI. ",
          "id": 17.13
        },
        {
          "name": "eval()",
          "classDeck": "card",
          "deck": "Global functions",
          "type": "function",
          "description": "функция, выполняющая JS-код из строки.\nconsole.log(eval('2 + 2'));// expected output: 4\nСинтаксис - \neval(string)\nгде string - выражение JavaScript, инструкция или перечень инструкций. Выражение может включать переменные и свойства существующих объектов. Возвращаемое значение - окончательное значение выполнения данного кода. Если значение пусто - вернется undefined. \neval() - функциональное свойство глобального объекта. Если аргументом является не строка, вернет неизмененный аргумент. \neval(new String('2 + 2')); // returns a String object containing \"2 + 2\"\neval('2 + 2');// returns 4\nПри непрямом (через переменную) вызове обращается только к глобальной области видимости, не к той, где работает с прямым вызовом.\nНикогда не используйте eval()! eval() is evil. Если вы запустите eval() со строкой, содержащей вредоносную часть, вы запустите вредоносный код с доступом к вашей странице или расширениям. Более того, вредоносный код \"увидит\" ту область видимости, где будет выполнен, что может стать причиной атак такого типа, к которым обычно функции нечувствительны. eval() также медленнее своих альтернатив, т.к. вызывает интерпретатор JS, в то время как другие конструкторы оптимизируются движками. Мало того, современные инетрпретаторы JS конвертируют JS в машинный код. Это значит, стирается любая существующая модель наименования переменных. Что заставляет браузер давать переменным длинные труднообрабатываемые имена в зависимости от их нахождения в коде и устанавливать их значения. Плюс к этому, другие вещи могут проявиться в eval(), такие как изменения типа данных переменных, что принудит браузер пересмотреть весь код. К счастью, есть очень хорошая альтернатива - использование window.Function(). ",
          "id": 17.14
        },
        {
          "name": "isFinite()",
          "classDeck": "card",
          "deck": "Global functions",
          "type": "function",
          "description": "функция синтаксиса \nisFinite(value) \nопределяет, является ли переданное значение конечным числом. При необходимости преобразует value к числу. Если аргумент является (или становится при конвертации) положительной или отрицательной Infinity, NaN или undefined - вернет false, во всех остальных случаях вернет true. Метод Number.isFinite() более точен, он определяет 0 как false, в то время как функция определит как true. \nЯвляется функциональным свойством глобального объекта. \nisFinite(Infinity);// false\nisFinite(NaN);// false\nisFinite(0);// true\nisFinite(2e64);// true\nisFinite(null);// true\nisFinite('0');// true",
          "id": 17.15
        },
        {
          "name": "isNaN()",
          "classDeck": "card",
          "deck": "Global functions",
          "type": "function",
          "description": "функция синтаксиса \nisNaN(value) \nопределяет, является ли значение value значением NaN. В отличие от других значений проверить NaN в JavaScript проблематично, т.к. строгое и нестрогое сравнение NaN === NaN и NaN == NaN всегда вернут false. Значение NaN возникает как рехультат неопределяемых или непредставимых значений, например, при делении 0 на 0. Оно также может появиться в результате попыток привести к числу тех типов данных, которые не могут быть переведены в числовой примитив. \nФункция отличается нетипичным поведением, т.к. сначала приводит аргумент к числу, если он не числового типа данных. В связи с этим, пустая строка или булевы примитивы могут быть переконвертированы в числовое значение, не NaN. Корень ошибок кроется в понимании самого термина NaN - \"не число\", имеющее специфическую трактовку для значений с плавающей тчокой стандарта IEEE754. По сути, задача функции - определение, \"является ли значение, приводящееся к числу, значением \"не число\" стандарта IEEE754?\". \nБолее надежный способ появился в ECMAScript2015 - Number.isNaN(). В отсутствие этого метода или как дополнительную проверку можно применить выражение (x != x). \nvar isNaN = function(value) {\n    var n = Number(value);\n    return n !== n;\n};",
          "id": 17.16
        }
      ],
      "id": 17
    },
    {
      "name": "Loops",
      "classDeck": "deck",
      "deck": "Loops",
      "type": "Loops",
      "description": "",
      "objects": [
        {
          "name": "do {...} while (...)",
          "classDeck": "card",
          "deck": "Loops",
          "type": "loop",
          "description": "do {body loop} while (condition)\nСначала будет выполнено тело цикла, а затем проверено условие. Пока оно true, цикл будет выполняться. Такая форма оправдана, если вы требуете выполнения цикла хотя бы один раз. Проверяет условие после каждой итерации.",
          "id": 18.1
        },
        {
          "name": "for (...) {...}",
          "classDeck": "card",
          "deck": "Loops",
          "type": "loop",
          "description": "for (start; condition; iteration) {body loop}\nСначала вводится переменная и присваивается ей значение, потом определяются условие (если будет false – цикл остановится) и итерация. \"Начало\" выполняется только раз. Проверяется условие перед каждой итерацией.\nfor (let i = 0; i < 5; i++) {body loop};\nМожно пропустить объявление переменной (если уже объявлена), шаг итерации (можно \"убрать\" его в выполняемый код for (;a>3;) {alert(a++)} или превратить в бесконечный цикл) и даже само условие, при этом обязательно остаются точки с запятыми - for (;;) {}). Объявление переменной внутри цикла – т.н. \"встроенное\" объявление переменной, такая переменная существует только внутри цикла!",
          "id": 18.11
        },
        {
          "name": "for (... in ...) {...}",
          "classDeck": "card",
          "deck": "Loops",
          "type": "loop",
          "description": "цикл перебирает все перечисляемые свойства, включая наследуемые, объекта под строковыми ключами (игнорируя символьные). Конструкция - for (variable in object) {...body loop...}, где variable - переменная, которой присваивается имя свойства, для каждой итерации другое, object - объект для перебора. В качестве имени переменной часто используют prop, иногда key. Почти всегда требуется ее объявление внутри цикла (let key in object). Объекты и массивы имеют неперечисляемые наследуемые свойства от прототипов (например, методы). При переборе свойств, в т.ч. наследуемых, приоритет будут иметь более близкие прототипы в цепочке наследования. Перебирает свойства в произвольном порядке. Если свойство меняется во время итерации и попадает в цикл опять, будет указано его более позднее значение. Удаленное до применения цикла свойство в цикл не попадает. Свойство, добавляемое во время его итерации может попасть в цикл или быть пропущено. В целом, во избежание ошибок, следует избегать добавления, удаления или изменения свойств во время их перебора. При переборе массивов нет никаких гарантий соблюдения порядка индекса свойств, поэтому, если это важно, стоит использовать цикл for (...), for ... of ... или метод Array.prototype.forEach(). Только собственные свойства можно перебрать, например, так.\nvar triangle = {a: 1, b: 2, c: 3};\nfunction ColoredTriangle() {\n  this.color = 'red';\n}\nColoredTriangle.prototype = triangle;\nvar obj = new ColoredTriangle();\nfor (const prop in obj) {\n  if (obj.hasOwnProperty(prop)) {\n    console.log(`obj.${prop} = ${obj[prop]}`);\n  } \n}\n// Output: \"obj.color = red\"",
          "id": 18.12
        },
        {
          "name": "for (... of ...) {...}",
          "classDeck": "card",
          "deck": "Loops",
          "type": "loop",
          "description": "выражение запускает цикл перебора (свойств) у перебираемых объектов, таких как встроенные String, Array, массивоподобные объекты (например, arguments или NodeList), TypedArray, Map, Set и итерируемые пользовательские объекты. Оно вызывает обработчик итераций с инструкциями, применяемыми к значению каждгого отдельного своства объекта. Синтаксис - for (variable of iterable) {statement}. variable - для каждого шага цикла значение отдельного свойства записывается в эту переменную, которую необходимо объявить при помощи let, const или var. iterable - итерируемый объект с перебираемыми свойствами. Неожиданная остановка цикла перебора возможна из-за break, throw или return. Различия между двумя циклами перебора for ... of и for ... in: первый перебирает свойства, которые итерируемый объект обозначает как перебираемые, второй перебирает перечисляемые свойства объекта в порядке их существования.\nПростой перебор массива:\nconst iterable = [10, 20, 30];\nfor (const value of iterable) {\n  console.log(value);\n}// 10, затем 20, 30\nУ строк как отдельный элемент рассматривает каждую кодовую точку.\nconst iterable = 'boo';\nfor (const value of iterable) {\n  console.log(value);\n}// \"b\", затем \"o\", \"o\"\nУ коллекций (Map) можно вызывать как каждый элемент в виде пары ключ/значение, так и ключ или его значение отдельно.\nconst iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);\nfor (const entry of iterable) {\n  console.log(entry);\n}\n// ['a', 1], затем ['b', 2], ['c', 3]\nfor (const [key, value] of iterable) {\n  console.log(value);\n}// 1, затем 2, 3\nМожно перебрать аргументы функции:\n(function() {\n  for (const argument of arguments) {\n    console.log(argument);\n  }\n})(1, 2, 3);// 1, 2, 3\nМожно перебрать и, соотвествтенно, обработать узлы в DOM, отвечающие каким-либо параметрам (не сработает в IE):\nconst articleParagraphs = document.querySelectorAll('article > p');\nfor (const paragraph of articleParagraphs) {\n  paragraph.classList.add('read');\n}\nПеребор объекта-генератора:\nfunction* fibonacci() { // a generator function\n  let [prev, curr] = [0, 1];\n  while (true) {\n    [prev, curr] = [curr, prev + curr];\n    yield curr;\n  }\n}\nfor (const n of fibonacci()) {\n  console.log(n);\n  // truncate the sequence at 1000\n  if (n >= 1000) {\n    break;\n  }\n}",
          "id": 18.13
        }
      ],
      "id": 18
    },
    {
      "name": "DOMMatrix (WebKitCSSMatrix)",
      "classDeck": "deck",
      "deck": "DOMMatrix (WebKitCSSMatrix)",
      "type": "DOMMatrix (WebKitCSSMatrix)",
      "description": "интерфейс, представляющий матрицу преобразований 4х4, применимую для 2D и 3D-графических операций, включая вращение и перемещение. Это изменяемая версия интерфейса только для чтения данных DOMMatrixReadOnly. WebKitCSSMatrix - аналог интерфейса. Интерфейс должен применяться в Web Workers, но некоторые реализации еще этого не позволяют. Не поддерживается в IE.",
      "objects": [
        {
          "name": "DOMMatrix()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "constructor",
          "description": "конструктор в синтаксисе \nlet domMatrix = new DOMMatrix(init) \nсоздает новый объект DOMMatrix, представляющий собой 4х4 матрицу перобразований для 2D и 3D-графики. init - строка из последовательности цифр или массив чисел, описывающих желаемую матрицу, или CSS-строка преобразований.\nvar matrix = new DOMMatrix([\n  Math.sin(angle) * scaleX,\n  Math.cos(angle) * scaleX,\n  -Math.sin(angle) * scaleY,\n  Math.cos(angle) * scaleY,\n  translateX,\n  translateY\n]);",
          "id": 19.1
        },
        {
          "name": "DOMMatrix.invertSelf()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "метод инвертирует матрицу. Если инвертирование невозможно, все значения будут установлены в NaN и свойство is2D вернет переключится в false.",
          "id": 19.11
        },
        {
          "name": "DOMMatrix.multiplySelf() ",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "метод модифицирует матрицу последующим умножением ее (post-muliplying) на другую указанную матрицу. Это эквивалент скалярному произведению A*B, где матрица A - исходная матрица и B - матрица с вводными данными для метода. Возвращает обновленную матрицу.",
          "id": 19.12
        },
        {
          "name": "DOMMatrix.preMultiplySelf()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "метод модифицирует матрицу ghtldfhbntkmysv умножением ее (pre-muliplying) на другую указанную матрицу. Это эквивалент скалярному произведению B*A, где матрица A - исходная матрица и B - матрица с вводными данными для метода. Возвращает обновленную матрицу.",
          "id": 19.13
        },
        {
          "name": "DOMMatrix.rotateAxisAngleSelf() ",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "метод, применяющий к матрице эффект поворота на указанное количество градусов вокруг установленного вектора.",
          "id": 19.14
        },
        {
          "name": "DOMMatrix.rotateFromVectorSelf()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "изменяет матрицу, применяя поворот на угол между указанным вектором и (1, 0). Возвращает измененную матрицу.",
          "id": 19.15
        },
        {
          "name": "DOMMatrix.rotateSelf()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "метод, применяющий к матрице эффект поворота вокруг каждой из осей в градусах. Возвращает измененную матрицу.",
          "id": 19.16
        },
        {
          "name": "DOMMatrix.scale3dSelf()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "метод, применяющий к матрице один масштабирующий коэффициент сразу к трем осям, центр - в указанной точке. Возвращает измененную матрицу.",
          "id": 19.17
        },
        {
          "name": "DOMMatrix.scaleSelf()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "метод изменяет матрицу, добавляя масштабирующие факторы, с центром в указываемой точке начала координат. Возвращает обновленную матрицу. По умолчанию, фактор масштабирования равен 1 для всех трех осей, а начало координат - в точке (0, 0, 0).",
          "id": 19.18
        },
        {
          "name": "DOMMatrix.setMatrixValue()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "заменяет значения матрицы на приведенные значения изменения или изменений. Возвращает измененную матрицу.",
          "id": 19.19
        },
        {
          "name": "DOMMatrix.skewXSelf()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "метод, изменяющий матрицу применением эффекта наклона вдоль оси x. Возвращает измененную матрицу.",
          "id": 19.2
        },
        {
          "name": "DOMMatrix.skewYSelf()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "метод, изменяющий матрицу применением эффекта наклона вдоль оси y. Возвращает измененную матрицу.",
          "id": 19.21
        },
        {
          "name": "DOMMatrix.translateSelf()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "метод модифицирует матрицу добавлением определенного вектора (по умолчанию - [0, 0, 0]). Возвращает измененную матрицу.",
          "id": 19.22
        },
        {
          "name": "fromFloat32Array()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "статический метод интерфейса DOMMatrix, создающий новый изменяемый объект DOMMatrix из массива значений одинарной точности (32 бит) с плавающей запятой. Если у массива 6 значений, результатом будет матрица 2D, если 16 значений - 3D. При другом количестве выбросит TypeError. ",
          "id": 19.23
        },
        {
          "name": "fromFloat64Array()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "method",
          "description": "статический метод интерфейса DOMMatrix создает новый объект DOMMatrix из массива значений двойной точности (64 бит) с плавающей точкой. Если у массива 6 значений, результатом будет матрица 2D, если 16 значений - 3D. При другом количестве выбросит TypeError. ",
          "id": 19.24
        },
        {
          "name": "fromMatrix()",
          "classDeck": "card",
          "deck": "DOMMatrix (WebKitCSSMatrix)",
          "type": "static method",
          "description": "статический метод интерфейса DOMMatrix создает новый объект DOMMatrix на основе имеющейся матрицы или словарного объекта DOMMatrixInit. Если исходная матрица не предоставлена, инициализируется матрица со всеми значениями, равными 0, кроме двух крайне правых значений главной диагонали (внизу справа) - m33 и m44, они будут установлены в 1. ",
          "id": 19.25
        }
      ],
      "id": 19
    },
    {
      "name": "DOMMatrixReadOnly",
      "classDeck": "deck",
      "deck": "DOMMatrixReadOnly",
      "type": "DOMMatrixReadOnly",
      "description": "интерфейс, представляющий матрицу преобразований 4х4, применимую только для чтения для 2D и 3D-графических операций. Существует изменяемая версия - интерфейс DOMMatrix (WebKitCSSMatrix - аналог интерфейса). Он позволяет изменять значения матрицы после ее создания. Оба интерфейса должны применяться в Web Workers, но некоторые реализации еще этого не позволяют. Не поддерживаются в IE.",
      "objects": [
        {
          "name": "DOMMatrixReadOnly.flipX()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, создающий новую матрицу на основе имеющейся, делая ее \"зеркальной\" изначальной относительно оси x. То же самое сделало бы умножение матрицы на матрицу DOMMatrix(-1, 0, 0, 1, 0, 0). Первоначальная матрица не меняется. Возвращает новую \"зеркальную\" матрицу. ",
          "id": 20.1
        },
        {
          "name": "DOMMatrixReadOnly.flipY()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, создающий новую матрицу на основе имеющейся, делая ее \"зеркальной\" изначальной относительно оси y. То же самое сделало бы умножение матрицы на матрицу DOMMatrix(1, 0, 0, -1, 0, 0). Первоначальная матрица не меняется. Возвращает новую \"зеркальную\" матрицу. ",
          "id": 20.11
        },
        {
          "name": "DOMMatrixReadOnly.inverse()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод возвращает новый объект DOMMatrix, созданные на основе инвертированной исходной матрицы. Если матрица не может быть инвертирована, значения всех компонентов устанавливаются в NaN и значением свойства is2D становится false. Исходная матрица не изменяется.",
          "id": 20.12
        },
        {
          "name": "DOMMatrixReadOnly.multiply()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод возвращает новый объект DOMMatrix из умножаемых матриц A и B. Если матрица-множитель не представлена, исходная матрица будет умножена на матрицу, где все значения представлены нулями кроме двух крайне правых значений главной диагонали (внизу справа) - m33 и m44, они будут установлены в 1. Изначальная матрица не меняется. ",
          "id": 20.13
        },
        {
          "name": "DOMMatrixReadOnly.rotate()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод возвращает новый объект DOMMatrix, созданный на основе исходной матрицы, повернутой вокруг каждой из своих осей на указанное количество градусов. ",
          "id": 20.14
        },
        {
          "name": "DOMMatrixReadOnly.rotateAxisAngle()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, возвращающий новый объект DOMMatrix, созданный на основе исходной матрицы, повернутой на указанный угол вокруг определенного вектора.",
          "id": 20.15
        },
        {
          "name": "DOMMatrixReadOnly.rotateFromVector()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод возвращает новый объект DOMMatrix, созданный на основе исходной матрицы, повернутой на угол между указанным вектором и (1, 0). ",
          "id": 20.16
        },
        {
          "name": "DOMMatrixReadOnly.scale()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод создает новую матрицу, применяя к исходной матрице масштабирование. Методу передаются 1 или 6 аргументов. \nDOMMatrixReadOnly.scale(scX, scY, scZ, orX, orY, orZ)\nscX - множитель масштабирования по горизонтали (единственный обязательный параметр), scY - по вертикали (если не представлен, будет равен значению scX), scZ - по оси Z (если отличается от 1 - это 3D матрица). orX - точка отсчета координат (если не указана, то равна 0), orY - точка отсчета по оси y, orZ - по оси Z (если не указана, равна 0, любое значение отличное от 0 сделает матрицу 3D).",
          "id": 20.17
        },
        {
          "name": "DOMMatrixReadOnly.scale3d() ",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, создающий и возвращающий новый объект DOMMatrix, созданный на основе исходной матрицы, к которой применен масштабирующий коэффициент сразу по всем трем осям относительно указываемой точки отсчета координат (по умолчанию (0, 0, 0). ",
          "id": 20.18
        },
        {
          "name": "DOMMatrixReadOnly.skewX()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, возвращающий новую матрицу DOMMatrix, созданную на основе исходной матрицы, повернутой вдоль оси x. ",
          "id": 20.19
        },
        {
          "name": "DOMMatrixReadOnly.skewY() ",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, возвращающий новую матрицу DOMMatrix, созданную на основе исходной матрицы, повернутой вдоль оси y. ",
          "id": 20.2
        },
        {
          "name": "DOMMatrixReadOnly.toFloat32Array() ",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, возвращаюший новый объект Float32Array, содержащий 16 элементов (m11, m12 и т.д.), составляющих матрицу. Все элементы сохраняются в массив как числа одинарной точности с плавающей точкой в порядке \"по колонкам\" (colexofraphical (colex) order - т.е. сначала заполняется первая колонка сверху вниз, потом вторая и т.д.).  ",
          "id": 20.21
        },
        {
          "name": "DOMMatrixReadOnly.toFloat64Array()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, возвращаюший новый объект Float64Array, содержащий 16 элементов (m11, m12 и т.д.), составляющих матрицу. Все элементы сохраняются в массив как числа двойной точности с плавающей точкой в порядке \"по колонкам\" (colexofraphical (colex) order - т.е. сначала заполняется первая колонка сверху вниз, потом вторая и т.д.).  ",
          "id": 20.22
        },
        {
          "name": "DOMMatrixReadOnly.toJSON()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, возвращающий объект JSON, описывающий матрицу DOMMatrixReadOnly.",
          "id": 20.23
        },
        {
          "name": "DOMMatrixReadOnly.toString()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, возвращающий объект DOMString, описывающий матрицу в синтаксисе CSS (см. детали синтаксиса в CSS-функции matrix()). У 2D-матриц будут описаны параметры a-f. У 3D-матриц - все 16 элементов. Будет выброшена ошибка, если хотя бы одно из значений является бесконечным.",
          "id": 20.24
        },
        {
          "name": "DOMMatrixReadOnly.transformPoint()",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод, изменяющий указанную точку, используемую в матрице, возвращая новый объект DOMPoint, содержащий эту измененную точку. Ни исходная матрица, ни исходная точка не изменяются.",
          "id": 20.25
        },
        {
          "name": "DOMMatrixReadOnly.translate() ",
          "classDeck": "card",
          "deck": "DOMMatrixReadOnly",
          "type": "method",
          "description": "метод создает и возвращает новую матрицу DOMMatrix на основе исходной, перемещенной по указанным координатам. Метод принимает 2 или 3 аргумента. DOMMatrix.translate(x, y, z). Если значение z не указывантся, оно равно 0. Любое указываемое отличное от 0 значение создаст 3D-матрицу.",
          "id": 20.26
        }
      ],
      "id": 20
    },
    {
      "name": "DOMTokenList",
      "classDeck": "deck",
      "deck": "DOMTokenList",
      "type": "DOMTokenList",
      "description": "интерфейс представляет собой набор разделенных пробелами токенов. Это наборы данных, возвращаемые Element.classList, HTMLLinkElement.relList, HTMLAnchorElement.relList, HTMLAreaElement.relList, HTMLIframeElement.sandbox или HTMLOutputElement.htmlFor. Они индексируются с 0 как массивы объектов. Всегда чувствительны к регистру.",
      "objects": [
        {
          "name": "DOMTokenList.add() ",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе \ntokenList.add(token_1, token_2...) \nдобавляет токены к списку. Возвращает undefined, аргументы token - строки. Нет поддержки в IE",
          "id": 21.1
        },
        {
          "name": "DOMTokenList.contains()",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе \ntokenList.contains(token) \nвозвращает булево значение - true, если указанный список содержит указанный токен, иначе вернет false. Аргумент token - строка",
          "id": 21.11
        },
        {
          "name": "DOMTokenList.entries()",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе \ntokenList.entries() \nвозвращает итератор, позволяющий перебрать пары ключ/значение, содержащиеся в объекте. Ключи - индекс. Значения (values) - строки, представляющие собой отдельные токены. Нет поддержки в IE",
          "id": 21.12
        },
        {
          "name": "DOMTokenList.forEach()",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе \ntokenList.forEach(callback, thisArg) \nвызывает указанную колбэк-функцию применительно к каждому элементу списка в порядке их нахождения в списке. У колбэк-функции три аргумента: currentValue (текущий обрабатываемый элемент в списке), currentIndex (индекс текущего обрабатываемого элемента), listObj (массив, к которому применяется функция). Опциональный аргумент thisArg - this. Метод возвращает undefined. \n<span class=\"a b c\"></span>\nlet span = document.querySelector(\"span\");\nlet classes = span.classList;\nlet iterator = classes.values();\nclasses.forEach(\n  function(value, key, listObj) {\n    span.textContent += `${value} ${key}/${this}  ++  `;\n  },\n  \"arg\"\n);\nНет поддержки в IE.",
          "id": 21.13
        },
        {
          "name": "DOMTokenList.item()",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе\ntokenList.item(index) \nвозвращает элемент списка по его индексу. Возвращаемое значение - строка, представляющая возвращаемый элемент. Вернет null, если индекс будет больше или равен длине списка. Соответственно, индекс последнего элемента списка будет равен length - 1",
          "id": 21.14
        },
        {
          "name": "DOMTokenList.keys()",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе \ntokenList.keys() \nвозвращает итератор, позволяющий перебрать элементы списка по ключам. Ключи - целые беззнаковые числа. Нет поддержки в IE.",
          "id": 21.15
        },
        {
          "name": "DOMTokenList.length",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "property",
          "description": "свойство только для чтения, целое число, представляющее количество хранящихся объектов в данно объекте.",
          "id": 21.16
        },
        {
          "name": "DOMTokenList.remove()",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе \ntokenList.remove(token_1, token_2...) \nудаляет указанные токены из списка. Возвращает undefined, аргументы token - строки. Нет поддержки в IE",
          "id": 21.17
        },
        {
          "name": "DOMTokenList.replace()",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе \ntokenList.replace(oldToken, newToken) \nменяет один токен списка oldToken на новый newToken. Если oldToken не существует, метод незамедлительно вернет false, не добавляя новый токен. В случае, если найден старый и он успешно заменен на новый, метод вернет true. В старых браузерах метод возвращает void. Нет поддержки в IE",
          "id": 21.18
        },
        {
          "name": "DOMTokenList.supports()",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе \nlet trueOrFalse = element.supports(token)\nвернет true, если указанный токен присутствует среди поддерживаемых элементом атрибутов. Нацелен на определение функции поддержки. Нет поддержки в IE",
          "id": 21.19
        },
        {
          "name": "DOMTokenList.toggle()",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе \ntokenList.toggle(token, force) \nудаляет указанный токен из списка и возвращает false. Если такой токен не найден в списке, установит его и вернет true. Опциональный параметр force сделает этот переключатель \"одноразовым\". Если аргумент равен false, токен можно только удалить, но не добавить. Если true - только добавить, но не удалить. Нет поддержки в IE",
          "id": 21.2
        },
        {
          "name": "DOMTokenList.value",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "property",
          "description": "свойство с преобразованием в строку, возвращающее значение списка в виде строки DOMString или \"обнуляющее\" или устанавливающее значением указываемый список. Нет поддержки в IE.",
          "id": 21.21
        },
        {
          "name": "DOMTokenList.values()",
          "classDeck": "card",
          "deck": "DOMTokenList",
          "type": "method",
          "description": "метод в синтаксисе \ntokenList.values() \nвозвращает итератор, позволяющий разработчику обойти значения списка. Значения - сами элементы списка. Нет поддержки в IE. ",
          "id": 21.22
        }
      ],
      "id": 21
    },
    {
      "name": "Element",
      "classDeck": "deck",
      "deck": "Element",
      "type": "Element",
      "description": "Element - основной класс, от которого наследуют все элементы-объекты (т.е. объекты, представляюшие элементы) в интерфейсе Document. Только этот класс имеет методы и свойства, общие для всех элементов. Более специфичные классы наследуют от Element. Например, HTMLElement - базовый интерфейс для HTML-элементов, или SVGElement - базовый интерфейс для всех SVG-элементов. Основная функциональность определяется далее вниз по иерархии класса. Языки, выходящие за область действия веб-платформы, вроде XUL у интерфейса XULElement, также используют Element.",
      "objects": [
        {
          "name": "Element.animate()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "экспериментальный метод - быстрый способ создания new Animation, нового объекта Web-API Animation, применяемого к элементу и затем запускающего анимацию. Возвращает созданный экземпляр объекта Animation. К элементам можно применять сразу несколько анимаций. Можно получить список, влияющих на элемент, вызовом Element.getAnimations(). Синтаксис - \nvar animation = element.animate(keyframes, options)\nKeyframes - массив объектов или один объект keyframe, чьи свойства - массивы значений для их перебора (см. Keyframe Formats). Options - это либо целое число, указывающее продолжительность анимации в миллисекундах, либо объект, содержащий одно или несколько временных свойств (все опциональные): id (по этому id можно идентифицировать конкретную анимацию animate(), строка), delay (время задержки начала анимации в миллисекундах, по-умолчанию 0), direction (указывает, идет ли анимация вперед (normal) или в обратном (reverse) направлении, идет вперед и сменяется ли направление после каждого шага итерации (alternate) или идет назад и сменяет направление после каждой итерации (alternate-reverse), по-умолчанию normal), duration (время каждого шага (итерации), необходимого на завершение анимации в миллисекундах, по-молчанию 0; несмотря на то, что это необязательная опция, помните, что ваша анимация не будет запускаться, если это значение оставить как 0), easing (скорость анимации, изменяющаяся со временем, применимы предустановленные значения (в виде строки в кавычках) - linear (по-умолчанию), ease, ease-in, ease-out, ease-in-out или изменяемое пользователем cubic-bezier в виде \"cubic-bezier(0.42, 0, 0.58, 1)\"), endDelay (время задержки после окончания анимации, в основном используется, когда задается последовательность анимации в зависимости от окончания предыдущей, по-умолчанию 0), fill (указывает, должны ли анимационные эффекты отражаться элементами перед проигрыванием (\"backwards\"), оставаться после завершения анимации (\"forwards\") или и то, и другое; по-умолчанию \"none\"), iterationStart (описывает, с какой точки в шаге итерации анимация должна начаться, 0.5 укажет начать анимацию с середины первого шага, в таком случае анимация, которая будет иметь всего 2 итерации, закончится на середине третьей; по-умолчанию 0), iterations (количество повторений анимации, по-умолчанию 1, возможна установка infinity для бесконечного проигрывания во время всей жизни элемента), \ncomposite (определяет, как значения разных анимаций объединяются, отделяет анимации, у которых не установлены собственные операции комбинирования: add указывает применить аддитивный эффект, где каждая успешная итерация построена на значении предыдущей, например, поворот translateX не перезапишет результат предыдущей анимации другого поворота rotate, а будет отталкиваться от его значения, т.е. новое значение будет прибавлено к предыдущему, accumulate работает похожим образом, но несколько умнее: blur(5) и blur(2) станет blur(7), replace перезапишет старое значение новым), iterationComposite (определяет как значения меняются от итерации к итерации, может быть установлено в accumulate или replace (по-умолчанию) как указано выше).",
          "id": 22.1
        },
        {
          "name": "Element.assignedSlot",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "включенное свойство, основанное на миксине Slottable. В синтаксисе var slotEl = element.assignedSlot свойство только для чтения вернет экземпляр HTMLSlotElement, представляющий собой <slot>, вставленный как узел, или null, если элементу не был присвоен slot или ассоциированный с ним теневой корень был присоединен в закрытом режиме (mode == \"closed\").",
          "id": 22.11
        },
        {
          "name": "Element.attachShadow()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nvar shadowRoot = element.attachShadow(shadowRootInit) присоединяет теневое дерево DOM к указанному элементу и возвращает ссылку на его ShadowRoot (возвращает объект ShadowRoot). Имейте в виду, что вы не можете присоединить shadow root к любому элементу. По причинам безопасности вы не можете присоединить теневое дерево к некоторым из них (например, <a>). Вот список элементов, к которым присоединение возможно: article, aside, blockquote, body, div, footer, h1-h6, header, main, nav, p, section, span и автономные (пользовательские) элементы с правильным именем. \nShadowRootInit - это словарь, содержащий следующие поля: mode (строка, устанавливающая режим инкапсуляции для теневого дерева, это либо open - элементы теневого корня доступны для JavaScript \"снаружи\", либо closed - доступ к узлам теневого корня \"внешнему\" JavaScript запрещен) и delegateFocus (булево значение, когда true - устанавливает поведение, смягчающее ограничения пользовательского элемента, связанные с его способностью получать фокус: при клике на не-фокусируемую часть теневого DOM, первая, фокусируемая часть, получает фокус и к элементу-хозяину теневого дерева применима стилизация с :focus). \nВозможные выбрасываемые исключения: InvalidStateError (элемент, к которому вы пытаетесь подключиться, уже содержит shadow), NotSupportedError (вы пытаетесь подключить shadow root к элементу, лежащему вне пространства имен HTML или к данному типу элемента невозможно подключение shadow). ",
          "id": 22.13
        },
        {
          "name": "Element.attributes",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство только для чтения, возвращающее живую коллекцию всех узлов-атрибутов у данного узла - NamedNodeMap, это не массив, поэтому методы массивов не применимы и индексы узлов Attr могут варьироваться у разных браузеров. Будучи достаточно специфичными, атрибуты представляют собой пары строк в виде \"ключ/значение\", предоставлющих информацию о данном атрибуте. ",
          "id": 22.14
        },
        {
          "name": "Element.classList",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство только для чтения, возвращающее живую коллекцию DOMTokenList атрибутов класса (class) элемента. Она может затем использоваться для манипуляций со списком классов. Использование classList - удобный способ доступа к списку классов как к разделенным пробелами строкам. DOMTokenList представляет набор значений атрибута класса. Если атрибут класса не установлен или пуст, вернется пустой DOMTokenList, т.е. со свойством length == 0. Сама по себе коллекция - только для чтения, тем не менее ее можно изменять, применяя методы add(), remove() и toggle() из Web-API интерфейса DOMTokenList",
          "id": 22.15
        },
        {
          "name": "Element.className",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "геттер и сеттер значения атрибута класса данного элемента. Синтаксис - \nlet cName = elementNodeReference.className \nили \nelementNodeReference.className = cName. \nlet el = document.getElementById('item');\nif (el.className === 'active'){\n  el.className = 'inactive';\n} else {\n  el.className = 'active';\n}\nТакое имя свойства используется вместо class по причине фозможных конфликтов (многие языки использут это ключевое слово для манипулирования DOM). className также может быть экземпляром интерфейса SVGAnimatedString, если элемент - SVGElement. В случае, если вы имеете дело с SVG, лучше устанавливать или получать это свойство через Element.getAttribute() и Element.setAttribute(). Но имейте в виду, что в случае пустого значения атрибута класса .getAttribute() вернет null вместо \"\". ",
          "id": 22.16
        },
        {
          "name": "Element.clientHeight",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство только для чтения, равное нулю у элементов без CSS или элементов каркаса строчной разметки, иначе - равное внутренней высоте элемента в пикселях. Синтаксис - \nlet height = element.clientHeight\nВозвращает целое число в пикселях. Саойство включает в себя внутренние отступы, но не включает границы, поля и горизонтальные скролбары (если они есть). Может быть рассчитано как CSS height + CSS padding - height скролбара. При использовании на корневом элементе (<html>) или на <body> у документа в режиме совместимости, свойство равно высоте видимого экрана просмотра (viewport) без учета скролбара. Это особый случай. Свойство округляет свое значение, если нужно более точное значение - используйте element.getBoundingClientRect().",
          "id": 22.17
        },
        {
          "name": "Element.clientLeft",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "ширина левой границы элемента в пикселях. Включает ширину вертикального скролбара, если направление написания текста справа налево и если переполнение контента заставляет отображать скролбар. Не включает в себя левое поле или отступ. Свойство только для чтения. \nКогда настройка layout.scrollbar.side установлена в положения от 1 до 3 и направление текста осуществляется справа налево, скролбар позиционируется слева и он влияет на расчет clientLeft. Свойство также округляет свое значение до целых чисел. Для более точных данных используйте element.getBoundingClientRect(). Если у элемента свойство display: inline, вернется 0 вне зависимости от того, есть граница у элемента или ее нет.",
          "id": 22.18
        },
        {
          "name": "Element.clientTop",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "ширина верхней границы элемента в пикселях. Свойство только для чтения, целое число. Бывает, что все лежащее между двух позиций (offsetTop и верхней границей области клиента) - это граница элемента. Это потому что offsetTop показыват положение верхнего края границы (но не внешнего поля), в то время как область клиента начинается непосредственно от низа границы (она включает область внутреннего отступа padding). Следовательно, значение ClientTop будет всегда равным целому числу значения .getComputedStyle() для ширины верхней границы (в действительности может быть округленным Math.round(parseFloat())). Например, если вычисленное значение ширины верхней границы равно нулю, то значение clientTop также равно нулю. Значение, как уже сказано, округляется. Для более точных значений используйте element.getBoundingClientRect(). ",
          "id": 22.19
        },
        {
          "name": "Element.clientWidth",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "значение свойства равно нулю для инлайн-элементов и элементов без CSS. иначе - это внутренняя ширина элемента в пикселях. Включая внутренние отступы, но исключая границы, внешние поля (margins) и вертикальный скролбар, если он присутствует. У корневого (<html>) элемента или у <body> у документа в режиме совместимости вернет ширину видимого окна просмотра (viewport), исключая скролбар. Это особый случай. Только для чтения, возвращает целое число в пикселях.",
          "id": 22.2
        },
        {
          "name": "Element.closest()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "метод просматривает элемент и его родителей (следуя по направлению к корню документа) до тех пор, пока не найдет узел, соответствующий указанному селектору (в строке). Вернет сам узел (на котором вызван) или сопоставленного с ним предка. В отсутствие подходящего элемента вернет null. Синтаксис - \nvar closestElement = targetElement.closest(selectors)\nгде selectors - DOMString - список селекторов (например, p:hover, .toto + q и т.д.). Возвращаемое значение - наиближайший предок элемента, соответствующий указанным селекторам. При ошибке в написании строки с селекторами выбросит исключение SyntaxError. \n<article>\n  <div id=\"div-01\">Here is div-01\n    <div id=\"div-02\">Here is div-02\n      <div id=\"div-03\">Here is div-03</div>\n    </div>\n  </div>\n</article>\nvar el = document.getElementById('div-03');\nvar r1 = el.closest(\"#div-02\");// returns div-02\nvar r2 = el.closest(\"div div\");// returns the closest ancestor which is a div in div, div-03\nvar r3 = el.closest(\"article > div\");// returns div-01\nvar r4 = el.closest(\":not(div)\");// returns article",
          "id": 22.21
        },
        {
          "name": "Element.computedName",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "только для чтения, возвращает DOMString, содержащую ярлык (label), указываемый для обеспечения доступности",
          "id": 22.22
        },
        {
          "name": "Element.computedRole",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "только для чтения, возвращает DOMString, содержащую значение (role) ARIA-атрибута, примененного к данному элементу",
          "id": 22.23
        },
        {
          "name": "Element.computedStyleMap()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nvar stylePropertyMap = element.computedStyleMap() \nэкспериментальный метод, возвращающий интерфейс StylePropertyMapReadOnly, предоставляющий описание всего блока CSS-деклараций (только для чтения, альтернатива CSSStyleDeclaration). Это будет перебираемый массивоподобный объект всех CSS-свойств, и примененных, и дефолтных. ",
          "id": 22.25
        },
        {
          "name": "Element.focusin",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие focusin возникает, когда элемент получает фокус. Разница с событием focus - focusin всплывает, а focus нет. Противоположное событие focusin - focusout. Интерфейс: FocusEvent, свойство-обработчик: onfocusin, синхронное, составное, всплытие: да, отменяемость: нет. ",
          "id": 22.26
        },
        {
          "name": "Element.getAnimations()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "экспериментальный метод интерфейса (определенный у миксина Animatable), возвращающий массив всех объектов Animation, влияющих на данный элемент или которые должны повлиять на него в будущем. Опционально может вернуть объекты Animation и для элементов-потомков. Массив содержит CSS Animations, CSS Transitions и Web Animations. Синтаксис - \nconst animations = element.getAnimations(options)\nгде options - необязательный параметр в виде объекта, содержащего булево свойство subtree, если {subtree: true} - вернутся объекты и для потомков, и для псевдо-элементов, прикрепленных к данному элементу (по-умолчанию, false).  ",
          "id": 22.27
        },
        {
          "name": "Element.getAttribute()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nlet attribute = element.getAttribute(attrData)\nметод интерфейса, возвращающий значение указанного атрибута. Если такого атрибута не существует, вернется null или \"\" (пустая строка). Параметром attrData может быть как имя атрибута, так и его значение в виде строки. При использовании с HTML-элементом в DOM, отмеченном как HTML-документ, метод переведет строчный аргумент в нижний регистр. В большинстве браузеров вернет null, если указанный атрибут у указанного элемента отсутствует. В старом DOM (в 3-й версии ядра) спецификация говорит, что правильным возвращаемым значением является пустая строка и некоторые реализации DOM до сих пор реализуют такое поведение. Реализация метода в XUL (Gecko) следует этой спецификации и возвращает пустую строку. Следовательно, вы должны использовать .hasAttribute() \nдля проверки наличия атрибута перед вызовом .getAttribute(), если есть какие-то сомнения. В целях безопасности специальные значения (nonce value) у нескриптовых ресурсов, таких как СSS-селекторы, и при вызове .getAttribute(\"nonce\") скрыты. \nlet nonce =  script.getAttribute('nonce');// вернет пустую строку\nВместо получения данных из контента атрибута используйте свойство nonce миксина HTMLElementOrForeignElement.\nlet nonce =  script.nonce;",
          "id": 22.28
        },
        {
          "name": "Element.getAttributeNames()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "возвращает имена атрибутов элемента в виде массива строк. Если элемент не имеет атрибутов, вернется пустой массив. Использование метода наряду с .getAttribute() является малозатратным для памяти и эффективным альтернативным доступом к свойству Element.attributes. \nfor (let name of element.getAttributeNames()) {\n  let value = element.getAttribute(name);\n  console.log(name, value);\n}",
          "id": 22.29
        },
        {
          "name": "Element.getAttributeNS()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nattrVal = element.getAttributeNS(namespace, name) \nвозвращает строчное значение атрибута с именем name пространства имен namespace. Если атрибута не существует, вернется null или пустая строка. Пространства имен поддерживаются только в XML-документах. В HTML5 используйте .getAttribute(). Метод отличается от .getAttribute() возможностью получения атрибута с установленным пространством имен. Спецификация указывает возвращать при отсутствии атрибута пустую строку, но большинство браузеров вернут null (лишь некоторые старые браузеры выдадут пустую строку). По этим причинам используйте метод .hasAttributeNS() \nдля проверки наличия атрибута перед применением данного метода.",
          "id": 22.3
        },
        {
          "name": "Element.getBoundingClientRect()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nlet rectObj = element.getBoundingClientRect() \nвозвращает объект DOMRect, предоставляющий информацию о размерах и позиционировании элемента относительно экрана просмотра (viewport). Это наименьший из прямоугольников, содержащих элемент целиком, включая его отступы и ширину границ. Свойства left, top, right, bottom, x, y, width и height описывают позицию и размер этого прямоугольника в пикселях. Все свойства кроме ширины и высоты даются относительно левого верхнего угла экрана просмотра. Свойства ширины и высоты включают отступы и границы, не только ширину/высоту контента. В стандартной модели это ширина или высота элемента + отступы + ширина границ. Но если к элементу применена модель box-sizing: border-box, это будет только ширина или высота. Возвращаемое значение можно понимать как объединение прямоугольников, возвращенных \n.getClientRects() для данного элемента, т.е. набор CSS-бордер-боксов, ассоциированных с этим элементом. Пустые бордер-боксы полностью игнорируются. Если все бордер-боксы элемента пусты, вернется прямоугольник с нулевыми шириной и высотой и его top и left будут top-left бордер-бокса первого CSS-блока (в порядке положения контента) этого элемента. Данные скроллинга у экрана просмотра (или другого прокручиваемого элемента) принимаются в расчет. Это значит, что границы очерчиваемого прямоугольника (top, right, bottom, left) изменяют свои значения каждый раз при изменениях позиций при прокрутке (потому что их значения относительны окна просмотра и не абсолютны). Если вы хотите получить прямоугольник с положением относительно верхнего левого угла всего документа (с положением независимо от прокрутки), просто прибавьте текущую прокрутку (ее можно получить из свойств window.scrollX и window.scrollY) к свойствам left и top. Для повышенной совместимости браузеров лучше использовать свойства window.pageXOffset, window.pageYOffset. ",
          "id": 22.31
        },
        {
          "name": "Element.getClientRects()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "метод возвращает коллекцию объектов DOMRect, показывающих границы прямоугольников для каждого SCC-бордер-бокса в клиенте. Большинство элементов имеют только один бордер-бокс, но многострочные строчые элементы (такие как многострочный <span> по-умолчанию) имеют бордер-бокс вокруг каждой строки. Каждый объект DOMRect содержит свойства только для чтения: left, top, right и bottom в пикселях, чей верхний угол указан относительно вернего левого угла экрана просмотра. У таблиц с названием (caption) название заключено внутри, даже если оно вне бордер-бокса таблицы. При вызове на SVG-элементах кроме внешнего <svg> окном просмотра будет считаться внешний <svg>. Изначально Microsoft задумывала этот метод для возврата объекта TextRectangle для каждой строки текста. CSSOM указывает, что должен возвращаться DOMRect для каждого бордер-бокса. Для строчных элементов оба этих определения идентичны. Но для блочных Mozilla вернет только один прямоугольник. Прокрутка принимается в расчет. Возвращаемые прямоугольники не включают границы любых дочерних элементов, которые вышли за пределы предка (случилось переполнение). У HTML-элементов <area>, ничего не отображающих SVG-элементов, элементов с display: none и почти всех элементов не отображаемых явно, вернется пустой список. Прямоугольники будут возвращены даже для СSS-боксов, содержащих пустые бордер-боксы. И их координаты будут значимыми.",
          "id": 22.32
        },
        {
          "name": "Element.getElementsByClassName()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nlet elem = element.getElementsByClassName(names) \nвернет живую HTML-коллекцию (HTMLCollection), содержащую все элементы-потомки element, у которых установлен класс с именем или именами names (DOMString с именами классов, разделенных пробелами). На интерфейсе Document метод работает точно так же, с той лишь разницей, что стартует с корня документа. \nelement.getElementsByClassName('red test');",
          "id": 22.33
        },
        {
          "name": "Element.getElementsByTagName()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nlet elems = element.getElementsByTagName(tagName) \nвозвращает живую HTMLCollection элементов с указанным теговым именем tagName. В поиск попадают все потомки установленного элемента, но не он сам. Возвращаемый список живой, изменяющийся в завосимости от изменений в DOM tree, Поэтому нет необходимости в вызове одного и того же метода на том же элементе и с теми же аргументами в промежутке между этими изменениями. При вызове на HTML-элементе в HTML-документе приведите аргументы к нижнему регистру. Но это нежелательно при поиске SVG-элементов с верблюжьей нотацией (таких как <linearGradient>). В таких случаях используйте Element.getElementsByTagNameNS(), который предотвратит капитализацию имени тега. Метод близок методу Document.getElementsByTagName(), только ищет элементы среди потомков данного элемента. Если не найдено ни одного элемента, вернется пустая коллекция. Специальная строка \"*\" задаст поиск всех элементов. Для совместимости с XHTML необходим нижний регистр.",
          "id": 22.34
        },
        {
          "name": "Element.getElementsByTagNameNS()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nlet elems = element.getElementsByTagNameNS(namespaceURI, localName) \nвозвращает живую коллекцию HTMLCollection элементов по данному имени тега, принадлежащему данному пространству имен. Близок методу Document.getElementsByTagNameNS(), исключая ограничение искомых элементов потомками. Порядок элементов в коллекции определяется их нахождением в дереве. Element - элемент, с которого нужно начать поиск. В результат поиска будут включены только потомки этого элемента, но не сам узел. NamespaceURI - это URI пространства имен элементов для поиска. Например, для поиска XHTML-элементов используйте URI пространства имен XHTML, http://www.w3.org/1999/xhtml. LocalName - локальное имя элемента или специальное значение \"*\", обозначающее \"все элементы\".",
          "id": 22.35
        },
        {
          "name": "Element.hasAttribute()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.hasAttribute(name) \nвозвращает булево значение, показывающее имеет ли данный элемент атрибут с таким именем (name, строка в кавычках) или нет. ",
          "id": 22.36
        },
        {
          "name": "Element.hasAttributeNS()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nlet result = element.hasAttributeNS(namespace, localName) \nвозвращает булево значение, показывающее, имеет ли элемент данный атрибут. ",
          "id": 22.37
        },
        {
          "name": "Element.hasAttributes()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "возвращает булево значение, показывающее, имеет ли данный элемент вообще какой-либо атрибут или не имеет.",
          "id": 22.38
        },
        {
          "name": "Element.hasPointerCapture()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \ntargetElement.hasPointerCapture(pointerId) \nметод интерфейса Element, определяющий, имеет ли элемент, на котором он вызван (targetElement) перехватчик указателя, идентифицируемого по ID. Возвращает булево значение.",
          "id": 22.39
        },
        {
          "name": "Element.id",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство представляет идентификатор элемента, отображая его глобальный атрибут id. Если значение - не пустая строка, оно должно быть уникальным для данного документа. Свойство часто используется для доступа к определенному элементу методом .getElementById(). Другое частое применение - в качестве селектора при стилизации документа в CSS. Значение чувствительно к регистру, но лучше все же избегать создания id, отличающихся только регистром. \nСинтаксис - \nvar idStr = element.id;// получение id\nили \nelement.id = idStr;// установка id",
          "id": 22.4
        },
        {
          "name": "Element.innerHTML",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "получение или установка разметки HTML или XML в качестве контента внутри элемента. Если узлы <div>, <span> или <noembed> имеют дочерний текстовый узел, включающий символы &, < или >, innerHTML вернет эти символы как сущности HTML (\"&amp\", \"&lt\", \"&gt\" соответственно). Применяйте Node.textContent для получения \"сырой\" копии контента этих текстовых узлов. Для вставки контента без замены уже существующего применяйте .insertAdjacentHTML(). Значение - строка DOMString, содержащая HTML-сериализацию потомков элемента. Установка значения удалит всех вложенных в элемент потомков и заменит их узлами, спарсенными из указанного в новом значении HTML. Синтаксис - \nlet content = element.innerHTML;// получение значения свойства\nили \nelement.innerHTML = htmlString;// установка нового значения свойства\nИсключение SyntaxError будет выброшено, если устанавливаемое значение - строка с неправильно оформленным HTML. Исключение NoModificationAllowedError будет выброшено при попытке вставить HTML в узел, чьим прямым потомком является Document.\nВозвращаемый фрагмент разметки основывается на текущем контенте, так что его разметка и форматирование могут отличаться от изначально загруженного в оригинальной странице. Вставка фрагмента - удобный способ очистить элемент и даже сразу весь документ от всего контента разом, просто вставив пустую строку: document.body.innerHTML = \"\"; \nВ следующем примере запрашивается текущая HTML-разметка документа и в ней заменяются символы < на HTML-сущности \"&lt\", таким образом фактически конвертируя HTML в обычный текст. Затем он оборачивается в элемент <pre>. Потом результат помещается в innerHTML. В результате, контент документа заменяется код всего документа, как он выглядит в разметке.\ndocument.documentElement.innerHTML = \"<pre>\" +\n         document.documentElement.innerHTML.replace(/</g,\"&lt;\") +\n            \"</pre>\";\nЧто в действительности происходит, когда вы устанавливаете значение innerHTML? Пользовательский агент делает следующее:\n1. Устанавливаемое значение парсится на наличие HTML или XML (в зависимости от типа документа), результатом чего становится объект DocumentFragment, представляющий собой новый набор DOM-узлов, создаваемых для новых элементов.\n2. Если целевой элемент - тот, чье содержимое перемещается как элемент <template>, то атрибутивное свойство HTMLTemplateElement.content элемента <template> заменяется на сформированный в первом шаге DocumentFragment.\n3. У всех остальных элементов их содержимое заменяется на узлы нового DocumentFragment.\nСвойство небезопасно, уязвимо для атак, поэтому в HTML5 тег <script> не запускается, будучи вставленным в innerHTML. Тем не менее, есть способы запуска JavaScript и без этого тега\nconst name = \"<img src='x' onerror='alert(1)'>\";\nel.innerHTML = name; // shows the alert\nПо этим причинам рекомендуется не использовать это свойство для вставки обычного текста, лучше применяйте Node.textContent. При этом, контент не парсится на HTML, вставляя простой текст.",
          "id": 22.42
        },
        {
          "name": "Element.insertAdjacentElement()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \ntargetElement.insertAdjacentElement(position, element) \nвставляет данный узел-элемент в указанную позицию по отношению к элементу, на котором вызван. Параметр position - строка с одним из вариантов: 'beforebegin' (перед targetElement), 'afterbegin' (внутри targetElement, перед его первым дочерним элементом), 'beforeend' (внутри targetElement, после его последнего дочернего элемента), 'afterend' (после targetElement). Element - вставляемый элемент. Метод возвращает вставляемый узел или null, если вставка была неудачной. Выбросит исключение SyntaxError, если не удастся распознать значение для указанной позиции. Выбросит TypeError, если вставляемый элемент не является валидным элементом. ",
          "id": 22.43
        },
        {
          "name": "Element.insertAdjacentHTML()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.insertAdjacentHTML(position, text) \nпарсит приводимый текст (text) как HTML или XML и вставляет полученные из парсинга узлы в определенную позицию DOM-дерева. Метод не парсит элемент, на котором используется, и поэтому не повреждает элементы внутри него. Это позволяет избежать лишних шагов сериализации, делая метод более быстрым, чем прямое манипулирование innerHTML. Параметр position - строка с одним из вариантов: 'beforebegin' (перед targetElement), 'afterbegin' (внутри targetElement, перед его первым дочерним элементом). 'beforeend' (внутри targetElement, после его последнего дочернего элемента), 'afterend' (после targetElement). ",
          "id": 22.44
        },
        {
          "name": "Element.insertAdjacentText()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.insertAdjacentText(position, elem) \nвставляет указанный текстовый узел (elem) в указанную позицию (position) по отношению к элементу, на котором он вызван (element). Параметр position - строка с одним из вариантов: 'beforebegin' (перед targetElement), 'afterbegin' (внутри targetElement, перед его первым дочерним элементом). 'beforeend' (внутри targetElement, после его последнего дочернего элемента), 'afterend' (после targetElement). Ничего не возвращает. Выбросит SyntaxError при нераспознанном значении position. ",
          "id": 22.45
        },
        {
          "name": "Element.localName",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство только для чтения, возвращающее локальную часть составного имени элемента (ранее это API было установлено у Node). Применимо к XML-документам, локальная часть имени - та, что следует после двоеточия.",
          "id": 22.46
        },
        {
          "name": "Element.matches()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nvar result = element.matches(selectorString) \nпроверяет, может ли элемент быть выбран по указанному селектору selectorString. Возвращает булево значение. При неправильно прописанном селекторе выбросит SyntaxError.",
          "id": 22.47
        },
        {
          "name": "Element.namespaceURI",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство только для чтения, возвращающее пространство имен элемента или null, если элемент не в пространстве имен (ранее этот API был установлен у Node). Это не вычисляемое значение, это результат поиска пространства имен, основанного на проверке объявленного пространства имен в области видимости. Пространство имен URI узла замораживается в момент создания узла. В ранних версиях Firefox пространство име URI у HTML-элементов в HTML-документах было null, в более поздних, в соответствии с HTML5, это http://www.w3.org/1999/xhtml, как у XHTML. Вы можете создать элемент с определенным пространством имен URI, сипользуя старый метод document.createElementNS(). Формально DOM не обрабатывает и не принуждает к валидации пространства имен. Валидация производится приложением, если это необходимо. Также имейте в виду, что префикс пространства имен, однажды установленный у конкретного элемента, не может быть изменен.",
          "id": 22.48
        },
        {
          "name": "Element.onauxclick",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие auxclick возникает на элементе Element, когда вторичная клавиша на управляющем устройстве (любая кнопка, кроме первичной - обычно, левой) нажата и отпущена на этом элементе. Возникает именно при последовательности возникновения событий mousedown - mouseup. Интерфейс: MouseEvent, свойство-обработчик: onauxclick, всплытие: да, отменяемость: да. Абсолютное большинство браузеров расценивают клик средней кнопкой как команду открыть ссылку в новой вкладке, в т.ч. так поступает Firefox. Это поведение можно отменить вызовом preventDefault() на обработчике события auxclick. При отслеживании события auxclick, возникающего на элементах, не поддерживающих введение данных или навигацию, вам скорее всего захочется однозначно предотвратить все посторонние действия, которые может вызвать нажатие средней кнопки на мыши. В операционной системе Windows это обычно автоскроллинг, а на macOS и Linux - команда \"вставить из буфера обмена\". Это можно предотвратить, изменив поведение по умолчанию событий mousedown и pointerdown. Вдобавок вам может понадобиться обезопасить себя от открытия контекстного меню правой кнопкой. Из-за различий в синхронизации между операционными системами это поведение не устранимо у ивента auxclick. Вместо этого можно предотвраить дефолтное поведение ивента contextmenu. ",
          "id": 22.49
        },
        {
          "name": "Element.onblur",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие blur возникает, когда элемент теряет фокус. Главное отличие от ивента focusout, что focusout всплывает, а blur нет. Ивент, противоположный blur - focus. Интерфейс: FocusEvent, свойство-обработчик: onblur, синхронное, составное, всплытие: нет, отменяемость: нет. Делегировать ивент можно двумя путями: использованием события focusout или установкой у отслеживателя addEventListener() параметра useCapture в true.",
          "id": 22.5
        },
        {
          "name": "Element.oncancel",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие cancel запускается на элементе <dialog> когда пользователь указывает браузеру, что необходимо закрыть текущий открытый диалог. Например, браузер может запустить это событие, если пользователь нахмет клавишу Escape или кликнет на кнопку \"Закрыть диалог\", являющуюся частью пользовательского интерфейса браузера. Интерфейс: Event, обработчик: oncancel, всплытие: нет, отменяемое: да.",
          "id": 22.51
        },
        {
          "name": "Element.onclick",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "элемент получает событие click, когда на него нацелено управляющее устройство и его кнопка (главная кнопка мыши) нажимается и отпускается, пока курсор находится внутри элемента. Интерфейс: MouseEvent, свойство-обработчик: onclick, всплытие: да, отменяемость: да. Если кнопка была нажата на одном элементе и курсор сдвинулся, прежде чем кнопка была отпущена, на другой элемент, ивент запустится на предке, содержащем оба элемента. click возникает именно в таком порядке возникновения событий: mousedown - mouseup. Объект MouseEvent, передающийся обработчику события click, содержит свойство detail, показывающее сколько раз был \"кликнут\" целевой элемент target. Другими словами, detail будет равно 2 при двойном клике, 3 при тройном клике и т.д. Счетчик сбрасывется по прошествии короткого периода времени, если за это время не было никаких кликов, этот интервал может меняться от браузера к браузеру и на разных платформах. На интервал также возможно влияние пользовательских настроек, например, настройки доступности могут увеличивать этот интервал для облегчения множественных кликов на адаптивных интерфейсах. IE 8 и 9 страдают от бага, когда элементы с вычисленным background-color прозрачного фона лежат поверх всех других элементов и не могут получить событие click. Вместо этого событие возникает на нижележащих элементах. Исправить это можно установив background-color: rgba(0,0,0,0) или установив opacity:0 и сделать фоновый цвет непрозрачным (для IE9). Для обеих версий баг исправим установкой фильтра filter: alpha(opacity=0) и определением фона как непрозрачного. У Safari7 и некоторых более ранних версий был баг, когда события click не запускались на элементах, которые по природе своей не интерактивны (например, <div>) и который не позволял пркреплять отслеживатели события непосредственно к самим элементам (использовалось только делегирование). Решить проблему можно установкой у элемента или любого его предка cursor: pointer, установкой заглушки onclick = \"void(0)\" как атрибута у элемента или его предков (кроме <body>), использованием действительно интерактивного элемента (например, <a>; кроме него Safari считает интерактивными area, button, img, input, label, textarea и некоторые другие элементы) или неиспользованием делегировнаия события click. ",
          "id": 22.52
        },
        {
          "name": "Element.oncontextmenu",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие contextmenu возникает, когда пользователь пытвеется открыть контекстное меню. Фактически запускаетс кликом правой кнопки мыши или кнопки вызова контекстного меню. В последнем случае, контекстное меню отображается у нижнего левого края элемента, на котором находится фокус, если только элемент не является деревом, тогда меню отобразится у нижнего левого края текущего ряда. Любой клик правой кнопкой мыши, не предотвращенный методом preventDefault() приведет к появлению события contextmenu, запущенном на целевом элементе. Интерфейс: MouseEvent, свойство-обработчик: oncontextmenu, всплытие: да, отменяемость: да. ",
          "id": 22.53
        },
        {
          "name": "Element.oncopy",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие copy запускается, когда пользователь инициирует копирование через интерфейс пользователя. Действие по умолчанию - копирование выбранного в буфер обмена. Обработчик для этого ивента может изменять содержимое буфера обмена посредством вызова setData(format, data) на свойстве ClipboardEvent.clipboardData и отмены действия по умолчанию методом event.preventDefault(). Но, в любом случае, обработчик не может прочитать данные буфера обмена. Возможно смоделировать и направить искусственную копию ивента, но это не подействует на систему буфера обмена. Интерфейс: ClipboardEvent, обработчик: oncopy, всплытие: да, отменяемость: да.",
          "id": 22.54
        },
        {
          "name": "Element.oncut",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие cut возникает, когда пользователь инициирует действие \"cut\" через пользовательский интерфейс браузера. Если пользователь пытается воздействовать на нередактируемый контент, ивент cut все равно возникает, но объект ивента не содержит данных. Действие обработчика по умолчанию - копирование текущих выбранных данных в системный буфер обмена и удаление их из документа. Обработчик может изменять содержимое буфера обмена посредством вызова метода setData(format, data) на свойстве ClipboardEvent.clipboardData и отмены действия по умолчанию методом event.preventDefault(). Тем не менее, помните, что отмена действия по умолчанию также предовратить возможность обновления документа. Поэтому обработчик, которым вы эмулируете действие по умолчанию, одновременно с изменением буфера обмена должен самостоятельно удалить выбранные данные из элемента. Обработчик не может читать данные из буфера обмена. Возможно смоделировать и направить искусственную копию ивента, но это не подействует на систему буфера обмена. Интерфейс: ClipboardEvent, обработчик: oncut, всплытие: да, отменяемость: да.",
          "id": 22.55
        },
        {
          "name": "Element.ondblclick",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие dblclick возникает, когда производится двойное нажатие на кнопку управляющего устройства (на первичную кнопку мыши), когда производится быстрый двойной клик на одном и том же элементе в течении очень короткого промежутка времени. Фактически возникает после двух событий click (в более широком понимании, после двух пар mousedown - mouseup). Интерфейс: MouseEvent, свойство-обработчик: ondblclick, всплытие: да, отменяемость: да. ",
          "id": 22.56
        },
        {
          "name": "Element.onerror",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие error запускается на объекте Element, когда ресурс невозможно загрузить или использовать. Например, если в скрипте встречается ошибка выполнения или искомое изображение не найдено или неиспользуемо. Интерфейс: Event или UIEvent, свойство-обработчик: onerror, всплытие: нет, отменяемое: нет. Объект ивента - экземпляр UIEvent, если оно было сгенерировано элементом пользовательского интерфейса, иначе - это экземпляр Event.",
          "id": 22.57
        },
        {
          "name": "Element.onfocus",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие focus возникает, когда элемент получает фокус.Главная разница между этим событием и focusin в том, что focusin всплывает, а focus нет. Противоположность focus - blur. Интерфейс: FocusEvent, свойство-обработчик: onfocus, синхронное, составное, всплытие: нет, отменяемость: нет. Есть два способа делегирования этого события: использование ивента focusin или установка параметра useCapture у addEventListener() в true. ",
          "id": 22.58
        },
        {
          "name": "Element.onfocusout",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие focusout возникает, когда элемент практически теряет фокус. Главное отличие от ивента blur - focusout всплывает (blur - нет). Противоположность focusout - focusin. Интерфейс: FocusEvent, свойство-обработчик - onfocusout, синхронное, составное, всплывает: да, отменяемое: нет. ",
          "id": 22.59
        },
        {
          "name": "Element.onfullscreenchange",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство-обработчик события fullscreenchange, запускающийся при переходе элемента в или из полноэкранного режима. Синтаксис - \ntargetDocument.onfullscreenchange = eventHandler\nЗначение свойства - обработчик, демонстрирующий, что элемент переведен в или из полноэкранного режима. ",
          "id": 22.6
        },
        {
          "name": "Element.onfullscreenerror",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "свойство-обработчик события fullscreenerror, отправляющегося элементу при возникновении ошибок во время попытки перехода в или из полноэкранного режима. Значение свойства - обработчик ошибок. Синтаксис - \nelement.onfullscreenerror = eventHandler. ",
          "id": 22.61
        },
        {
          "name": "Element.onkeydown",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие keydown запускается, когда нажата клавиша на клавиатуре. В отличие от события keypress, событие keydown запускается для всех клавиш, вне зависимости от их символьного значения. Интерфейс: KeyboardEvent, событие-обработчик: onkeydown, всплытие: да, отменяемость: да. События keydown и keyup предоставляют цифровой код, показывающий какая клавиша была нажата, в то время как keypress показывает какой символ был введен. Например, \"а\" нижнего регистра будет обозначена как 65 у keydown, но 97 у keypress. \"А\" большого регистра будет под обозначением 65 у всех ивентов. Клавиатурные события генерируются только <input>, <textarea> и другими элементами с атрибутом contentEditable или tabindex=\"-1\".  ",
          "id": 22.62
        },
        {
          "name": "Element.onkeyup",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие keyup возникает, когда клавиша отпущена. Интерфейс: KeyboardEvent, свойство-обработчик: onkeyup, всплытие: да, отменяемость: да. События keydown и keyup предоставляют цифровой код, показывающий какая клавиша была нажата, в то время как keypress показывает какой символ был введен. Например, \"а\" нижнего регистра будет обозначена как 65 у keydown, но 97 у keypress. \"А\" большого регистра будет под обозначением 65 у всех ивентов. ",
          "id": 22.63
        },
        {
          "name": "Element.onmousedown",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "mousedown - событие возникает на элементе Element, когда кнопка управляющего устройства нажата, в то время как курсор находится внутри этого элемента. Отличия от ивента click в том, что click запускается после полной процедуры клика - кнопка мыши нажата и отпущена, пока курсор находится внутри одного и того же элемента. mousedown возникает в тот момент, когда кнопка только нажата. Интерфейс: MouseEvent, свойство-обработчик: onmousedown, всплытие: да, отменяемость: да. ",
          "id": 22.64
        },
        {
          "name": "Element.onmouseenter",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие mouseenter возникает на элементе, когда управляющее устройство (обычно мышь) передвигается к элементу и его указатель начинает появляеться над элементом, на котором будет запущено событие. Интерфейс: MouseEvent, свойство-обработчик: onmouseenter, всплытие: нет, отменяемость: нет. Вместе с некоторым сходством с событием mouseover, mouseenter отличается тем, что не всплывает и не перенаправляется ни к каких потомкам, когда курсор перемещается от одного потомка к другому. В итоге, mouseenter отсылается к каждому вложенному элементу в иерархии, прежде чем достигнет самого глубокого. mouseover будет послано самому глубоковложенному элементу и только один раз, а затем начинает всплывать, пока не достигнет обработчика или корневого элемента. Из-за такого поведения, при обработке события на глубоковложенных элементах возникает огромное число событий mouseenter, что может привести к проблемам с производительностью, поэтому в таких случаях предпочтительнее mouseover. Вместе с событием mouseleave (запускающимся, когда мышь покидает элемент) mouseenter работает очень похоже на CSS-псевдокласс :hover. ",
          "id": 22.65
        },
        {
          "name": "Element.onmouseleave",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие mouseleave возникает на элементе, когда курсор управляющего устройства (обычно мыши) уходит с него. Интерфейс: MouseEvent, свойство-обработчик: onmouseleave, всплытие: нет, отменяемость: нет. Отличие от mouseout - mouseleave не всплывает. Это значит, что событие возникает когда курсор покидает как элемент, так и всех его потомков, в то время как mouseout возникает, когдв курсор уходит с элемента или с его потомка (даже если все еще находится в родительском элементе). ",
          "id": 22.66
        },
        {
          "name": "Element.onmousemove",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие mousemove возникает на элементе, когда управляющее устройство (обычно мышь) двигается, но курсор все еще внутри элемента. Интерфейс: MouseEvent, свойство-обработчик: onmousemove, всплытие: да, отменяемость: да. ",
          "id": 22.67
        },
        {
          "name": "Element.onmouseout",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие mouseout возникает на элементе, когда указующее устройство (обычно мышь) передвигает курсор так, что он больше не находится внутри элемента или кого-либо из его детей. mouseout также направляется к элементу, если курсор входит в дочерний элемент, потому что дочерний элемент визуально перекрывает родительский. Интерфейс: MouseEvent, свойство-обработчик: onmouseout. всплытие: да, отменяемость: да. ",
          "id": 22.68
        },
        {
          "name": "Element.onmouseover",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие mouseover возникает на элементе, когда указующее устройство (такое как мышь или трэкпэд) используется для перемещения курсора на элемент или на одного из его дочерних элементов. Интерфейс: MouseEvent, свойство-обработчик: onmouseover, всплытие: да, Отменяемость: да. ",
          "id": 22.69
        },
        {
          "name": "Element.onmouseup",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие mouseup возникает на элементе, когда кнопка указующего устройства (такого как мышь или трэкпэд) отпущена, при этом курсор находится внутри этого элемента. mouseup - противоположность ивенту mousedown. Интерфейс: MouseEvent, свойство-обработчик: onmouseup, всплытие: да, отменяемость: да. ",
          "id": 22.7
        },
        {
          "name": "Element.onpaste",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие paste возникает, когда пользователь инициирует действие \"вставить\" через пользовательский интерфейс. Если курсор располагается над редактируемым контентом (например, в <textarea> или над элементом с атрибутом contenteditable в значении true), то действием по умолчанию будет вставка содержимого буфера обмена в документ в том месте, где находится курсор. Обработчик этого события может иметь доступ к содержимому посредством вызова getData() на свойстве clipboardData. Для изменения предустановленного поведения (например, для вставки неких различных данных или изменения содержимого буфера обмена) обработчик события должен отменить предустановленное действие с помощью event.preventDefault() и затем вставить нужные данные в ручном режиме. Возможно создание и направление искусственного события вставки, но оно не может воздействовать на контент документа. Интерфейс: ClipboardEvent, свойство-обработчик: onpaste, всплытие: да, отменяемость: да. ",
          "id": 22.71
        },
        {
          "name": "Element.onscroll",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие scroll запускается на скроллящемся элементе. в iOS событие не возникает во время скроллинга, а только после его завершения. Интерфейс: Event, обработчик: onscroll, всплытие: нет, отменяемое: нет.",
          "id": 22.72
        },
        {
          "name": "Element.onselect",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "cобытие select возникает тогда, когда выделяется текст. Не доступно для всех элементов во всех языках. Например, в HTML, событие select можно направить только к элементам формы <input type=\"text\"> и <textarea>. Интерфейс: UIEvent (если сгенерировано из пользовательского интерфейса), иначе Event, обработчик: onselect, всплытие: да, отменяемость: нет. ",
          "id": 22.73
        },
        {
          "name": "Element.ontouchcancel",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие touchcancel запускается, когда одна или больше точек прикосновения теряют свою организацию в своей методике реализации (например, создано слишком много точек прикосновения). Интерфейс: TouchEvent, свойство-обработчик: ontouchcancel, всплытие: да, отменяемость: нет. ",
          "id": 22.74
        },
        {
          "name": "Element.ontouchend",
          "classDeck": "card",
          "deck": "Element",
          "type": "event",
          "description": "событие touchend возникает, когда одна или более точек прикосновения удаляются с экрана устройства. Интерфейс: TouchEvent, свойство-обработчик: ontouchend, всплытие: да, отменяемость: да. ",
          "id": 22.75
        },
        {
          "name": "Element.ontouchmove",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие touchmove возникает тогда, когда одна или больше точек прикосновения перемещаются по экрану устройства. Интерфейс: TouchEvent, свойство-обработчик: ontouchmove, всплытие: да, отменяемость: да.",
          "id": 22.76
        },
        {
          "name": "Element.ontouchstart",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие touchstart возникает, когда одна или более точек прикосновения появляются на экране устройства. Интерфейс: TouchEvent, свойство-обработчик: ontouchstart, всплытие: да, отменяемость: да. ",
          "id": 22.77
        },
        {
          "name": "Element.onwheel",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "событие wheel возникает, когда пользователь крутит колесо устройства (обычно мыши). Не путайте его с событием scroll. Обычно используется для изменения масштаба. Интерфейс: WheelEvent, обработчик: onwheel, всплытие: да, отменяемость: да. ",
          "id": 22.78
        },
        {
          "name": "Element.outerHTML",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "атрибут DOM-интерфейса Element, содержит сериализованный HTML-фрагмент, описывающий элемент и всех его потомков.Свойство также может быть установлено для замены элемента узлами, спарсенными из приведенной строки. Для простого получения HTML-представления из контента элемента или для замены содержимого элемента, лучше используйте свойство innerHTML. \nСинтаксис - \nvar content = element.outerHTML \nили \nelement.outerHTML = htmlString\nВозвращаемое значение - DOMString, содержащий сериализованный HTML элемента и его потомков. Установка значения заменит элемент и всех его потомков новым деревом DOM, сконструированным после парсинга строки htmlString. Выбросит SyntaxError при попытке установки нового значения с использованием строки с не валидным HTML. Выбросит NoModificationAllowedError при попытке установки значения на элементе - прямом потомке Document, таком как Document.documentElement. \nЕсли элемент не имеет родителя, установка свойства outerHTML не изменит его или его потомков. Многие браузеры при этом выбросят исключение. Также, при перемещении элемента в документе переменная, на котором было установлено свойство, все еще будет хранить ссылку на оригинальный элемент.",
          "id": 22.79
        },
        {
          "name": "Element.part",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство интерфейса Element, представляющее идентификаторы элемента part (у которых установлен атрибут part - принадлежности к shadow DOM), возвращает DOMTokenList. Может использоваться для стилизации отдельных частей теневого DOM через селектор псевдоэлемента ::part. Синтаксис - \nlet partList = element.part",
          "id": 22.8
        },
        {
          "name": "Element.prefix",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство только для чтения, возвращающее префикс пространства имен указанного элемента (в виде строки) или null, если префикса нет (ранее этот API был установлен у Node). Используется только с документами с MIME-типом XML, с HTML не работает.",
          "id": 22.81
        },
        {
          "name": "Element.pseudo()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "экспериментальный метод, представляющий дочерний псевдоэлемент по указанному селектору псевдоэлемента.",
          "id": 22.82
        },
        {
          "name": "Element.querySelector()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement = baseElement.querySelector(selectors) \nвозвращает первый элемент, найденный среди потомков базового элемента (baseElement, на котором вызван метод), отвечающий установленной группе селекторов (selectors). Сначала проверяются все элементы в дереве на соответствие селекторам, затем отобранные проверяются на то, являются ли они потомками базового элемента и возвращается первый найденный. Если такового нет - вернется null. Если селекторы прописаны с ошибками CSS-синтаксиса, выбросится исключение SyntaxError. Можно проводить поиск на соответствие точному значению CSS-свойства - по селектору атрибута (в квадратных скобках).\nvar el = document.body.querySelector(\"style[type='text/css'], style:not([type])\");\nПутем точного подбора селекторов в их определенной последовательности можно легко находить элементы вне базового элемента. В интерфейсе Document существует аналогичный метод Document.querySelector(). ",
          "id": 22.83
        },
        {
          "name": "Element.querySelectorAll()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelementList = element.querySelectorAll(selectors) возвращает статичный (не живой) список узлов NodeList, представляющий перечень элементов, соответствующих хотя бы одному из установленной группы CSS-селекторов и являющихся потомками элемента, на котором был вызван метод. Реализация метода базируется на методе миксина ParentNode.querySelectorAll(). Следите за правильным синтаксисом CSS-селекторов, иначе будет выброшено исключение. Селекторы отделяются друг от друга запятыми. Невалидные для CSS символы должны экранироваться обратными слэшами, а т.к. они используются в JS - будьте осторожны в применении строковых литералов. При наличии в списке CSS-псевдоэлемента, всегда вернется пустой список. Поиск можно осуществлять с задействованием dataset.\n<div class=\"funnel-chart-percent2\">3700.00%</div>\n<div class=\"funnel-chart-percent3\">0.00%</div>\nconst refs = [...document.querySelectorAll(`[data-name*=\"funnel-chart-percent\"]`)];\nДля поиска, к примеру, элемента <p> с классом внутри <div> с определенным id можно вызвать метод дважды.\nvar container = document.querySelector(\"#test\");\nvar matches = container.querySelectorAll(\"div.highlighted > p\");\nДоступ к узлам списка осуществляется как в массиве - при помощи циклов for или for...of или метода Array.forEach(). Т.к. это не настоящий массив, на нем невозможно вызвать методы Array.some(), Array.slice(), Array.map()... Для трансформации в массив используйте Array.from(nodeList). При длине массива 0 узлов в нем нет (сопоставлений не найдено). \nИногда библиотека ведет себя непредсказуемо, изменяя поведение поиска. Для возврата к точному соответствию поведению (поиску только среди потомков) применяют псевдо-класс :scope.",
          "id": 22.84
        },
        {
          "name": "Element.releasePointerCapture()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \ntargetElement.releasePointerCapture(pointerId) \nудаляет (останавливает) \"захват\" указателя, заранее установленного как \"указатель\" (pointer) у PointerEvent. Смотрите метод Element.setPointerCapture() с объяснениями что такое \"захват указателя\" (pointer capture) и как его установить у отдельного элемента. pointerId - уникальный идентификационный номер указателя, если он неверный - выбросится InvalidPointerId.  ",
          "id": 22.85
        },
        {
          "name": "Element.removeAttribute()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.removeAttribute(attrName) \nудаляет атрибут с именем attrName у элемента element. Если атрибута с указанным именем не существует, ошибка не возникнет. Метод возвращает undefined. Использовать метод следует вместо установки у атрибута null напрямую или с применением setAttribute(), поскольку многие атрибуты не рассчитаны на нулевое значение. ",
          "id": 22.86
        },
        {
          "name": "Element.removeAttributeNS()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.removeAttributeNS(namespase, attrName) \nудаляет атрибут с именем attrName пространства имен namespase у элемента element. ",
          "id": 22.87
        },
        {
          "name": "Element.requestFullscreen()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nvar promise = element.requestFullscreen(options) \nвыдает асинхронный запрос на отображение элемента в полноэкранном режиме. Не гарантируется, что элемент будет показан в таком виде. Если на показ в таком виде элемента разрешение дано, возвращаемый Promise будет со значением resolved и элемент получит событие fullscreenchange, дающий элементу понять, что он теперь в полноэкранном режиме. Если разрешение отклонено, промис выбрасывается и элемент получает событие fullscreenerror. Если элемент отделен от основного документа, то перечисленные события получит основной документ. Ранние имплементации этого APi всегда направляли такие события основному документу, а не элементу, что требовало корректировки. Проверяйте совместимость браузеров перед использованием. Метод должен вызываться при ответе на запрос пользователя или устройства на изменение ориентации экрана, иначе изменить ориентацию не получится. Необязательный параметр options - объект FullscreenOptions, предоставляющий опции контроля поведения перехода в полноэкранный режим. Пока это единственная опция navigationUI, определяющая, отображать ли элементы навигации в полноэкранном режиме. По-умолчанию - 'auto' (на усмотрение браузера). Возвращаемое значение метода - Promise c resolved-значеним undefined после переключения в полноэкранный режим.\nПомимо стандартных ошибок, выполнение приводит к условиям появления других исключений, обусловленных отклоненным промисом. Обработчик может перехватить следующие виды исключений: TypeError (в ситуациях, когда: документ, содержащий данный элемент, не полностью активный, т.е. это не текущий активный документ; элемент не содержится в документе; у элемента нет разрешения на использование полноэкранной возможности по причинам особенностей конфигурации или других возможностей; элемент и документ - это один узел). \nЭлемент, который вы хотите переключить в полноэкранный режим, должен соответствовать небольшому числу требований: это должен быть один из стандартных HTML-элементов или <svg> или <math>; это не должен быть элемент <dialog>; он должен размещаться в пределах документа высшего уровня или в <iframe>, к которому применен атрибут allowfullscreen. Дополнительно проверяйте Feature Policy, разрешение fullscreen должно быть дано. Проверить, доступно ли переключение элемента в полноэкранный режим, можно, используя возвращаемый методом Promise, Включен ли или выключен режим другими частями кода, можно узнать, установив на Document отслеживатели события fullscreenchange. Это важно и по другим причинам: пользователь может включить режим самостоятельно или выключить его может запущенное стороннее приложение.",
          "id": 22.88
        },
        {
          "name": "Element.requestPointerLock()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "экспериментальный метод, позволяющий вам сделать асинхронный запрос на \"прикрепление\" указателя к данному элементу. Для того, чтобы узнать, удачно завершился запрос или нет, необходимо отслушивать события pointerlockchange и pointerlockerror на уровне Document. Синтаксис - \nelement.requestPointerLock(). ",
          "id": 22.89
        },
        {
          "name": "Element.scroll()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.scroll(x, y) \nили \nelement.scroll({ScrollToOptions}) \nпрокручивает элемент на указанный набор координат внутри данного элемента. x - пиксель на горизонтальной оси элемента, который вы хотите отобразить в левом верхнем углу, y - такой пиксель на вертикальной оси. options - ScrollToOptions-словарь спецификации CSSOM, устанавливающий, куда должен прокручиваться элемент и должна ли прокрутка быть плавной.",
          "id": 22.9
        },
        {
          "name": "Element.scrollBy()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.scrollBy(x, y) \nили \nelement.scrollBy({ScrollToOptions})\nпрокручивает элемент на указанное расстояние (в пикселях или с указанием словаря ScrollToOptions). ",
          "id": 22.91
        },
        {
          "name": "Element.scrollHeight",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство только для чтения, это мера высоты контента элемента, включая невидимый из-за переполнения контент на экране. Значение равно минимальной высоте элемента (в пикселях), необходимой для того, чтобы контент поместился в экран просмотра без использования вертикального скролбара. Вычисляется таким же образом, как clientHeght, включает внутренние отступы, но не границы, поля или сам скролбар (если он представлен). Также може включать высоту псевдо-элементов, таких как ::before или ::after. Если контент может поместиться без вертикального скролбара, то свойство scrollHeight элемента равно его clientHeight. Значение округляется, для точных цифр используйте Element.getBoundingClientRect(). \nВариант проверки на то, что документ находится в положении, когда прокручен до самого конца.\nelement.scrollHeight - element.scrollTop === element.clientHeight;// вернет true\nОдно из самых известных применений - проверка того, что пользователь, например, прочитал правила.",
          "id": 22.92
        },
        {
          "name": "Element.scrollIntoView()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.scrollIntoView() \nили \nelement.scrollIntoView(alignToTop) \nили \nelement.scrollIntoView({scrollIntoViewOptions}) \nпрокручивает родительский контейнер элемента так, чтобы элемент, на котором был вызван метод, был видим пользователю. Булев параметр alignToTop - если true, верхняя граница элемента будет выровнена по верхней границе видимой области прокручиваемого предка, соответствует параметрам scrollIntoViewOptions {block: \"start\", inline: \"nearest\"}, установлено по умолчанию; если false, нижняя граница элемента будет выровнена по нижней границе видимой области прокручивамого предка, соответствует {block: \"end\", inline: \"nearest\"}. \nscrollIntoViewOptions - объект со следующими необязательными свойствами: behavior (определяет анимацию перехода, auto (по умолчанию) или smooth), block (определяет вертикальное выравнивание, start (по умолчанию), center, end или nearest), inline (горизонтальное выравнивание, start, center, end или nearest (по умолчанию)). В зависимости от положения других элементов целевой элемент может не прокручиваться точно к верху или низу.",
          "id": 22.93
        },
        {
          "name": "Element.scrollLeft",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство для получения или установки количества пикселей, на которое контент элемента прокручен от левого края. Если направление потока текста справа налево (rtl), то scrollLeft == 0, когда горизонтальный скролбар находится в крайней правой возиции (в начале скроллинга) и затем увеличивает значение со знаком минус при скроллинге к концу контента (влево). Синтаксис - var sLeft = element.scrollLeft (вернет целое значение в пикселях) или element.scrollLeft = 10. Значение может быть любым целым числом. Тем не менее: если элемент не прокручиваемый, scrollLeft == 0, если  значение меньше 0 (больше нуля при rtl), scrollLeft установлен в 0; если значение больше максимального, на которое контент может быть прокручен, scrollLeft установлен на максимум.",
          "id": 22.94
        },
        {
          "name": "Element.scrollLeftMax",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "нестандартизованное свойство (Mozilla) только для чтения, возвращаюшее Number, представляющий максимально возможное для элемента значения скроллинга (вправо).",
          "id": 22.95
        },
        {
          "name": "Element.scrollTo()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.scrollTo(x, y) \nили \nelement.scrollTo(ScrollToOptions) \nпрокручивает (окно просмотра) к указанным координатам внутри данного элемента. x - пиксель по горизонтальной оси, который вы хотите отобразить в верхнем левом углу просмотра, y - пиксель на вертикальной оси. Объект ScrollToOptions с выбранными параметрами.",
          "id": 22.96
        },
        {
          "name": "Element.scrollTop",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство для получения или установки количества пикселей, на которые контент прокручен вертикально. Это мера расстояния от верха элемента до самой высокой точки его видимого контента. Если при этом не создается вертикальный скролбар, то значение scrollTop равно нулю. С применением на корневом (<html>) элементе вернет scrollY, это особый случай. Синтаксис - \nvar.scrollPos = element.scrollTop или element.scrollTop = 25\nЗначение может быть любым целым числом. Тем не менее: если элемент не прокручиваемый (не переполнен или имеет свойство \"non-scrollable\"), scrollTop == 0; свойство не откликается на негативные значения, устанавливая вместо них 0; если устанавливаемое значение превышает максимально возможное для прокручивания элемента, будет установлено максимальное значение.",
          "id": 22.97
        },
        {
          "name": "Element.scrollTopMax",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "нестандартизованное свойство (Mozilla) только для чтения, возвращающее Number, представляя максимум вертикального скроллинга, возможного у данного элемента.",
          "id": 22.98
        },
        {
          "name": "Element.scrollWidth",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство только для чтения, это мера ширины контента элемента, включающая не видимый на экране из-за переполнения контент. Значение равно минимальной ширине элемента, необходимой для того, чтобы уместить весь контент в окно просмотра без использования горизонтального скролбара. Ширина рассчитывается таким же образом, что и clientWidth, включает внутренние отступы элемента, но не его границы, поля или вертикальный скролбар (если он представлен). Также может включать ширину псевдо-элементов (таких как ::before или ::after). Если контент помещается в элементе без горизонтального скролбара, scrollWidth == clientWidth. Значение округляется до целых чисел, для более точных цифр используйте element.getBoundingClientRect(). ",
          "id": 22.99
        },
        {
          "name": "Element.setAttribute()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.setAttribute(name, value) \nустанавливает значение определенного атрибута у целевого элемента. Если атрибут уже существует, его значение обновится, иначе будет добавлен новый атрибут с установленными именем (name) и значением (value). Для получения текущего значения атрибута используйте .getAttribute(), для удаления атрибута - .removeAttribute(). Строка с name автоматически приводится к нижнему регистру при вызове метода на HTML-элементе в HTML-документе. value - также строчное значение, любое нестрочное значение будет приведено к строке. Для булевых значений true принято указывать как пустую строку \"\". Некоторые используют нестандартизованный способ с указанием значения в имени (\"disabled: true\"). Для удаления атрибута лучше использовать .removeAttribute() вместо установки значения в null, т.к. значение будет приведено к строке и вместо удаления атрибута вы получите атрибут со значением \"null\". Метод возвращает undefined. Выбросит исключение InvalidCharacterError, если в имени присутствуют недопустимые символы. ",
          "id": 23
        },
        {
          "name": "Element.setAttributeNS()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.setAttributeNS(namespace, name, value) \nдобавляет новый атрибут или изменяет значение уже имеющегося с данным пространством имен и именем. namespace - ссылка на пространство имен в виде строки. Имя name - классифицированное имя (префикс пространства имен), двоеточие за ним и имя атрибута.\nd.setAttributeNS('http://www.mozilla.org/ns/specialspace', 'spec:align', 'center');",
          "id": 23.01
        },
        {
          "name": "Element.setCapture()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "нестандартизованный метод в синтаксисе \nelement.setCapture(retargetToElement) \nперенаправляет во время обработки события мыши mousedown все остальные события мыши на данный элемент до тех пор, пока не будет отпущена кнопка мыши или не будет вызван метод document.releaseCapture(). У него плохая поддержка и различная реализация, пробуйте использовать метод интерфейса Pointer Events API element.setPointerCapture(). retargetToElement - булев атрибут, если true - все события будут перенаправлены прямо на этот элемент, если false - события смогут также запускаться на потомках этого элемента. ",
          "id": 23.02
        },
        {
          "name": "Element.setPointerCapture()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \ntargetElement.setPointerCapture(pointerId) \nиспользуется для установки определенного элемента в качестве фиксированной цели всех будущих событий курсора. Последующие события курсора будут нацеливаться на зафиксированный элемент до тех пор, пока захват не будет отменен (посредством element.releasePointerCapture()). Если установлен захват курсора, события pointerover, pointerout, pointerenter и pointerleave генерируются только при пересечении границ зафиксированной цели. Так подавляются подобные ивенты на всех других элементах. Захват курсора позволяет событиям при определенном событии курсора (PointerEvent) перенацеливаться на определенный элемент вместо нормальной (или тестируемой) цели на месте курсора. Это можно использовать для того, чтобы убедиться, что элемент продолжает получать события курсора, даже если курсор контактного устройства уходит с элемента (например, во время вертикальной или горизонтальной прокрутки). pointerId - свойство-геттер интерфейса PointerEvent, уникальный id определенного ивента курсора, генерируется случайным образом. Метод возвращает undefined, выбрасывает исключение NotFoundError, если указанный pointerId не соответствует ни одному активному курсору.",
          "id": 23.03
        },
        {
          "name": "Element.shadowRoot",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство только для чтения, представляющее теневой корень (shadow root) элемента. Используйте Element.attachShadow() для добавления теневого корневого узла к существующему элементу. Синтаксис - \nvar shedowRoot = element.shadowRoot\nВозвращает экземпляр объекта ShadowRoot или null, если нет ассоциированного shadow root, присоединенного в закрытом режиме (ShadowRoot.mode == 'closed'). ",
          "id": 23.04
        },
        {
          "name": "Element.slot",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "экспериментальное свойство интерфейса, возвращаюшее имя слота в теневом DOM, в который вставлен элемент. Слот - это плейсхолдер внутри вебкомпонента, который пользователи могут наполнить собственной разметкой. Синтаксис - \nvar aString = element.slot \nили \nelement.slot = aString",
          "id": 23.05
        },
        {
          "name": "Element.tagName",
          "classDeck": "card",
          "deck": "Element",
          "type": "property",
          "description": "свойство только для чтения, возвращающее имя тега элемента, на котором оно вызвано. Например, если элемент - <img>, его свойство tagName == \"IMG\" (у HTML-документов; у XML/XHTML-документов может быть другим). Значение - строка с именем. Капитализация букв зависит от типа документа: в DOM HTML-документов это всегда прописные буквы (IMG, DIV...); в DOM XML-документов знавение вернется в том же виде, что было установлено в оригинальном файле (<SomeTag> == SomeTag). У объектов Element значение tagName такое же, что и у свойства nodeName, которое они наследуют у Node. ",
          "id": 23.06
        },
        {
          "name": "Element.toggleAttribute()",
          "classDeck": "card",
          "deck": "Element",
          "type": "method",
          "description": "в синтаксисе \nelement.toggleAttribute(name, force) \nпереключает булев атрибут (удаляет, если он присутствует и добавляет, если его нет) у указанного элемента. Строка с name автоматически приводится к нижнему регистру при вызове метода на HTML-элементе в HTML-документе. Опциональный параметр force - булево значение, определяющее, следует ли добавлять или удалять атрибут несмотря на его присутствие или отсутствие в данный момент. Метод вернет true, если имя атрибута в итоге присутствует у элемента и false, если его нет. Выбросится исключение InvalidCharacterError, если имя атрибута содержит один или более некорректных символов. ",
          "id": 23.07
        }
      ],
      "id": 22
    },
    {
      "name": "Error",
      "classDeck": "deck",
      "deck": "Error",
      "type": "Error",
      "description": "объекты Error создаются и выбрасываются при возникновении ошибок при выполнении кода. Объект Error также может использоваться для создания пользовательских исключений. Наряду с общим конструктором в JavaScript существуют другие конструкторы ошибок.",
      "objects": [
        {
          "name": "Error()",
          "classDeck": "card",
          "deck": "Error",
          "type": "constructor",
          "description": "конструктор в синтаксисе \nnew Error(message, fileName, lineNumber) \nсоздает объект ошибки. message - обязательный параметр, человекочитаемое сообщение об ошибке, строка. Два остальных параметра - экспериментальные, путь к файлу и номер строки, где возникла ошибка. Также возможен вызов конструктора как функции - без оператора new. Такая функция также вернет ошибку.\nconst x = Error('I was created using a function call!');\nconst y = new Error('I was constructed via the \"new\" keyword!');// the same result",
          "id": 23.1
        },
        {
          "name": "Error.prototype.columnNumber",
          "classDeck": "card",
          "deck": "Error",
          "type": "property",
          "description": "не стандартизованное свойство, хранящее номер колонки в строке кода, где случилась ошибка. Поддерживается только в Firefox. ",
          "id": 23.11
        },
        {
          "name": "Error.prototype.description",
          "classDeck": "card",
          "deck": "Error",
          "type": "property",
          "description": "не стандартизованное свойство Microsoft с описанием ошибки, сродни Error.prototype.message.",
          "id": 23.12
        },
        {
          "name": "Error.prototype.fileName",
          "classDeck": "card",
          "deck": "Error",
          "type": "property",
          "description": "не стандартизованное свойство, содержащее путь к файлу с кодом, в котором произошла ошибка. В контексте дебаггера, например, в Firefox Development Tools, вернет \"debugger eval code\". Поддерживается только в Firefox. \nvar e = new Error('Could not parse input');// throw e;// e.fileName could look like \"file:///C:/example.html\"",
          "id": 23.13
        },
        {
          "name": "Error.prototype.lineNumber",
          "classDeck": "card",
          "deck": "Error",
          "type": "property",
          "description": "не стандартизованное свойство, хранящее номер строки кода, где произошла ошибка. Поддерживается только в Firefox. ",
          "id": 23.14
        },
        {
          "name": "Error.prototype.message ",
          "classDeck": "card",
          "deck": "Error",
          "type": "property",
          "description": "человекочитаемое сообщение об ошибке. Вместе со свойством name используется в приведении к строке методом Error.prototype.toString(). По умолчанию, свойство являет собо пустую строку, но это можно изменить при создании новых экземпляров, установив аргумент message в конструкторе. ",
          "id": 23.15
        },
        {
          "name": "Error.prototype.name",
          "classDeck": "card",
          "deck": "Error",
          "type": "property",
          "description": "имя ошибки, изначально - \"Error\". Вместе со свойством Error.prototype.message участвует в приведении объекта к строке методом Error.prototype.toString(). ",
          "id": 23.16
        },
        {
          "name": "Error.prototype.number",
          "classDeck": "card",
          "deck": "Error",
          "type": "property",
          "description": "не стандартизованное свойство Microsoft с номером ошибки",
          "id": 23.17
        },
        {
          "name": "Error.prototype.stack",
          "classDeck": "card",
          "deck": "Error",
          "type": "property",
          "description": "не стандартизованное, но широко поддерживаемое свойство, позволяющее отследить все обстоятельства, при которых произошла ошибка - вызванную функцию, в каком порядке, в какой строке кода и какого файла и с какими аргументами была вызвана функция. Последовательность в стеке идет от наиболее позднего до наиболее раннего вызовов, следуя к изначальной глобальной области видимости. Каждый шаг стека идет в отдельной строке, первая часть которой - имя функции (если она не вызвана в глобальной области видимости), затем следует знак @, расположение файла (если только функция не является конструктором ошибок, выбрасывающим исключение), затем двоеточие и, если указано расположение файла, номер строки кода. \ntrace@file:///C:/example.html:9:17\nb@file:///C:/example.html:16:13\na@file:///C:/example.html:19:13\n@file:///C:/example.html:21:9\nОбъект Error может также хранить данные fileNumber, lineNumber и columnNumber, которые можно получить из выброшенного исключения, но только из него, эти данные не хранятся как \"следы\" ошибки. Реализация различна у разных браузеров и движков. ",
          "id": 23.18
        },
        {
          "name": "Error.prototype.toString()",
          "classDeck": "card",
          "deck": "Error",
          "type": "method",
          "description": "внутренний метод в синтаксисе \nerror.toSTring()\nвозвращающий строку, представляющую собой объект error. Данный метод перезаписывает метод \nObject.prototype.toString(), наследуемый всеми объектами. Работает по следующей семантической схеме:\nError.prototype.toString = function() {\n  'use strict';\n  var obj = Object(this);\n  if (obj !== this) {\n    throw new TypeError();\n  }\n  var name = this.name;\n  name = (name === undefined) ? 'Error' : String(name);\n  var msg = this.message;\n  msg = (msg === undefined) ? '' : String(msg);\n  if (name === '') {\n    return msg;\n  }\n  if (msg === '') {\n    return name;\n  }\n  return name + ': ' + msg;\n};",
          "id": 23.19
        }
      ],
      "id": 23
    },
    {
      "name": "EvalError",
      "classDeck": "deck",
      "deck": "EvalError",
      "type": "EvalError",
      "description": "объект, демонстрирующий ошибку, имеющую отношение к глобальной функции eval(). Это исключение больше не выбрасывается в языке, тем не менее объект EvalError был в нем оставлен для обеспечения совместимости. \nНаследует все свойства объекта Error.\nВнутренние свойства: \nError.prototype.message -  сообщение об ошибке. ECMA262 определяет как собственное свойство, в SpiderMonkey наследуется от Error.prototype.message. Вместе со свойством name используется в приведении к строке методом Error.prototype.toString(). По умолчанию, свойство являет собо пустую строку, но это можно изменить при создании новых экземпляров, установив аргумент message в конструкторе. \nError.prototype.name - имя ошибки, изначально - \"Error\". \nError.prototype.fileName - не стандартизованное свойство, содержащее путь к файлу с кодом, в котором произошла ошибка. В контексте дебаггера, например, в Firefox Development Tools, вернет \"debugger eval code\". Поддерживается только в Firefox. \nvar e = new Error('Could not parse input');// throw e;// e.fileName could look like \"file:///C:/example.html\"\nError.prototype.lineNumber - не стандартизованное свойство, хранящее номер строки кода, где произошла ошибка. Поддерживается только в Firefox. \nError.prototype.columnNumber - не стандартизованное свойство, хранящее номер колонки в строке кода, где случилась ошибка. Поддерживается только в Firefox. \nError.prototype.stack - не стандартизованное, но широко поддерживаемое свойство, позволяющее отследить все обстоятельства, при которых произошла ошибка - вызванную функцию, в каком порядке, в какой строке кода и какого файла и с какими аргументами была вызвана функция. Последовательность в стеке идет от наиболее позднего до наиболее раннего вызовов, следуя к изначальной глобальной области видимости. Каждый шаг стека идет в отдельной строке, первая часть которой - имя функции (если она не вызвана в глобальной области видимости), затем следует знак @, расположение файла (если только функция не является конструктором ошибок, выбрасывающим исключение), затем двоеточие и, если указано расположение файла, номер строки кода. \ntrace@file:///C:/example.html:9:17\nb@file:///C:/example.html:16:13\na@file:///C:/example.html:19:13\n@file:///C:/example.html:21:9\nОбъект Error может также хранить данные fileNumber, lineNumber и columnNumber, которые можно получить из выброшенного исключения, но только из него, эти данные не хранятся как \"следы\" ошибки. Реализация различна у разных браузеров и движков. ",
      "objects": [
        {
          "name": "EvalError()",
          "classDeck": "card",
          "deck": "EvalError",
          "type": "constructor",
          "description": "в синтаксисе \nnew EvalError(message, fileName, lineNumber) \nсоздает новый экземпляр ошибки, имеющей отношение к глобальной функции eval(). Все аргументы необязательные. message - человекочитаемое описание ошибки, fileName - имя файла с кодом, вызвавшим ошибку, lineNumber - номер строки кода, где произошла ошибка. В JavaScript этот вид ошибки больше не выбрасывается, объект оставили для совместимости.\ntry {\n  throw new EvalError('Hello', 'someFile.js', 10);\n} catch (e) {\n  console.log(e instanceof EvalError); // true\n  console.log(e.message);  // \"Hello\"\n  console.log(e.name); // \"EvalError\"\n  console.log(e.fileName); // \"someFile.js\"\n  console.log(e.lineNumber);// 10\n  console.log(e.columnNumber);// 0\n  console.log(e.stack);// \"@Scratchpad/2:2:9\\n\"\n}",
          "id": 24.1
        }
      ],
      "id": 24
    },
    {
      "name": "Event",
      "classDeck": "deck",
      "deck": "Event",
      "type": "Event",
      "description": "интерфейс, представляющий событие, имеющее место в DOM. Событие может быть инициировано действием пользователя (например, клик мышью или нажатие клавиши на клавиатуре) или сгенерировано каким-либо API во время выполнения асинхронной задачи. Оно также может запускаться программно (например, запуском метода HTMLElement.click()) или быть определено как посылаемое лишь к определенной цели событие (с использованием EventTarget.dispatchEvent()). Существует множество видов ивентов, некоторые из которых используют интерфейсы, отличные от главного интерфейса Event. Event содержит свойства и методы, общие для всех событий. Многие DOM-элементы можно сделать \"принимающими\" (\"слушающими\") эти события и запускающими код в ответ на их появление (обрабатывающими их). Обработчики событий обычно подключаются (или присоединяются) к различным элементам (<button>, <div>, <span> и т.д.) посредством метода EventTarget.addEventListener() и он обычно перезаписывает атрибутивные HTML-обработчики событий. В дальнейшем, будучи правильно подключенными, обработчики могут быть, если нужно, отключены использованием .removeEventListener(). \nПри появлении одного и того же события у элемента-родителя и его потомка возможны накладки. Когда событие запускается на элементе, имеющем родителя, современные браузеры запускают две различные фазы - захвата (capturing) и всплытия (bubbling). В фазе захвата браузер проверяет наличие обработчика данного события, зарегистрированного в режиме capturing у самого дальнего предка (<html>) и запускает его, если находит, или переходит к проверке его потомков и т.д. вниз по дереву, пока не достигнет выбранного элемента. В фазе всплытия все наоборот - проверяется наличие обработчика, зарегистрированного в режиме bubbling у отмеченного элемента, запускает его, если находит, если нет - следует далее вверх по дереву. По-умолчанию, все события в современных браузерах запускаются в режиме всплытия. В случае наличия двух обработчиков в обоих режимах первым запустится capturing, затем bubbling. Одно из решений подобных конфликтов - использование метода event.stopPropagation().",
      "objects": [
        {
          "name": "Event()",
          "classDeck": "card",
          "deck": "Event",
          "type": "constructor",
          "description": "Конструктор в синтаксисе \nnew Event(type, eventInit)\nсоздает новый Event, type - имя ивента, eventInit - словарь EventInit со следующими полями: bubbles (является ли событие всплывающим, по-умолчанию false), cancelable (может ли быть отменено, false), composed (будет ли событие запускать отслеживатели вне теневого дерева, false).\nconst evt = new Event(\"look\", {\"bubbles\": true, \"cancelable\": false});",
          "id": 25.1
        },
        {
          "name": "Event.bubbles",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "в синтаксисе \nlet doesItBubble = event.bubbles \nвернет булево значение, указываюшее, является ли событие всплывающим вверх по дереву или нет. Свойство только для чтения. ",
          "id": 25.11
        },
        {
          "name": "Event.cancelable",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "свойство интерфейса Event только для чтения, показывающее является ли событие отменяемым и, следовательно, можно ли избежать появление этого события. Если событие не отменяемое, его значение cancelable будет false и обработчик не сможет остановить его после его появления. Отслеживателям, обрабатывающим сразу несколько разновидностей событий, сможет понадобиться проверка этого свойства перед вызовом методов preventDefault() для этих ивентов. Большинство естественных для браузеров событий, являющихся отменяемыми - это те, что участвуют во взаимодействиях пользователя со страницей. Отмена событий click, scroll или beforeunload поможет уберечь пользователя от нежелательного клика по чему-либо, скроллинга или выхода из страницы соответственно. Свойство можно задавать при создании нового ивента через конструктор.",
          "id": 25.12
        },
        {
          "name": "Event.cancelBubble",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "историческая альтернатива методу Event.stopPropagation(). Установка у этого свойства true до возвращения результата от обработчика предупредит распространение этого события дальше. В юолее поздних реализациях установка значения в false не оказывает никакого влияния. Синтаксис - \nevent.cancelBubble = true/false \nили \nlet true/false = event.cancelBubble. ",
          "id": 25.13
        },
        {
          "name": "Event.composed",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "свойство только для чтения, возвращающее булево значение, показывающее, является ли событие комбинированным, т.е. способно ли распространяться за пределы теневого DOM - в стандартный DOM. Синтаксис: \nconst isComposed = event.composed. \nTrue, если событие может пересекать границы теневого DOM и проникать в стандартный, достигнув корневого элемента теневого DOM (соответственно, в стандартном DOM событие начинает распространяться именно с этого первого, корневого, узла). Все направляемые пользовательскому агенту события - комбинированные (click, touch, mouseover, copy,paste и т.д.). Большинство других видов событий - не комбинированные и значение этого свойства будет false. Например, this включает в себя искусственные ивенты, создаваемые некомбинированными - без этого свойства. Распространяться событие будет только если свойство bubbles тоже true. Тем не менее, только лишь захватывающие (capturing) комбинированные события также обрабатываются у хозяина, будучи в фазе AT_TARGET. Вы можете указать путь распространения события, по которому оно должно следовать в теневом DOM к корню DOM при помощи composedPath(). ",
          "id": 25.14
        },
        {
          "name": "Event.composedPath()",
          "classDeck": "card",
          "deck": "Event",
          "type": "method",
          "description": "в синтаксисе let eventPath = Event.composedPath() возвращает путь распространения ивента в виде массива объектов, у которых он вызвал отслеживатели. Результат не будет включать узлы теневых деревьев, если теневой корень был создан в режиме ShadowRoot.mode = closed. ",
          "id": 25.15
        },
        {
          "name": "Event.currentTarget",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "свойство только для чтения, идентифицирующее текущую цель ивента при его перемещении по DOM. Оно всегда указывает на элемент, к которому подключен обработчик ивента, в противоположность Event.target, идентифицирующему элемент, на котором ивент появился и который может быть потомком Event.currentTarget. Возвращает EventTarget (ссылку на него). Свойство доступно только при обработке обработчиком, если объект ивента просматривается в console.log, его значением будет null. Но оно доступно через прямое обращение в консоли console.log(event.currentTarget). ",
          "id": 25.16
        },
        {
          "name": "Event.defaultPrevented",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "свойство только для чтения, возвращающее булево значение, показывающее отменит ли или нет вызов Event.preventDefault() данное событие. Используется вместо устаревшего метода .getPreventDefault(). ",
          "id": 25.17
        },
        {
          "name": "Event.eventPhase",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "свойство только для чтения, показывающее, в какой стадии в данный момент находится проистекающее событие. Возвращает целое число от 0 до 3, обозначающее одну из фаз: 0 = Event.NONE (в данное время текущих событий нет), 1 = Event.CAPTURING_PHASE (событие распространяется по объектам предка целевого элемента, процесс стартует с Window, затем проходит через Document, затем HTMLHtmlElement и т.д., пока не достигнет родителя целевого элемента. Слушатели, зарегистрированные в режиме захвата, включаются при вызове EventTarget.addEventListener() во время этой фазы), 2 = Event.AT_TARGET (событие достигло цели события. Слушатели, зарегистрированные на эту фазу, вызываются в это время. Если Event.bubbles == false, проистекание события закончится, когда завершится эта фаза), 3 = Event.BUBBLING_PHASE (событие распространяется по предкам цели в обратную сторону, начиная с родителя и в конце-концов достигает Window. Это явление известно как всплытие и проявляется только если Event.bubbles == true. Слушатели, зарегистрированные на эту фазу, включаются во время этого процесса). ",
          "id": 25.18
        },
        {
          "name": "Event.explicitOriginalTarget",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "нестандартизованное свойство Mozilla. Если ивент был по каким-то причинам (кроме анонимного пересечения границ) перенацелен это свойство будет установлено у цели перед запуском перенаправления. Например, ивенты мыши перенаправляются на родительский элемент, когда происходят над текстовыми узлами и в этом случае currentTarget покажет этот рродительский элемент, а explicitOriginalTarget покажет текстовый узел. Свойство отличается от originalTarget тем, что никогда не содержит анонимный контент.",
          "id": 25.19
        },
        {
          "name": "Event.isTrusted",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "свойство только для чтения, возвращает булево значение true, когда событие создано пользовательским действием, и false, когда событие было создано или изменено скриптом или направлено методом EventTarget.dispatchEvent(). ",
          "id": 25.2
        },
        {
          "name": "Event.originalTarget",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "нестандартизованное свойство Mozilla. Указывает действительную цель ивента перед любым возможным перенаправлением. Может указывать на анонимный узел. ",
          "id": 25.21
        },
        {
          "name": "Event.preventDefault()",
          "classDeck": "card",
          "deck": "Event",
          "type": "method",
          "description": "в синтаксисе event.preventDefault() указывает пользовательскому агенту, что, если ивент не обрабатывается явно, его работа по-умолчанию не будет такой как обычно. По-сути, предотвращает запуск дефолтного обработчика. Ивент продолжает распространяться как обычно до тех пор, пока один из отслеживателей не вызовет stopPropagation() или stop.ImmediatePropagation(), один из которых прервет распространение. Вызов метода для неотменяемых событий (таких как направленные через EventTarget.dispatchEvent без предустановленного значения event.cancelable: true) эффекта иметь не будет. ",
          "id": 25.22
        },
        {
          "name": "Event.returnValue",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "исторический аналог Event.defaultPrevented, в новых проектах рекомендуется избегать его применения. Возвращает булево значение true, если ивент неотменяемый, false - если событие было отменено или по-умолчанию было предотвращено. Значения, противоположные Event.defaultPrevented. ",
          "id": 25.23
        },
        {
          "name": "Event.stopImmediatePropagation()",
          "classDeck": "card",
          "deck": "Event",
          "type": "method",
          "description": "в синтаксисе event.stopImmediatePropagation() предотвратит вызов других отслеживателей событий от вызова указанным событием. Если несколько отслеживателей установлены на одном и том же элементе для одного типа события, они вызываются в порядке их подключения. Если метод вызван во время вызова одного из них, все оставшиеся вызваны не будут. ",
          "id": 25.24
        },
        {
          "name": "Event.stopPropagation()",
          "classDeck": "card",
          "deck": "Event",
          "type": "method",
          "description": "в синтаксисе event.stopPropagation() предотвращает последующее распространение текущего события как в фазе всплытия, так и в фазе захвата. Тем не менее, не предотвращает появление дефолтного поведения, например, будут все еще возможны клики по ссылкам. Чтобы предотвратить и это, используйте метод preventDefault().",
          "id": 25.25
        },
        {
          "name": "Event.target",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "свойство, хранящее ссылку на объект (EventTarget), к которому направлен ивент. Отличается от Event.currentTarget, когда слушатель ивента вызван во время фаз всплытия или захвата. В примере ниже клик на списке вызовет скрытие одного пункта списка (с event.target, второй клик скроет весь список разом), а не всего списка (c event.currentTarget)\nconst ul = document.createElement('ul');\ndocument.body.appendChild(ul);\nconst li1 = document.createElement('li');\nconst li2 = document.createElement('li');\nul.appendChild(li1);\nul.appendChild(li2);\nli1.innerHTML = \"bla-bla\";\nli2.innerHTML = \"bla-bla-bla\";\nfunction hide(evt) {\n  evt.target.style.visibility = 'hidden';\n}\nul.addEventListener('click', hide, false);",
          "id": 25.26
        },
        {
          "name": "Event.timeStamp",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "свойство только для чтения, возвращающее время создания ивента (в миллисекундах). \nlet button = document.createElement('button');\ndocument.body.append(button);\nbutton.innerHTML = \"Press me for knowing the date\";\nfunction getDate(event) {\n    let timeOfPressing = event.timeStamp;\n    let correctTime = Math.round( timeOfPressing / 1000 );\n    alert(`Со времени открытия страницы прошло ${correctTime} секунд`);\n}\nbutton.addEventListener('click', getDate, false);",
          "id": 25.27
        },
        {
          "name": "Event.type",
          "classDeck": "card",
          "deck": "Event",
          "type": "property",
          "description": "свойство только для чтения, возвращающее строку, содержащую тип ивента. Значение устанавливается во время конструирования события и представляет собой имя определенного типа ивентов - click, load, error... Весь список тут https://developer.mozilla.org/en-US/docs/Web/Events",
          "id": 25.28
        }
      ],
      "id": 25
    },
    {
      "name": "EventSource",
      "classDeck": "deck",
      "deck": "EventSource",
      "type": "EventSource",
      "description": "интерфейс доступа к событиям, отсылаемым сервером. Экземпляр объекта EventSource открывает постоянное подключение к HTTP-серверу, посылающему события в формате \"text/event-stream\". Подключение остается открытым до вызова EventSource.close(). С открытием подключения входящие сообщения с сервера приходят в ваш код в виде событий. Если в сообщении есть поле события - срабатываемое событие будет значением этого поля. Если такого поля в сообщении нет - запустится событие message. В отличие от WebSockets отсылаемые сервером события однонаправленны, так что сообщения с данными доставляются только в одном направлении, от сервера к клиенту (такому как браузер). Это делает интерфейс лучшим выбором в случаях, когда не нужно отслать никакие данные на сервер. Стандарт хорошо используется в соцсетях для остылки нотификаций, новостей или пересылке данных в хранилище на стороне клиента (IndexdDB или web storage). При использовании протокола ниже HTTP/2 стандарт страдает от ограничений в максимуме открытых подключений на браузер (до 6), что может стать проблемой при открытии нескольких вкладок. Были выпущены заплатки для Chrome и Firefox, позволяющие держать открытыми 6 каналов с сайтом example.com, еще 6 с example2.com и т.д. При использовании HTTP/2 количество одновременно открытых подключений обговаривается сервером и клиентом и варьируется в пределах 100. \nСтандарт предусматривает однонаправленность (события отсылает только сервер), ограничение по типу данных (только текст) и работу по протоколу HTTP. Справится с простыми задачами и автоматически переподключится при обрыве соединения (в WS пришлось бы реализовывать вручную).\nПолучение сообщений. Создаем экземпляр объекта new EventSource(url). Сервер долен ответить со статусом 200 (ok) и заголовком Content-Type: text/event-stream. Затем сервер отправляет сообщения в виде data: строка. Сообщения отделяются друг от друга двойным переносом \\n\\n. Чтобы отправить несколько строк - data: строка и опять data: строка (без двойного переноса). Но чаще на практике отсылается json. Для каждого получаемого сообщения генерируется событие message (доступно и через свойство onmessage).\nПоддержка кросс-доменных запросов. Сервер должен ответить заголовком Access-Control-Allow-Origin. Для отсылки идентификационных данных - new EventSource(url, {withCridentials: true}).\nПереподключение при обрыве связи автоматическое. Сервер может указать время между переподключениями в сообщении retry: число (миллисекунды). Сервер может остановить попытки переподключения кодом 204. Со стороны клиента попытки переподключения можно прервать с помощью EventSource.close(). Также возникнет ошибка, если полученный код отличается от 200, 204, 301 и 307 иди указан неверный Content-Type. Закрытое соединение не восстанавливается - нужно создавать новый EventSource.\nКаждое сообщение имеет идентификатор id, позволяющий отследить его доставку или потерю при разрыве связи (указывается после data). Браузер устанавливает id последнего сообщения значением свойства EventSource.lastEventId - это реализация интерфейса MessageEvent. При переподключении на сервер будет отправлен заголовок Last-Event-ID с этим номером id.\nТакже у объекта EventSource имеется свойство readyState, в котором фиксируется статус подключения: EventSource.CONNECTING (0, подключение или переподключение), EventSource.OPEN (1, соединение открыто), EventSource.CLOSED (2, подключение закрыто).\nОбъект генерирует всего 3 типа событий: message (получено сообщение, доступное через event.data), open (соединение открыто), error (не удалось установить соединение). Но сервер может отправлять собственные события с заголовком event: событие (любое, в т.ч. настраиваемое, пользовательское). Но они, конечно, не будут доступны через схожие имена свойств - только через addEventListener(). \nУ всего стандарта нет поддержки IE.\nИнтерфейс наследует свойства своего родителя - EventTarget. ",
      "objects": [
        {
          "name": "EventSource error event",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "event",
          "description": "событие возникает, когда не удается открыть соединение с удаленным источником. Не всплывает, неотменяемо. ",
          "id": 26.1
        },
        {
          "name": "EventSource message event",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "event",
          "description": "событие, возникающее при получении данных с удаленного источника. Не всплывает, неотменяемо. \nvar evtSource = new EventSource('sse.php');\nvar eventList = document.querySelector('ul');\nevtSource.addEventListener('message', (e) => {\n  var newElement = document.createElement(\"li\");\n  newElement.textContent = \"message: \" + e.data;\n  eventList.appendChild(newElement);\n});",
          "id": 26.11
        },
        {
          "name": "EventSource open event",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "event",
          "description": "событие, возникающее при открытии соединения с удаленным источником. Не всплывает, неотменяемо. ",
          "id": 26.12
        },
        {
          "name": "EventSource()",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "constructor",
          "description": "конструктор в синтаксисе \neventSourse = new EventSource(url, configuration) \nвозвращает новосозданный объект EventSource, представляющий удаленный ресурс. url - адрес ресурса в виде строки, необязательный аргумент configuration - объект с единственным пока полем withCridentials, указывающим, что CORS должна включать идентификационные данные (по умолчанию false). ",
          "id": 26.13
        },
        {
          "name": "EventSource.close()",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "method",
          "description": "метод в синтаксисе \neventSource.close() \nзакрывает подключение eventSource и устанавливает значение свойства eventSource.readyState в 2 (закрыто). Если подключение уже закрыто, метод не сделает ничего. Возвращает void.",
          "id": 26.14
        },
        {
          "name": "EventSource.onerror",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "property",
          "description": "свойство-обработчик для случаев ошибок, когда событие error доставляется к объекту EventSource. Синтаксис  \neventSource.onerror = function() {...}",
          "id": 26.15
        },
        {
          "name": "EventSource.onmessage",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "property",
          "description": "свойство для хранения обработчика в случае получения события message, пришедшего с удаленного источника. \neventSource.onmessage = function() {...}",
          "id": 26.16
        },
        {
          "name": "EventSource.onopen",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "property",
          "description": "свойство для хранения обработчика события open, получаемого, когда подключение только-только открыто. Синтаксис - \neventSource.onopen = function() {...}",
          "id": 26.17
        },
        {
          "name": "EventSource.readyState",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "property",
          "description": "свойство только для чтения, возвращаюшее число, представлающее состояние подключения: 0 - осуществляется подключение, 1 - подключено, 2 - закрыто.",
          "id": 26.18
        },
        {
          "name": "EventSource.url",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "property",
          "description": "свойство только для чтения, представляющее URL источника в виде строки.",
          "id": 26.19
        },
        {
          "name": "EventSource.withCredentials",
          "classDeck": "card",
          "deck": "EventSource",
          "type": "property",
          "description": "свойство только для чтения, демонстрирующее, был ли экземпляр EventSource создан с набором идентификационных параметров CORS. По умолчанию false.",
          "id": 26.2
        }
      ],
      "id": 26
    },
    {
      "name": "EventTarget",
      "classDeck": "deck",
      "deck": "EventTarget",
      "type": "EventTarget",
      "description": "Web-API-интерфейс DOM, реализуемый объектами, который может получать события и может иметь отслеживатели для них. Самые распространенные целевые элементы событий - Element, Document, Window, но другие объекты также могут быть ими - XMLHttpRequest, AudioNode, AudioContext и т.д. Многие целевые элементы поддерживают также установку обработчиков событий через onevent-свойства и атрибуты.",
      "objects": [
        {
          "name": "EventTarget()",
          "classDeck": "card",
          "deck": "EventTarget",
          "type": "constructor",
          "description": "EventTarget() - конструктор, создающий новый экземпляр объекта EventTarget. Синтаксис - \nvar myEventTarget = new EventTarget();\nВозвращает новый экземпляр объекта. \nclass MyEventTarget extends EventTarget {\n  constructor(mySecret) {\n    super();\n    this._secret = mySecret;\n  }\n  get secret() { return this._secret; }\n};\nlet myEventTarget = new MyEventTarget(5);",
          "id": 27.1
        },
        {
          "name": "EventTarget.addEventListener()",
          "classDeck": "card",
          "deck": "EventTarget",
          "type": "method",
          "description": "в синтаксисе \ntarget.addEventListener(type, listener, options) \nили \ntarget.addEventListener(type, listener, useCapture)\nустанавливает функцию listener, запускающуюся при достижении событием type элемента target. В качестве listener может быть не функция, а объект, внедряющий EventListener в список слушателей событий установленного типа на целевом элементе. type - строка (в кавычках!) с именем события (список возможных - тут https://developer.mozilla.org/en-US/docs/Web/Events)\nOptions - объект со специфическими параметрами. Возможные значения: capture (булево значение, показывающее, будет ли событие указанного типа передано зарегистрированному слушателю до того, как будет передано любому другому целевому элементу EventTarget ниже по DOM-дереву), once (булево значение, показывающее, что слушатель будет вызван больше одного раза после добавления, если true - отслеживатель будет автоматически удален после вызова), passive (булево значение, если true - означает, что обозначенная в отслеживателе функция никогда не вызовет preventDefault(), если пассивный слушатель вызывает preventDefault(), пользовательский агент ничего не сделает кроме выброса предупреждения в консоли), useCapture (булево значение, показывающее, будут ли события этого типа направлены к зарегистрированному слушателю до того, как будут направлены к любому другому EventTarget ниже по DOM-дереву; события, всплывающие вверх по дереву не запустят слушателя, ответственного за захват. Всплытие и захват - два пути распространения ивентов, которые происходят в элементе, вложенном в другой элемент, где оба элемента имеют обработчик для этого ивента. Режим распространения ивента определяет порядок, в котором элементы получают ивент. По-умолчанию, false. Для кросс-браузерной совместимости следует всегда указывать этот параметр). \nПример проверки слушателя на passive.\nlet passiveSupported = false;\ntry {\n  const options = {\n    get passive() { // This function will be called when the browser\n                    //   attempts to access the passive property.\n      passiveSupported = true;\n      return false;\n    }\n  };\n  window.addEventListener(\"test\", null, options);\n  window.removeEventListener(\"test\", null, options);\n} catch(err) {\n  passiveSupported = false;\n}\nsomeElement.addEventListener(\"mouseup\", handleMouseUp, passiveSupported\n                               ? { passive: true } : false);\nПример установки слушателя, меняющего текст при клике.\n<table id=\"outside\">\n    <tr><td id=\"t1\">один</td></tr>\n    <tr><td id=\"t2\">два</td></tr>\n</table>\nfunction modifyText() {\n  const t2 = document.getElementById(\"t2\");\n  if (t2.firstChild.nodeValue == \"three\") {\n    t2.firstChild.nodeValue = \"two\";\n  } else {\n    t2.firstChild.nodeValue = \"three\";\n  }\n}\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\"click\", modifyText, false);",
          "id": 27.11
        },
        {
          "name": "EventTarget.dispatchEvent()",
          "classDeck": "card",
          "deck": "EventTarget",
          "type": "method",
          "description": "в синтаксисе \ncancelled = !target.dispatchEvent(event) \nнаправляет событие event к установленному EventTarget, одновременно (синхронно) вызывая связанные с этим событием слушатели в установленном порядке. Обычные правила обработки события (включая захват и опциональную фазу всплытия) также применяются к событиям, вручную перенаправленным при помощи dispatchEvent(). Возвращает булево значение true в случае успешного перенаправления и false, если ивент отменяемый (cancelable) и как минимум один из обработчиков события, получивший ивент, вызвал Event.preventDefault(). Если ивент не был изначально (до применения метода) инициализирован, равен null или пустой строке, выбросит ошибку UNSPECIFIED_EVENT_TYPE_ERR. Исключения, выбрасываемые обработчиками событий, являются неотлавливаемыми (uncaught). Они запускаются в стеке, вложенными, поэтому блокируют вызов пока не выполнятся, но исключения не блокируют вызвавший код. В отличии от \"натуральных\" ивентов, запускаемых DOM-ом и вызывающих обработчики асинхронно, через цикл событий, dispatchEvent() вызывает обработчики синхронно. Все применимые обработчики будут остановлены и возвращены до продолжения выполнения кода. ",
          "id": 27.12
        },
        {
          "name": "EventTarget.removeEventListener()",
          "classDeck": "card",
          "deck": "EventTarget",
          "type": "method",
          "description": "в синтаксисе \ntarget.removeEventListener(type, listener, options)\nили \ntarget.removeEventListener(type, listener, useCapture) \nудаляет из объекта EventTarget отслеживатель, предварительно зарегистрированный методом .addEventListener(). Слушатель, предназначенный к удалению, будет идентифицирован по комбинации строки type, самой функции-обработчику и набору дополнительных опций. Среди дополнительных опций options - capture (булево значение, говорящее о том, что ивенты данного типа будут направлены к зарегистрированному слушателю до того, как будут направлены к любому EventTarget ниже по DOM-дереву), useCapture (определяет, будет ли EventListener удален как зарегистрированный перехватчик или нет. Если параметр пропущен, значением по-умолчанию будет false. Если слушатель зарегистрирован дважды, один с захватом и один без него, удаляйте каждый из них отдельно. Удаление слушателя-с захватом не влияет на вариант этого же слушателя без захвата и наоборот). При удалении слушателя особо следует отслеживать последний параметр (capture/useCapture). Чтобы удалить обработчик, надо его сохранить (как отдельную функцию), не существует метода получения обработчиков из .addEventLIstener(). Такую функцию .removeEventListener() не удалит.\nelem.addEventListener('click', () => alert('Hello'));",
          "id": 27.13
        }
      ],
      "id": 27
    },
    {
      "name": "HTMLCanvasElement",
      "classDeck": "deck",
      "deck": "HTMLCanvasElement",
      "type": "HTMLCanvasElement",
      "description": "Интерфейс, предоставляющий свойства и методы для обработки и представления содержимого элемента <canvas>. Наследует также свойства и методы интерфейса HTMLElement.\nНаследует свойства от родительского интерфейса HTMLElement. Собственных свойств всего два. Помимо собственных, наследует методы от родителя - HTMLElement.",
      "objects": [
        {
          "name": "HTMLCanvasElement webglcontextcreationerror event",
          "classDeck": "card",
          "deck": "HTMLCanvasElement",
          "type": "event",
          "description": "событие API QebGL срабатывает, когда браузер не может создать контекст WebGLRenderingContext. Больше информации о событии содержится в строчном значении свойства WebGLContextEvent.statusMessage. Всплываемое, отменяемое. ",
          "id": 28.1
        },
        {
          "name": "HTMLCanvasElement webglcontextlost event",
          "classDeck": "card",
          "deck": "HTMLCanvasElement",
          "type": "event",
          "description": "событие API WebGL, возникающее, когда браузер определяет, что связанные объектом WebGLRenderingContext данные потеряны. Невсплываемое, отменяемое. Можно симулировать появление события потери контекста при помощи расширения WEBGL_lose_context. ",
          "id": 28.11
        },
        {
          "name": "HTMLCanvasElement webglcontextrestored event",
          "classDeck": "card",
          "deck": "HTMLCanvasElement",
          "type": "event",
          "description": "событие API WebGL, возникающее, когда браузер восстанавливает данные для объекта WebGLRenderingContext. При восстановлении данных такие ресурсы как текстуры и слои, созданные до потери контекста, больше не валидны. Вам понадобится реинициализировать состояние вашего WebGL-приложения перевоссоздать все данные. Невсплываемое, отменяемое. Можно симулировать появление события восстановления контекста при помощи расширения \nWEBGL_lose_context. ",
          "id": 28.12
        },
        {
          "name": "HTMLCanvasElement.captureStream()",
          "classDeck": "card",
          "deck": "HTMLCanvasElement",
          "type": "method",
          "description": "метод в синтаксисе\nMediaStream = canvas.captureStream(frameRate) возвращает объект MediaStream, содержащий объект интерфейса CanvasCaptureMediaStreamTrack - поток видеоконтента, захватываемого с холста. Необязательный параметр frameRate - значение из числа двойной точности с плавающей запятой, определяющее частоту захвата (rate of capture). Если не определено - снимок будет делаться каждый раз при изменениях на холсте. При установке в 0 частота захвата не будет устанавливаться автоматически, а захват изображения будет производиться при возврате метода CanvasCaptureMediaStreamTrack.requestFrame(). При отрицательном значении выбросит ошибку NotSupportedError. Возвращает ссылку на объект интерфейса MediaStream, содержащий одиночный экземпляр \nCanvasCaptureMediaStreamTrack. Не поддерживается в IE.",
          "id": 28.13
        },
        {
          "name": "HTMLCanvasElement.getContext()",
          "classDeck": "card",
          "deck": "HTMLCanvasElement",
          "type": "method",
          "description": "метод в синтаксисе \nvar ctx = canvas.getContext(contextType) \nили \nvar ctx = canvas.getContext(contextType, contextAttributes) \nвозвращает изобразительный контекст или null, если идентификатор контекста неподдерживаемый или canvas уже был переключен в другой контекстный режим. Более поздние вызовы этого метода на том же элементе <canvas> с тем же аргументом contextType будут возвращать тот же экземпляр контекста, что вернулся с первым вызовом. Получить другой объект рисующего контекста на том же элементе невозможно. Возможные значения contextType (строка): \"2d\" - ведет к созданию объекта \nCanvasRenderingContext2D, представляющему двумерный изобразительный контекст; \"webgl\" или \"experimental-webgl\" (для новых, еще не до конца отработанных и нестабильных реализаций WebGL) создаст объект WebGLRenderingContext, представляющий собой трехмерный рендерящий контекст, он доступен только в браузерах, поддерживающих WebGL 1 (OpenGL ES 2.0); \"webgl2\" создаст объект \nWebGL2RenderingContext, представляющий трехмерный изобразительный контекст, возможен только в браузерах с поддержкой WebGL 2 (OpenGL ES 3.0); \n\"bitmaprenderer\" создаст ImageBitmapRenderingContext, предоставляющий лишь функциональность замены содержания canvas данным объектом ImageBitmap. Аргумент contextAttributes - объект с полями, характерными для каждого типа контекста. Для 2d: alpha (true/false) - должен ли canvas иметь альфа-канал, если установлен false - браузер понимает, что задний фон у canvas будет непрозрачным, что ускорит отрисовку прозрачного контента и изображений; desynchronized (true/false) подскажет браузеру уменьшить время задержки десинхронизацией цикла отрисовки canvas и событийного цикла. Для WebGL: \nalpha (альфа-канал); desynchronized (рассинхронизация цикла отрисовки с событийным циклом); antialias (true/false) - применять ли сглаживание (anti-aliasing); depth (true/false) устанавливает минимальную глубину буфера отрисовки в 16 бит; \nfailIfMajorPerformanceCaveat (true/false) укажет, должен ли создаваться контент, если возможности системы слишком слабы или не предоставлена поддержка графическим процессором; powerPreference подскажет браузеру подходящую конфигурацию видеокарты для данного WebGL-контента, возможные значения - \"default\" (браузер самостоятельно принимает решение о подходящей конфигурации, значение по умолчанию), \"high-performance\" (приоритет производительности над потреблением энергии), \"low-power\" (приоритет экономии потребления энергии над производительностью); premultipliedAlpha (true/false) демонстрирует, что создатель страницы будет применять слой, содержащий цвета заранее вычисленного альфа-канала; preserveDrawingBuffer (true/false) - указанный слой не будет удален (true) и сохранит свои значения до принудительной очистки или удаления самим автором; stencil (true/false) определяет использование слоя (буфера) шаблонов (трафаретов) глубиной минимум в 8 бит; xrCompatible (true/false) подскажет браузеру необходимость использования графического адаптера, совместимого с устройствами виртуальной (дополненной) реальности (XR), установка этого синхронизирующег флага не поощряется, если только перед самой XR-сессией не вызывается асинхронный метод \nWebGLRenderingContext.makeXRCompatible(). Многие параметры не поддерживаются рядом браузеров. Метод возвращает контекст отрисовки в виде CanvasRenderingContext2D, WebGLRenderingContext, WebGL2RenderingContext или ImageBitmapRenderingContext. При несоответствии contextType возможному или уже существующему контексту вернет null. ",
          "id": 28.14
        },
        {
          "name": "HTMLCanvasElement.height",
          "classDeck": "card",
          "deck": "HTMLCanvasElement",
          "type": "property",
          "description": "высота холста, положительное целое число, отображающее значение HTML-атрибута height элемента <canvas> в CSS-пикселях. Если значение не указано или применено неправильное (например, отрицательное число), значением по умолчанию станет 150. Вместе со свойством \nHTMLCanvasElement.width определяет размеры холста.",
          "id": 28.15
        },
        {
          "name": "HTMLCanvasElement.toBlob()",
          "classDeck": "card",
          "deck": "HTMLCanvasElement",
          "type": "method",
          "description": "метод в синтаксисе \ncanvas.toBlob(callback, mimeType, qualityArgument) \nсоздает объект Blob, представляющий собой изображение, содержащееся в canvas, который может кэшироваться на диск или сохраняться в памяти на усмотрение браузера. Изображение будет в разрешении 96dpi. Обязательный аргумент callback - колбэк-функция с единственным аргументом в виде объекта Blob. Необязательный mimeType - строка с форматом файла (по умолчанию image/png), этот же формат будет использоваться при попытке использовать неподдерживаемый формат. Необязательный аргумент qualityArgument - число от 0 до 1, указывающая желаемое качество изображения для форматов jpeg и webp (по умолчанию используется 0.92 и 0.80 соответственно). Используется при задействовании сжатия с потерей качества.\nvar canvas = document.getElementById('canvas');\ncanvas.toBlob(function(blob) {\n  var newImg = document.createElement('img'),\n      url = URL.createObjectURL(blob);\n  newImg.onload = function() {\n    // no longer need to read the blob so it's revoked\n    URL.revokeObjectURL(url);\n  };\n  newImg.src = url;\n  document.body.appendChild(newImg);\n});",
          "id": 28.16
        },
        {
          "name": "HTMLCanvasElement.toDataURL()",
          "classDeck": "card",
          "deck": "HTMLCanvasElement",
          "type": "method",
          "description": "метод в синтаксисе \ncanvas.toDataURL(type, encoderOptions) \nвозвращает ссылку на данные, содержащие представленное изображение в установленном аргументом type формате (по умолчанию PNG). Возвращается изображение в разрешении 96dpi. Если высота или ширина <canvas> равна 0 или больше максимальных значений, вернется пустая строка \"data:,\". Если запрашиваемый формат не image/png, а возвратилось изображение с image/png в начале строки (\"data:image/png\"), то запрошенный файл имеет неподдерживаемый формат. Chrome поддерживает также формат image/webp. Аргумент type необязательный, указывает желаемый формат изображения (по умолчанию png). Необязательный параметр EncoderOptions - число от 0 до 1, означающее желаемое качество изображения при использовании сжатия с потерей качества (для jpeg и webp). Если у аргумента указано какое-либо иное значение, будет применено дефолтное - 0.92, остальные значения игнорируются. Метод возвращает строку с адресом ресурса. При несовпадении данных origin в CORS будет выброшено исключение SecurityError.",
          "id": 28.17
        },
        {
          "name": "HTMLCanvasElement.transferControlToOffscreen()",
          "classDeck": "card",
          "deck": "HTMLCanvasElement",
          "type": "method",
          "description": "метод в синтаксисе \nOffscreenCanvas = canvas.transferControlToOffscreen() \nпередает контроль объекту OffscreenCanvas в этом же рабочем потоке или в Worker. Возвращает объект OffscreenCanvas. Возврат в canvas осуществляется методом IDBTransaction.commit(). Слабая поддержка браузеров.",
          "id": 28.18
        },
        {
          "name": "HTMLCanvasElement.width",
          "classDeck": "card",
          "deck": "HTMLCanvasElement",
          "type": "property",
          "description": "ширина холста, положительное целое число, отображающее значение HTML-атрибута width элемента <canvas> в CSS-пикселях. Если значение не указано или применено неправильное (например, отрицательное число), значением по умолчанию станет 300. Вместе со свойством \nHTMLCanvasElement.height определяет размеры холста.",
          "id": 28.19
        }
      ],
      "id": 28
    },
    {
      "name": "HTMLCollection",
      "classDeck": "deck",
      "deck": "HTMLCollection",
      "type": "HTMLCollection",
      "description": "интерфейс, представляющий типизированную коллекцию (массивоподобный объект, близкий к arguments) элементов (в документированном порядке) и предоставляющий методы и свойства для отбора элементов из списка. Такое название имеет по историческим причинам, когда только HTML-элементы могли быть элементами такой коллекции. В DOM - это живая коллекция, автоматически обновляющаяся при изменении документа-основы.  \nКоллекция демонстрирует свои элементы как свойства из имени и индекса. ID в HTML могут содержать : и . в качестве валидных символов, что делает необходимым использование квадратных скобок для доступа к свойству. На данный момент HTMLCollection не распознает чисто цифровые ID, что может привести к конфликтам при попытке доступа как к элементам массива, что разрешено в HTML5. ",
      "objects": [
        {
          "name": "HTMLCollection.item()",
          "classDeck": "card",
          "deck": "HTMLCollection",
          "type": " method",
          "description": "в синтаксисе \nvar elem = HTMLCollection.item(index) \nвозвращает узел, расположенный в определенном месте в коллекции. Т.к. колекция живая, индекс элемента нельзя считать постоянным значением. Элементы появляются в коллекции в том же порядке, что расположены в исходном документе. Возвращаемое значение - узел Node или null, если индекс меньше нуля или больше или равен длине коллекции (свойству length). В JS коллекцию легче обрабатывать и индексировать как массив.\nvar img0 = c.item(0);// с методом  \nvar img1 = c[1];// как с массивом",
          "id": 29.1
        },
        {
          "name": "HTMLCollection.length",
          "classDeck": "card",
          "deck": "HTMLCollection",
          "type": "property",
          "description": "свойство только для чтения, возвращает количество элементов в коллекции",
          "id": 29.11
        },
        {
          "name": "HTMLCollection.namedItem()",
          "classDeck": "card",
          "deck": "HTMLCollection",
          "type": "method",
          "description": "возвращает определенный узел Node, чей ID или в крайнем случае имя соответствует указанному в строке имени. Сравнение по имени - уже как крайняя мера, только для HTML и только если данный элемент поддерживает атрибут name. Вернет null если узел с таким именем не найден. Альтернатива - доступ через collection[name] (в таком случае, если узел не будет найден, вернется undefined).",
          "id": 29.12
        }
      ],
      "id": 29
    },
    {
      "name": "ImageData",
      "classDeck": "deck",
      "deck": "ImageData",
      "type": "ImageData",
      "description": "интерфейс, представляющий данные о слое пикселей элемента <canvas>. Объект ImageData создается конструктором или одним из методов интерфейса CanvasRenderingContext2D - .createImageData() или .getImageData(). Также используется для отрисовки на холсте методом CanvasRenderingContext.putImageData(). Доступен в WebWorkers. \nПопиксельно перебрать данные можно циклом:\nfor (let i = 0; i < arr.length; i += 4) {\n  arr[i + 0] = 0;    // R value\n  arr[i + 1] = 190;  // G value\n  arr[i + 2] = 0;    // B value\n  arr[i + 3] = 255;  // A value\n}\nРаскрашивание объекта:\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\nconst imageData = ctx.createImageData(100, 100);\n// Iterate through every pixel\nfor (let i = 0; i < imageData.data.length; i += 4) {\n  // Percentage in the x direction, times 255\n  let x = (i % 400) / 400 * 255;\n  // Percentage in the y direction, times 255\n  let y = Math.ceil(i / 400) / 100 * 255;\n  // Modify pixel data\n  imageData.data[i + 0] = x;        // R value\n  imageData.data[i + 1] = y;        // G value\n  imageData.data[i + 2] = 255 - x;  // B value\n  imageData.data[i + 3] = 255;      // A value\n}\n// Draw image data to the canvas\nctx.putImageData(imageData, 20, 20);",
      "objects": [
        {
          "name": "ImageData()",
          "classDeck": "card",
          "deck": "ImageData",
          "type": "constructor",
          "description": "конструктор, возвращающий новый экземпляр объекта ImageData, созданный на основе типизированного массива и имеющий установленные ширину и высоту. Конструктор является предпочтительным методом создания объекта ImageData в Worker. Синтаксис - \nlet imageData = new ImageData(array, width, height) \nили \nlet imageData = new ImageData(width, height). Необязательный параметр array - типизированный массив Uint8ClampedArray, содержащий попиксельные данные изображения. Если параметр не указывается, будет создано изображение с указанными размерами, а все пиксели в нем будут прозрачными черными. width и height - большие беззнаковые числа, представляющие ширину и высоту изображения. Высота - необязательный параметр, если дан массив - она будет высчитана исходя из длины массива и ширины изображения. Будет выброшено исключение IndexSizeError, если длина массива не кратна произведению 4 * width или 4 * width * height. Последний индекс массива = (4 * width * height) - 1. Доступ к голубому компоненту (rgBa) у пикселя в 200-й колонке 50-го ряда:\nblueComponent = imageData.data[((50 * (imageData.width * 4)) + (200 * 4)) + 2];\nПолучение цифровых индексов конкретного пикселя с указанными координатами:\nconst xCoord = 50;\nconst yCoord = 100;\nconst canvasWidth = 1024;\nconst getColorIndicesForCoord = (x, y, width) => {\n  const red = y * (width * 4) + x * 4;\n  return [red, red + 1, red + 2, red + 3];\n};\nconst colorIndices = getColorIndicesForCoord(xCoord, yCoord, canvasWidth);\nconst [redIndex, greenIndex, blueIndex, alphaIndex] = colorIndices;\nНе поддерживается в IE.",
          "id": 30.1
        },
        {
          "name": "ImageData.data",
          "classDeck": "card",
          "deck": "ImageData",
          "type": "property",
          "description": "свойство только для чтения, возвращаюшее типизированный массив Uint8ClampedArray, содержащий данные о пикселях объекта. Данные сохраняются в одномерном массивев порядке следования RGBA, с целыми значениями от 0 до 255 включительно. ",
          "id": 30.11
        },
        {
          "name": "ImageData.height",
          "classDeck": "card",
          "deck": "ImageData",
          "type": "property",
          "description": "свойство только для чтения, возвращающее количество рядов пикселей в объекте ImageData. ",
          "id": 30.12
        },
        {
          "name": "ImageData.width",
          "classDeck": "card",
          "deck": "ImageData",
          "type": "property",
          "description": "свойство только для чтения, возвращающее количество пикселей в каждом ряду объекта ImageData",
          "id": 30.13
        }
      ],
      "id": 30
    },
    {
      "name": "JSON",
      "classDeck": "deck",
      "deck": "JSON",
      "type": "JSON",
      "description": "объект JSON содержит методы для парсинга объектов обмена данными JSON https://www.json.org/json-en.html и и конвертации данных в эти объекты. Он не может быть вызван или сконструирован и помимо его двух методов-свойств не несет более никакой функциональности. \nJSON - синтаксис сериализации объектов, массивов, чисел, строк, булевых значений и null. Построен на синтаксисе JavaScript, но имеет ряд отличий. У объектов и массивов имена свойств должны быть в двойных кавычках, висячая запятая запрещена. Числа с нулем в начале запрещены, десятичные значения должны иметь 0 в начале (нельзя писать .67), NaN и Infinity не поддерживаются. Любой JSON-текст - это выражение, валидное в JavaScript, но только в движках, реализовавших предложение рассматривать все JSON-тексты валидным ECMA-262. В движках, не реализовавших это предложение, символы U+2028 (LINE SEPARATOR) и U-2029 (PARAGRAPH SEPARATOR) являются допустимыми в строковых литералах и ключах свойств JSON, но в этом случае такие строки в JavaScript приведут к SyntaxError. Другие отличия - разрешены только двойные кавычки, не используются undefined и комментарии. Существует формат JSON5, использующий компилятор Babel.",
      "objects": [
        {
          "name": "JSON.parse()",
          "classDeck": "card",
          "deck": "JSON",
          "type": "static method",
          "description": "статический метод в синтаксисе \nJSON.parse(text, reviver) \nпарсит (считывает) JSON-строку, создавая JavaScript-значение или объект, описываемый строкой. Опциональный параметр reviver - функция, выполняющая преобразования в получаемом объекте перед тем, как он будет возвращен методом. Возвращается объект, массив, строка, число, булево значение или null. Если строка не является валидной JSON-строкой, выбросит SyntaxError. \nJSON.parse('{}');// {}\nJSON.parse('true'); // true\nJSON.parse('\"foo\"'); // \"foo\"\nJSON.parse('[1, 5, \"false\"]'); // [1, 5, \"false\"]\nJSON.parse('null');// null\nЕсли используется \"оживляющая\" функция reviver, считываемое значение изменяется перед тем, как будет возвращено. Точнее, высчитываемое значение и все его свойства (начиная с самых глубоко вложенных свойств и заканчивая самим исходным значением) по-отдельности пропускаются через reviver. Затем оно вызывается вместе с объектом, содержащим свойство, считающееся за this, и свойство с именем-строкой и свойство-значение в качестве аргументов. Если reviver возвращает undefined (или, например, не возвращает значение, или функция \"падает\" до возврата значения), то свойство удаляется из объекта. В противном случае будет возвращено переопределенное свойство. Если reviver изменяет только определенные значения, убедитесь, что все остальные она возвращает нетронутыми, иначе они будут удалены. \nJSON.parse('{\"p\": 5}', (key, value) =>\n  typeof value === 'number'\n    ? value * 2 // return value * 2 for numbers\n    : value     // return everything else unchanged\n);// { p: 10 }\nМетод не поддерживает висячие запятые\nJSON.parse('[1, 2, 3, 4, ]');// Error\nи одинарные кавычки\nJSON.parse(\"{'foo': 1}\");// Error",
          "id": 31.1
        },
        {
          "name": "JSON.stringify()",
          "classDeck": "card",
          "deck": "JSON",
          "type": "static method",
          "description": "статический метод в синтаксисе \nJSON.stringify(value, replacer, space) \nконвертирует JS-объекты или значения в JSON-строки, выборочно заменяя значения, если предоставлена функция replacer или выборочно конвертируя лишь определенные свойства, если указан массив replacer. Если значением является null или оно не предоставлено, все свойства объекта переносятся в итоговую строку JSON. Параметр space - объект String или Number, использующийся в качестве разделителя в строке JSON для улучшения ее читаемости. Если это число, оно указывает количество символов пробела (ограничено значением 10, т.е. если указано больше 10 - все равно будет 10). Если значение меньше 1 - это значит, что пробелы не надо использовать. Если это строка (первые 10 символов строки, если она длиннее), то она используется в качестве разделителя. Если параметр не указан или равняется null, пробелы не надо использовать. Метод возвращает созданную JSON-строку. Выбросит исключение TypeError при найденной циклической ссылке или при попытке конвертации значения BigInt. Для переноса циклических ссылок используются специальные библиотеки, например cycle.js https://github.com/douglascrockford/JSON-js/blob/master/cycle.js\nОсобенности конвертации: Если значение имеет метод toJSON(), то он определяет какие данные будут сериализованы. Объекты Boolean, Number и String конвертируются в соответствующие им примитивные значения в соответствии со стандартным преобразованием. Undefined, Function и Symbol не являются валидными JSON-значениями. Если они встречаются в процессе конвертации, то будут пропущены (если найдены в объекте) или будут заменены на null (если они найдены в массиве). Метод может вернуть undefined при передаче ему \"чистых\" значений вроде JSON.stringify(function() {}) или JSON.stringify(undefined). Все символьные свойства будут полностью проигнорированы даже если используется replacer. Экземпляры объекта Date реализуют метод toJSON(), возвращая строку (идентичную при вовзврате методом Date.prototype.toISOString()), следовательно, рассматриваются как строки. Infinity и NaN, так же, как и null, считаются значением null. У всех других объектов (Map, Set, WeakMap, WeakSet) будут сериализваны только их перечисляемые свойства. \nJSON.stringify({});// '{}'\nJSON.stringify(true);// 'true'\nJSON.stringify('foo');// '\"foo\"'\nJSON.stringify([1, 'false', false]);// '[1,\"false\",false]'\nJSON.stringify([NaN, null, Infinity]); // '[null,null,null]'\nJSON.stringify({ x: 5 }); // '{\"x\":5}'\nJSON.stringify(new Date(2006, 0, 2, 15, 4, 5));// '\"2006-01-02T15:04:05.000Z\"'\nJSON.stringify({ x: 5, y: 6 });// '{\"x\":5,\"y\":6}'\nJSON.stringify([new Number(3), new String('false'), new Boolean(false)]);// '[3,\"false\",false]'\n// String-keyed array elements are not enumerable and make no sense in JSON\nlet a = ['foo', 'bar'];\na['baz'] = 'quux'; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ]\nJSON.stringify(a);// '[\"foo\",\"bar\"]'\nJSON.stringify({ x: [10, undefined, function(){}, Symbol('')] });// '{\"x\":[10,null,null,null]}'\n// Standard data structures\nJSON.stringify([new Set([1]), new Map([[1, 2]]), new WeakSet([{a: 1}]), new WeakMap([[{a: 1}, 2]])]);// '[{},{},{},{}]'\n// TypedArray\nJSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]);// '[{\"0\":1},{\"0\":1},{\"0\":1}]'\nJSON.stringify([new Uint8Array([1]), new Uint8ClampedArray([1]), new Uint16Array([1]), new Uint32Array([1])]);\n// '[{\"0\":1},{\"0\":1},{\"0\":1},{\"0\":1}]'\nJSON.stringify([new Float32Array([1]), new Float64Array([1])]);// '[{\"0\":1},{\"0\":1}]'\n// toJSON()\nJSON.stringify({ x: 5, y: 6, toJSON(){ return this.x + this.y; } });// '11'\n// Symbols:\nJSON.stringify({ x: undefined, y: Object, z: Symbol('') });// '{}'\nJSON.stringify({ [Symbol('foo')]: 'foo' });// '{}'\nJSON.stringify({ [Symbol.for('foo')]: 'foo' }, [Symbol.for('foo')]);// '{}'\nJSON.stringify({ [Symbol.for('foo')]: 'foo' }, function(k, v) {\n  if (typeof k === 'symbol') {\n    return 'a symbol';\n  }\n});// undefined\n// Non-enumerable properties:\nJSON.stringify( Object.create(null, { x: { value: 'x', enumerable: false }, y: { value: 'y', enumerable: true } }) );\n// '{\"y\":\"y\"}'\nПараметр replacer может быть как функцией, так и массивом. Как функция, он принимает два параметра, key и value. Объект, в котором найден ключ key, считается за this. Сначала функция вызывается с пустой строкой-ключом, представляющей трансформирующийся в строку объект. Затем она вызывается для каждого свойства объекта или массива. Должна вернуть значение, добавляющееся к JSON-строке, по следующим правилам:\n- если возвращается Number, String, Boolean или null, сконвертированная версия этого значения используется как значение свойства\n- если возвращается Function, Symbol или undefined, свойство не попадает в итоговую строку\n- если возвращается любой другой объект, объект конвертируется рекурсивно, replacer вызывается для каждого свойства этого объекта.\nВы не можете использовать функцию replacer для удаления значений из массива. Если вы возвращаете undefined или функцию, то вместо них используется null. Если вам нужен replacer для отделения настоящего объекта от свойства с ключом из пустой строки (потому что оба будут при конвертации превращаться в ключ с пустой строкой и возможно объектом в виде значения), вам нужно отслеживать счетчик итераций (если больше одной итерации - это ключ из настоящей пустой строки). \nfunction replacer(key, value) {\n  // Filtering out properties\n  if (typeof value === 'string') {\n    return undefined;\n  }\n  return value;\n}\nКак массив, значения массива replacer указывают имена свойств объекта, которые необходимо перенести в итоговую JSON-строку.\nJSON.stringify(foo, ['week', 'month']);// '{\"week\":45,\"month\":7}', only keep \"week\" and \"month\" properties\nИспользование разделителей:\nJSON.stringify({ a: 2 }, null, ' ');\n// '{\n//  \"a\": 2\n// }'\nили символа TAB\nJSON.stringify({ uno: 1, dos: 2 }, null, '\\t');\n// returns the string:\n// '{\n//     \"uno\": 1,\n//     \"dos\": 2\n// }'\nЕсли объект имеет метод toJSON(), изменяющий поведение \"строкофикации\", то вместо сериализации объекта будет сериализовано значение, возвращаемое этим методом. JSON.stringify() вызывает этот метод с одним параметром: если объект является значением свойства - с именем этого свойства, если объект находится в массиве - с соответствующим его индексом в виде строки, если вызван прямо на этом объекте - с пустой строкой. \nvar obj = {\n    data: 'data',\n    toJSON (key) {\n        if (key)\n            return `Now I am a nested object under key '${key}'`;\n        else\n            return this;\n    }\n};\nJSON.stringify(obj);// '{\"data\":\"data\"}'\nJSON.stringify({ obj }); // Shorthand property names (ES2015).\n// '{\"obj\":\"Now I am a nested object under key 'obj'\"}'\nJSON.stringify([ obj ]);// '[\"Now I am a nested object under key '0'\"]'",
          "id": 31.11
        }
      ],
      "id": 31
    },
    {
      "name": "Map",
      "classDeck": "deck",
      "deck": "Map",
      "type": "Map",
      "description": "объект Map хранит пары \"ключ/значение\" и запоминает порядок вставки ключей. В качестве ключей или значений могут быть любые данные - объекты или примитивы. Перебор элементов осуществляется в порядке их добавления циклом for...of, возвращающим массив [key, value] при каждой итерации.\nРавенство ключей проверяется по алгоритму same-value-zero. NaN считается равным NaN (даже несмотря на то, что NaN !== NaN), все другие значения проверяются на равенство ===. -0 равен +0. Отсюда возможность использования NaN в качестве ключей:\nlet myMap = new Map();\nmyMap.set(NaN, 'not a number');\nmyMap.get(NaN);// \"not a number\"\nlet otherNaN = Number('foo');\nmyMap.get(otherNaN);// \"not a number\"\nMap близок Object, но со значительными отличиями: Конфликтующие ключи - объект имеет прототип, содержащий дефолтные ключи, которые могут вступиить в противоречие с вашими, если вы не будете достаточно внимательны (хотя в ES5 появился способ этого избежать - Object.create(null)), Map не имеет таких ключей, только те, что однозначно в него записаны. Типы ключей - у Object это или строки, или символы, у Map - любое значение (включая функции, объекты и примитивы). Порядок ключей - несмотря на то, что ключи у стандартного объекта сейчас систематизированы, исторически так не было и порядок случайный. Как результат - лучше не полагаться на порядок свойств. Имейте также ввиду, что нет единого механизма перебора свойств объекта; каждый из различныъ механизмов перебирает отличный от других набор свойств (циклу for...in доступны только перечисляемые свойства со строчными ключами, Object.keys() перебирает только собственные перечисляемые свойства с ключами-строками, Object.getOwnPropertyNames() - собственные свойства со строчными ключами, даже неперечисляемые, Object.getOwnPropertySymbol() - собственные, в т.ч. неперечисляемые свойства с ключами-символами и т.д. У Map ключи систематизированы в простой незамысловатой манере: перебор пар ключ/значение, ключей и значений отдельно осуществляется в порядке их вставки в Map. Размер - количество элементов объекта устанавливается только вручную, количество элементов Map легко получить из его свойства size. Итерация - у Object изначально не реализован протокол итерации, поэтому объекты нельзя перебирать непосредственно циклом for...of по умолчанию (в объекте может быть специально реализован протокол перебора или вы можете получить итератор при помощи Object.keys() или Object.entries(), а также возможен перебор перечисляемых свойств при помощи выражения for...in). Map итерируем, так что это можно делать напрямую. Производительность - не оптимизирована у объектов мз-за частого добавления и удаления пар ключ/значение, у Map сценарии быстрого добавления и удаления реализованы лучше. Например, у Map можно добавлять свойства, как объектам:\nlet wrongMap = new Map()\nwrongMap['bla'] = 'blaa'\nwrongMap['bla2'] = 'blaaa2'\nconsole.log(wrongMap)  // Map { bla: 'blaa', bla2: 'blaaa2' }\nНо в таком случае эти свойства не взаимодействуют как следует со структурой данных Map и не будут доступны Map-запросам:\nwrongMap.has('bla')    // false\nwrongMap.delete('bla') // false\nИспользование объекта Map:\nlet myMap = new Map()\nlet keyString = 'a string';\nlet keyObj = {};\nlet keyFunc = function() {};\nmyMap.set(keyString, \"value associated with 'a string'\");\nmyMap.set(keyObj, 'value associated with keyObj');\nmyMap.set(keyFunc, 'value associated with keyFunc');\nmyMap.size; // 3\nmyMap.get(keyString);// \"value associated with 'a string'\"\nmyMap.get(keyObj); // \"value associated with keyObj\"\nmyMap.get(keyFunc); // \"value associated with keyFunc\"\nmyMap.get('a string'); // \"value associated with 'a string'\", because keyString === 'a string'\nmyMap.get({}); // undefined, because keyObj !== {}\nmyMap.get(function() {}); // undefined, because keyFunc !== function () {}\nMap, как и объекты, можно клонировать, будет получена неглубокая копия:\nlet original = new Map([\n  [1, 'one']\n]);\nlet clone = new Map(original);\nconsole.log(clone.get(1)); // one\nconsole.log(original === clone); // false (useful for shallow comparison)\nМожно сливать объекты Map, под тем же ключом будет записано значение более поздно добавляемого элемента.\nlet first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\nlet second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n// Spread operator essentially converts a Map to an Array\nlet merged = new Map([...first, ...second])\nconsole.log(merged.get(1)) // uno\nconsole.log(merged.get(2)) // dos\nconsole.log(merged.get(3)) // three\nТакже Map можно сливать с массивами:\nlet merged = new Map([...first, ...second, [1, 'eins']]);\nconsole.log(merged.get(1)); // eins\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three ",
      "objects": [
        {
          "name": "Map()",
          "classDeck": "card",
          "deck": "Map",
          "type": "constructor",
          "description": "конструктор создания объектов Map. Синтаксис - \nnew Map(iterable)\nгде iterable - необязательный параметр, массив или другой итерируемый объект, чьими элементами являются пары ключ/значение. Каждая пара будет добавлена в объект Map. \nlet myMap = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\nНет поддержки в IE.",
          "id": 32.1
        },
        {
          "name": "Map.prototype.clear()",
          "classDeck": "card",
          "deck": "Map",
          "type": "method",
          "description": "метод в синтаксисе \nmyMap.clear() \nудаляет из объекта Map все элементы. Возвращает undefined.",
          "id": 32.11
        },
        {
          "name": "Map.prototype.delete()",
          "classDeck": "card",
          "deck": "Map",
          "type": "method",
          "description": "метод в синтаксисе \nmyMap.delete(key) \nудаляет из объекта Map определенный элемент под ключом key. Метод возвращает true, если элемент существовал и был удален, или false, если такого элемента нет. \nvar myMap = new Map();\nmyMap.set('bar', 'foo');\nmyMap.delete('bar'); // true\nmyMap.has('bar');    // false. The \"bar\" element is no longer present.",
          "id": 32.12
        },
        {
          "name": "Map.prototype.entries()",
          "classDeck": "card",
          "deck": "Map",
          "type": "method",
          "description": "метод в синтаксисе \nmyMap.entries()\nвозвращает новый объект Iterator, содержащий пары ключ/значение для каждого элемента в объекте Map в порядке их вставки. В конкретном случае объект Iterator сам является итерабельным и возможен доступ к элементам через цикл for...of (кроме \"приивычного\" .next.value). Когда используется протокол [Symbol.iterator] - он возвращает такую функцию, когда вызван - возвращает непосредственно итератор. \nlet myMap = new Map()\nmyMap.set('0', 'foo')\nmyMap.set(1, 'bar')\nmyMap.set({}, 'baz')\nlet mapIter = myMap.entries()\nfor (let [index, item] of mapIter) {\n    console.log(index, item);\n}\nили\nconsole.log(mapIter.next().value)  // [\"0\", \"foo\"]\nconsole.log(mapIter.next().value)  // [1, \"bar\"]\nconsole.log(mapIter.next().value)  // [Object, \"baz\"]\nНет поддержки в IE.",
          "id": 32.13
        },
        {
          "name": "Map.prototype.forEach()",
          "classDeck": "card",
          "deck": "Map",
          "type": "method",
          "description": "метод в синтаксисе \nmyMap.forEach(callback(value, key, map), thisArg) \nзапускает предоставленную колбэк-функцию по одному разу для каждой пары ключ/значение в объекте Map в порядке вставки. Для удаленных ключей метод не вызывается (даже если они вставлены обратно до завершения работы метода), но вызывается для представленных значений, равных undefined. Новые значение, вставленные в Map до завершения работы метода, будут им обработаны. \nКолбэк принимает три аргумента - ключ, значение и объект Map. Можно указать аргумент thisArg, тогда он будет расцениваться колбэком как значение this. Метод возвращает undefined. \nfunction logMapElements(value, key, map) {\n    console.log(`map.get('${key}') = ${value}`);\n}\nnew Map([['foo', 3], ['bar', {}], ['baz', undefined]]).forEach(logMapElements);\n// logs:\n// \"map.get('foo') = 3\"\n// \"map.get('bar') = [object Object]\"\n// \"map.get('baz') = undefined\"",
          "id": 32.14
        },
        {
          "name": "Map.prototype.get()",
          "classDeck": "card",
          "deck": "Map",
          "type": "method",
          "description": "метод в синтаксисе \nmyMap.get(key) \nвозвращает определенный элемент объекта Map. Если значением элемента является объект, будет возвращена ссылка на него и любые внесенные в этот объект изменения приведут к изменениям внутри Map. При отсутствии искомого элемента вернется undefined. ",
          "id": 32.15
        },
        {
          "name": "Map.prototype.has()",
          "classDeck": "card",
          "deck": "Map",
          "type": "method",
          "description": "метод в синтаксисе \nmyMap.has(key) \nвозвращает булево значение в зависимости от того, имеется ли в объекте Map элемент под ключом key. ",
          "id": 32.16
        },
        {
          "name": "Map.prototype.keys()",
          "classDeck": "card",
          "deck": "Map",
          "type": "method",
          "description": "метод в синтаксисе \nmyMap.keys()\nвозвращает новый объект итератора, содержащий ключи каждого элемента в объекте Map в порядке их вставки. Доступ к полученным элементам осуществляется через .next().value\nvar myMap = new Map();\nmyMap.set('0', 'foo');\nmyMap.set(1, 'bar');\nmyMap.set({}, 'baz');\nvar mapIter = myMap.keys();\nconsole.log(mapIter.next().value); // \"0\"\nconsole.log(mapIter.next().value); // 1\nconsole.log(mapIter.next().value); // Object\nНет поддержки в IE.",
          "id": 32.17
        },
        {
          "name": "Map.prototype.set()",
          "classDeck": "card",
          "deck": "Map",
          "type": "method",
          "description": "метод в синтаксисе \nmyMap.set(key, value) \nдобавляет или обновляет имеющийся элемент в Map под указанным ключом key и новым значением value. Метод вовзаращет объект Map, так что возможна его работа по цепочке:\nmyMap.set('bar', 'foo')\n     .set(1, 'foobar')\n     .set(2, 'baz');",
          "id": 32.18
        },
        {
          "name": "Map.prototype.size",
          "classDeck": "card",
          "deck": "Map",
          "type": "property",
          "description": "свойство-геттер, возвращающее количество элементов объекта Map. Это целое число, демонстрирующее как много записей содержит Map. Сеттер этого свойства установлен в undefined, вы не можете его изменить. ",
          "id": 32.19
        },
        {
          "name": "Map.prototype.values()",
          "classDeck": "card",
          "deck": "Map",
          "type": "method",
          "description": "метод в синтаксисе \nmyMap.values() \nвозвращает новый объект Iterator, содержащий значения каждого элемента в Map в порядке вставки этих элементов. Доступ к значениям осуществляется также через .next().value\nvar myMap = new Map();\nmyMap.set('0', 'foo');\nmyMap.set(1, 'bar');\nmyMap.set({}, 'baz');\nvar mapIter = myMap.values();\nconsole.log(mapIter.next().value); // \"foo\"\nconsole.log(mapIter.next().value); // \"bar\"\nconsole.log(mapIter.next().value); // \"baz\"\nНет поддержки в IE.",
          "id": 32.2
        },
        {
          "name": "Map.prototype[Symbol.iterator]()",
          "classDeck": "card",
          "deck": "Map",
          "type": "method",
          "description": "значение свойства, вызываемого методом в синтаксисе \nmyMap[Symbol.iterator]()\nто же, что и у метода \nMap.prototype.entries() - это функция итерации. Доступ к очередному объекту осуществляется через .next().value\nconst myMap = new Map();\nmyMap.set('0', 'foo');\nmyMap.set(1, 'bar');\nmyMap.set({}, 'baz');\nconst mapIter = myMap[Symbol.iterator]();\nconsole.log(mapIter.next().value); // [\"0\", \"foo\"]\nconsole.log(mapIter.next().value); // [1, \"bar\"]\nconsole.log(mapIter.next().value); // [Object, \"baz\"]\nили в цикле for...of\nfor (const entry of myMap) {\n  console.log(entry);\n}// [\"0\", \"foo\"], [1, \"bar\"], [{}, \"baz\"]\nfor (const [key, value] of myMap) {\n  console.log(`${key}: ${value}`);\n}// 0: foo, 1: bar, [Object]: baz\nНет поддержки в IE.",
          "id": 32.21
        },
        {
          "name": "Map[Symbol.species]",
          "classDeck": "card",
          "deck": "Map",
          "type": "property getter",
          "description": "свойство-геттер, возвращающее конструктор Map. \nMap[Symbol.species]; // function Map()\nКонструкторы подклассов могут перезаписывать его. Поэтому, если вы хотите, чтобы возвращался конструктор всего класса, необходимо прямо это указать:\nclass MyMap extends Map {\n  // Overwrite MyMap species to the parent Map constructor\n  static get [Symbol.species]() { return Map; }\n}\nНет поддержки в IE.",
          "id": 32.22
        }
      ],
      "id": 32
    },
    {
      "name": "Math",
      "classDeck": "deck",
      "deck": "Math",
      "type": "Math",
      "description": "встроенный объект, имеющий свойства и методы для математических констант и функций. Это не функциональный объект, все его методы являются статическими. Работает с типом данных Number, не работает с BigInt.\nВ отличие от других глобальных объектов, Math - не конструктор, все его методы статические. Вы ссылаетесь на константу пи обращением к Math.PI и вызываете функицю синуса как Math.sin(x), где х - аргумент метода. Константы определены с максимальной точностью реальных цифр в JavaScript. У многих функций точность зависит от реализации. Это значит, что в разных браузерах это дает различный результат. Даже один и тот же движок в различных ОС или архитектурах дает разные результаты!",
      "objects": [
        {
          "name": "Math.abs()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "метод в синтаксисе \nMath.abs(x) \nвозвращает абсолютное значение (модуль) числа х. \nMath.abs('-1');// 1\nMath.abs(-2);// 2\nMath.abs(null);// 0\nMath.abs('');// 0\nMath.abs([]);// 0\nMath.abs([2]);// 2\nMath.abs([1,2]);// NaN\nMath.abs({});// NaN\nMath.abs('string');// NaN\nMath.abs();// NaN",
          "id": 33.1
        },
        {
          "name": "Math.acos()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.acos(x) \nвозвращает арккосинус числа x (от 1 до -1) в радианах. Если x выходит за пределы значения, вернет NaN. \nMath.acos(-2);// NaN\nMath.acos(-1);// 3.141592653589793\nMath.acos(0);// 1.5707963267948966",
          "id": 33.11
        },
        {
          "name": "Math.acosh()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.acosh(x) \nвозвращает гиперболический арккосинус числа x (если х меньше 1, вернет NaN). \nMath.acosh(0.5); // NaN\nMath.acosh(1); // 0\nMath.acosh(2); // 1.3169578969248166\nНе поддерживается в IE.",
          "id": 33.12
        },
        {
          "name": "Math.asin()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.asin(x)\nвозвращает арксинус числа х (от -1 до 1) в радианах. Если х выходит за пределы этих значений, вернет NaN. \nMath.asin(-2);// NaN\nMath.asin(-1);// -1.5707963267948966 (-pi/2)\nMath.asin(0); // 0",
          "id": 33.13
        },
        {
          "name": "Math.asinh()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.asinh(х) \nвозвращает гиперболический арксинус числа x. \nMath.asinh(1);// 0.881373587019543\nMath.asinh(0);// 0\nНе поддерживается в IE",
          "id": 33.14
        },
        {
          "name": "Math.atan()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.atan(x) \nвозвращает арктангенс числа х в радианах. \nMath.atan(1);// 0.7853981633974483\nMath.atan(0);// 0\nMath.atan(-0);// -0\nMath.atan(Infinity);//  1.5707963267948966\nMath.atan(-Infinity);// -1.5707963267948966",
          "id": 33.15
        },
        {
          "name": "Math.atan2()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.atan2(y, x) \nвозвращает угол на плоскости (в радианах), образующийся между положительной осью абсцисс и лучом с началом в точке (0, 0), проходящим через точку (x, y). Возвращает число, лежащее между пи и -пи. Метод Math.atan() отличается от данного тем, что получает в качестве аргумента соотношение координат. \nMath.atan2(90, 15); // 1.4056476493802699\nMath.atan2(15, 90); // 0.16514867741462683\nMath.atan2(±0, -0);// ±PI.\nMath.atan2(±0, +0);// ±0.\nMath.atan2(±0, -x);// ±PI for x > 0.\nMath.atan2(±0, x);// ±0 for x > 0.\nMath.atan2(-y, ±0);// -PI/2 for y > 0.\nMath.atan2(y, ±0);// PI/2 for y > 0.\nMath.atan2(±y, -Infinity);// ±PI for finite y > 0.\nMath.atan2(±y, +Infinity);// ±0 for finite y > 0.\nMath.atan2(±Infinity, x);// ±PI/2 for finite x.\nMath.atan2(±Infinity, -Infinity); // ±3*PI/4.\nMath.atan2(±Infinity, +Infinity); // ±PI/4.",
          "id": 33.16
        },
        {
          "name": "Math.atanh()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static.method",
          "description": "функция в синтаксисе \nMath.atanh(x) \nвозвращает гиперболический арктангенс числа x (х должно быть в диапазоне от 1 до -1, иначе вернет NaN).\nMath.atanh(-2);// NaN\nMath.atanh(-1);// -Infinity\nMath.atanh(0);// 0\nMath.atanh(0.5);// 0.5493061443340548\nMath.atanh(1);// Infinity\nMath.atanh(2);// NaN\nНе поддерживается в IE. ",
          "id": 33.17
        },
        {
          "name": "Math.cbrt()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.cbrt(x) \nвозвращает кубический корень числа x.\nMath.cbrt(NaN); // NaN\nMath.cbrt(-1); // -1\nMath.cbrt(-0); // -0\nMath.cbrt(Infinity); // Infinity\nMath.cbrt(null); // 0\nMath.cbrt(2);  // 1.2599210498948732\nНе поддерживается в IE. ",
          "id": 33.18
        },
        {
          "name": "Math.ceil()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.ceil(x) \nвсегда округляет число х до бОльшего целого значения. Math.ceil(null) вернет 0. \nMath.ceil(.95);// 1\nMath.ceil(4);// 4\nMath.ceil(7.004);// 8\nMath.ceil(-0.95);// -0\nMath.ceil(-4);// -4\nMath.ceil(-7.004);// -7",
          "id": 33.19
        },
        {
          "name": "Math.clz32()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.clz32(x) \nвозвращает количество начинающихся с нуля битов в числе х, представленном в 32-битной системе счисления. clz32 = CountLeadingZeroes32. Если аргумент x - не число, он будет приведен к числу, а затем переведен в 32-битную систему счисления. Если это 0, вернется 32 (все 32 бита - нули). Метод полезен для систем, компилирующихся в JavaScript. Не поддерживается в IE. ",
          "id": 33.2
        },
        {
          "name": "Math.cos()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.cos(x) \nвозвращает косинус (число в диапазоне от -1 до 1) установленного угла х (должен быть в радианах). Значение равно длине прилегающей гипотенузы. \nMath.cos(0);// 1\nMath.cos(1);// 0.5403023058681398\nMath.cos(Math.PI);// -1",
          "id": 33.21
        },
        {
          "name": "Math.cosh()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.cosh(х) \nвозвращает гиперболический косинус числа х, который может быть выражен в константе e (Math.E).\nMath.cosh(0);  // 1\nMath.cosh(1);  // 1.5430806348152437\nMath.cosh(-1); // 1.5430806348152437\nНе поддерживается в IE. ",
          "id": 33.22
        },
        {
          "name": "Math.E",
          "classDeck": "card",
          "deck": "Math",
          "type": "static property",
          "description": "число Эйлера, основание натуральных логарифмов, е, примерно равное 2.718. Свойство незаписываемое, неперечисляемое, неизменяемое.",
          "id": 33.23
        },
        {
          "name": "Math.exp()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.exp(x) \nвозвращает число Эйлера e в степени числа x - основание натурального логарифма. \nMath.exp(-1); // 0.36787944117144233\nMath.exp(0);  // 1\nMath.exp(1);  // 2.718281828459045",
          "id": 33.24
        },
        {
          "name": "Math.expm1()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.expm1(x) \nвозвращает значение е в степени х - 1, где x - аргумент и e - число Эйлера, основание натурального логарифма.\nMath.expm1(-1); // -0.6321205588285577\nMath.expm1(0);  // 0\nMath.expm1(1);  // 1.718281828459045\nНе поддерживается в IE. ",
          "id": 33.25
        },
        {
          "name": "Math.floor()",
          "classDeck": "card",
          "deck": "Math",
          "type": "static method",
          "description": "функция в синтаксисе \nMath.floor(x) \nвозвращает наибольшее из целых чисел, меньшее или равное числу х (округляет число в меньшую сторону). Math.floor(null) вернет 0. \nMath.floor(45.95); //  45\nMath.floor(45.05); //  45\nMath.floor(-45.05); // -46",
          "id": 33.26
        }
      ],
      "id": 33
    }
  ]
}